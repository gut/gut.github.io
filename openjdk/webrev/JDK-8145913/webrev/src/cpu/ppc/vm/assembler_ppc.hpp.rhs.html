<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev 8345 : Backport of "<a href="https://bugs.openjdk.java.net/browse/JDK-8145913">8145913</a>: PPC64: add Montgomery multiply intrinsic"</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright 2012, 2013 SAP AG. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_VM_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_VM_ASSEMBLER_PPC_HPP
  28 
  29 #include "asm/register.hpp"
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 // So far we do not use this as simplification by this class is low
  35 // on PPC with its simple addressing mode. Use RegisterOrConstant to
  36 // represent an offset.
  37 class Address VALUE_OBJ_CLASS_SPEC {
  38 };
  39 
  40 class AddressLiteral VALUE_OBJ_CLASS_SPEC {
  41  private:
  42   address          _address;
  43   RelocationHolder _rspec;
  44 
  45   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  46     switch (rtype) {
  47     case relocInfo::external_word_type:
  48       return external_word_Relocation::spec(addr);
  49     case relocInfo::internal_word_type:
  50       return internal_word_Relocation::spec(addr);
  51     case relocInfo::opt_virtual_call_type:
  52       return opt_virtual_call_Relocation::spec();
  53     case relocInfo::static_call_type:
  54       return static_call_Relocation::spec();
  55     case relocInfo::runtime_call_type:
  56       return runtime_call_Relocation::spec();
  57     case relocInfo::none:
  58       return RelocationHolder();
  59     default:
  60       ShouldNotReachHere();
  61       return RelocationHolder();
  62     }
  63   }
  64 
  65  protected:
  66   // creation
  67   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  68 
  69  public:
  70   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  71     : _address(addr),
  72       _rspec(rspec) {}
  73 
  74   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
  75     : _address((address) addr),
  76       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
  77 
  78   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
  79     : _address((address) addr),
  80       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
  81 
  82   intptr_t value() const { return (intptr_t) _address; }
  83 
  84   const RelocationHolder&amp; rspec() const { return _rspec; }
  85 };
  86 
  87 // Argument is an abstraction used to represent an outgoing
  88 // actual argument or an incoming formal parameter, whether
  89 // it resides in memory or in a register, in a manner consistent
  90 // with the PPC Application Binary Interface, or ABI. This is
  91 // often referred to as the native or C calling convention.
  92 
  93 class Argument VALUE_OBJ_CLASS_SPEC {
  94  private:
  95   int _number;  // The number of the argument.
  96  public:
  97   enum {
  98     // Only 8 registers may contain integer parameters.
  99     n_register_parameters = 8,
 100     // Can have up to 8 floating registers.
 101     n_float_register_parameters = 8,
 102 
 103     // PPC C calling conventions.
 104     // The first eight arguments are passed in int regs if they are int.
 105     n_int_register_parameters_c = 8,
 106     // The first thirteen float arguments are passed in float regs.
 107     n_float_register_parameters_c = 13,
 108     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 109     // shows that xlC places all float args after argument 8 on the stack AND
 110     // in a register. This is not documented, but we follow this convention, too.
 111     n_regs_not_on_stack_c = 8,
 112   };
 113   // creation
 114   Argument(int number) : _number(number) {}
 115 
 116   int  number() const { return _number; }
 117 
 118   // Locating register-based arguments:
 119   bool is_register() const { return _number &lt; n_register_parameters; }
 120 
 121   Register as_register() const {
 122     assert(is_register(), "must be a register argument");
 123     return as_Register(number() + R3_ARG1-&gt;encoding());
 124   }
 125 };
 126 
 127 #if !defined(ABI_ELFv2)
 128 // A ppc64 function descriptor.
 129 struct FunctionDescriptor VALUE_OBJ_CLASS_SPEC {
 130  private:
 131   address _entry;
 132   address _toc;
 133   address _env;
 134 
 135  public:
 136   inline address entry() const { return _entry; }
 137   inline address toc()   const { return _toc; }
 138   inline address env()   const { return _env; }
 139 
 140   inline void set_entry(address entry) { _entry = entry; }
 141   inline void set_toc(  address toc)   { _toc   = toc; }
 142   inline void set_env(  address env)   { _env   = env; }
 143 
 144   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 145   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 146   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 147 
 148   // Friend functions can be called without loading toc and env.
 149   enum {
 150     friend_toc = 0xcafe,
 151     friend_env = 0xc0de
 152   };
 153 
 154   inline bool is_friend_function() const {
 155     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 156   }
 157 
 158   // Constructor for stack-allocated instances.
 159   FunctionDescriptor() {
 160     _entry = (address) 0xbad;
 161     _toc   = (address) 0xbad;
 162     _env   = (address) 0xbad;
 163   }
 164 };
 165 #endif
 166 
 167 class Assembler : public AbstractAssembler {
 168  protected:
 169   // Displacement routines
 170   static void print_instruction(int inst);
 171   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 172   static int  branch_destination(int inst, int pos);
 173 
 174   friend class AbstractAssembler;
 175 
 176   // Code patchers need various routines like inv_wdisp()
 177   friend class NativeInstruction;
 178   friend class NativeGeneralJump;
 179   friend class Relocation;
 180 
 181  public:
 182 
 183   enum shifts {
 184     XO_21_29_SHIFT = 2,
 185     XO_21_30_SHIFT = 1,
 186     XO_27_29_SHIFT = 2,
 187     XO_30_31_SHIFT = 0,
 188     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 189     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 190     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 191     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 192   };
 193 
 194   enum opcdxos_masks {
 195     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 196     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 197     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 198     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 199     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 200     // trap instructions
 201     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 202     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 203     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 204     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 205     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 206     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 207     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 208     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 209     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 210     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 211     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 212     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 213     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 214     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 215     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 216     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 217     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 218   };
 219 
 220   enum opcdxos {
 221     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 222     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 223     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 224     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 225     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 226     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 227     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 228     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 229     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 230     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 231     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 232     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 233     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 234     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 235     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 236     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 237     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 238     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 239     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 240     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 241     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 242     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 243     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 244     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 245     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 246     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 247     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 248 
 249     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 250 
 251     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 252     CLRRWI_OPCODE = RLWINM_OPCODE,
 253     CLRLWI_OPCODE = RLWINM_OPCODE,
 254 
 255     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 256 
 257     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 258     SLWI_OPCODE   = RLWINM_OPCODE,
 259     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 260     SRWI_OPCODE   = RLWINM_OPCODE,
 261     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 262     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 263 
 264     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 265     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 266     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 267     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 268 
 269     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 270 
 271     // Special purpose registers
 272     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 273     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 274 
 275     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 276     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 277 
 278     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 279     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 280 
 281     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 282     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 283 
 284     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 285     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 286 
 287     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 128 &lt;&lt; SPR_0_4_SHIFT),
 288     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 128 &lt;&lt; SPR_0_4_SHIFT),
 289     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 129 &lt;&lt; SPR_0_4_SHIFT),
 290     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 129 &lt;&lt; SPR_0_4_SHIFT),
 291     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 130 &lt;&lt; SPR_0_4_SHIFT),
 292     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 130 &lt;&lt; SPR_0_4_SHIFT),
 293     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 131 &lt;&lt; SPR_0_4_SHIFT),
 294     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 131 &lt;&lt; SPR_0_4_SHIFT),
 295 
 296     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 256 &lt;&lt; SPR_0_4_SHIFT),
 297     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 256 &lt;&lt; SPR_0_4_SHIFT),
 298 
 299     MFTB_OPCODE   = (MFSPR_OPCODE | 268 &lt;&lt; SPR_0_4_SHIFT),
 300 
 301     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 302     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 303     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 304 
 305     // condition register logic instructions
 306     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 307     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 308     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 309     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 310     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 311     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 312     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 313     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 314 
 315     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 316     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 317     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 318 
 319     // CTR-related opcodes
 320     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 321 
 322     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 323     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 324     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 325     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 326 
 327     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 328     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 329     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 330 
 331     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 332     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 333     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 334     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 335 
 336     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 337     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 338     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 339 
 340     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 341     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 342     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 343     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 344 
 345     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 346     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 347     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 348 
 349     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 350     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 351     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 352 
 353     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 354     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 355     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 356 
 357     // 32 bit opcode encodings
 358 
 359     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 360     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 361 
 362     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 363 
 364     // 64 bit opcode encodings
 365 
 366     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 367     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 368     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 369 
 370     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 371     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 372     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),                  // X-FORM
 373     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 374 
 375     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 376     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 377     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 378     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 379 
 380     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 381 
 382     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 383     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 384     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 385 
 386     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 387     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 388     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 389     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 390 
 391     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 392     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 393     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 394 
 395 
 396     // opcodes only used for floating arithmetic
 397     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 398     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 399     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 400     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 401     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 402     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
 403     // These are special Power6 opcodes, reused for "lfdepx" and "stfdepx"
 404     // on Power7.  Do not use.
 405     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 406     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 407     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 408     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 409     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 410     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 411     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 412     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 413     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 414     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 415     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 416     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 417     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 418 
 419     // PPC64-internal FPU conversion opcodes
 420     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 421     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 422     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 423     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 424     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 425     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 426     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 427 
 428     // WARNING: using fmadd results in a non-compliant vm. Some floating
 429     // point tck tests will fail.
 430     FMADD_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 431     DMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 432     FMSUB_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 433     DMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 434     FNMADD_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 435     DNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 436     FNMSUB_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 437     DNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 438 
 439     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 440     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 441     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 442     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 443     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 444     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 445 
 446     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 447     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 448     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 449     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 450     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 451     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 452 
 453     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 454     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 455 
 456     // Vector instruction support for &gt;= Power6
 457     // Vector Storage Access
 458     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 459     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 460     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 461     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 462     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 463     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 464     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 465     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 466     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 467     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 468     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 469     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 470 
 471     // Vector Permute and Formatting
 472     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 473     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 474     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 475     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 476     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 477     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 478     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 479     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 480     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 481     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 482     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 483     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 484     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 485     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 486     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 487 
 488     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 489     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 490     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 491     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 492     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 493     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 494 
 495     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 496     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 497     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 498     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 499     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 500     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 501 
 502     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 503     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 504 
 505     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 506     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 507     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 508     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 509     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 510 
 511     // Vector Integer
 512     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 513     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 514     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 515     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 516     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 517     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 518     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
 519     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 520     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 521     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 522     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 523     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 524     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 525     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 526     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 527     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 528     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 529     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 530     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 531     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 532 
 533     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 534     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 535     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 536     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 537     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 538     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 539     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 540     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 541     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 542     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 543     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 544     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 545     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 546     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 547     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 548     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 549     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 550 
 551     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 552     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 553     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 554     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 555     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 556 
 557     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 558     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 559     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 560     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 561     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 562     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 563 
 564     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 565     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 566     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 567     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 568     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 569     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 570     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 571     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 572     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 573     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 574     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 575     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 576 
 577     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 578     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 579     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 580     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 581     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 582     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 583     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 584     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 585     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 586 
 587     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 588     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 589     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 590     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 591     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 592     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 593     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 594     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 595     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 596     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 597     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 598     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 599     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 600     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 601     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 602     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 603     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 604     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 605 
 606     // Vector Floating-Point
 607     // not implemented yet
 608 
 609     // Vector Status and Control
 610     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 611     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 612 
 613     // AES (introduced with Power 8)
 614     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 615     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 616     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 617     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 618     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 619 
 620     // SHA (introduced with Power 8)
 621     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 622     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 623 
 624     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 625     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 626     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 627     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 628     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 629 
 630     // Vector Permute and Xor (introduced with Power 8)
 631     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 632 
 633     // Transactional Memory instructions (introduced with Power 8)
 634     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 635     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 636     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 637     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 638     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 639     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 640     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 641     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 642     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 643 
 644     // Icache and dcache related instructions
 645     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 646     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 647     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 648     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 649 
 650     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 651     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 652     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 653 
 654     // Instruction synchronization
 655     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 656     // Memory barriers
 657     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 658     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 659 
 660     // Trap instructions
 661     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 662     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 663     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 664     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 665 
 666     // Atomics.
 667     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 668     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 669     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 670     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1)
 671 
 672   };
 673 
 674   // Trap instructions TO bits
 675   enum trap_to_bits {
 676     // single bits
 677     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 678     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 679     traptoEqual               = 1 &lt;&lt; 2,
 680     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 681     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 682 
 683     // compound ones
 684     traptoUnconditional       = (traptoLessThanSigned |
 685                                  traptoGreaterThanSigned |
 686                                  traptoEqual |
 687                                  traptoLessThanUnsigned |
 688                                  traptoGreaterThanUnsigned)
 689   };
 690 
 691   // Branch hints BH field
 692   enum branch_hint_bh {
 693     // bclr cases:
 694     bhintbhBCLRisReturn            = 0,
 695     bhintbhBCLRisNotReturnButSame  = 1,
 696     bhintbhBCLRisNotPredictable    = 3,
 697 
 698     // bcctr cases:
 699     bhintbhBCCTRisNotReturnButSame = 0,
 700     bhintbhBCCTRisNotPredictable   = 3
 701   };
 702 
 703   // Branch prediction hints AT field
 704   enum branch_hint_at {
 705     bhintatNoHint     = 0,  // at=00
 706     bhintatIsNotTaken = 2,  // at=10
 707     bhintatIsTaken    = 3   // at=11
 708   };
 709 
 710   // Branch prediction hints
 711   enum branch_hint_concept {
 712     // Use the same encoding as branch_hint_at to simply code.
 713     bhintNoHint       = bhintatNoHint,
 714     bhintIsNotTaken   = bhintatIsNotTaken,
 715     bhintIsTaken      = bhintatIsTaken
 716   };
 717 
 718   // Used in BO field of branch instruction.
 719   enum branch_condition {
 720     bcondCRbiIs0      =  4, // bo=001at
 721     bcondCRbiIs1      = 12, // bo=011at
 722     bcondAlways       = 20  // bo=10100
 723   };
 724 
 725   // Branch condition with combined prediction hints.
 726   enum branch_condition_with_hint {
 727     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 728     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 729     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 730     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 731     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 732     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 733   };
 734 
 735   // Elemental Memory Barriers (&gt;=Power 8)
 736   enum Elemental_Membar_mask_bits {
 737     StoreStore = 1 &lt;&lt; 0,
 738     StoreLoad  = 1 &lt;&lt; 1,
 739     LoadStore  = 1 &lt;&lt; 2,
 740     LoadLoad   = 1 &lt;&lt; 3
 741   };
 742 
 743   // Branch prediction hints.
 744   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 745     switch (boint) {
 746       case bcondCRbiIs0:
 747       case bcondCRbiIs1:
 748         // branch_hint and branch_hint_at have same encodings
 749         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 750                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 751                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 752                "wrong encodings");
 753         assert((bhint &amp; 0x03) == bhint, "wrong encodings");
 754         return (boint &amp; ~0x03) | bhint;
 755       case bcondAlways:
 756         // no branch_hint
 757         return boint;
 758       default:
 759         ShouldNotReachHere();
 760         return 0;
 761     }
 762   }
 763 
 764   // Extract bcond from boint.
 765   inline static int inv_boint_bcond(const int boint) {
 766     int r_bcond = boint &amp; ~0x03;
 767     assert(r_bcond == bcondCRbiIs0 ||
 768            r_bcond == bcondCRbiIs1 ||
 769            r_bcond == bcondAlways,
 770            "bad branch condition");
 771     return r_bcond;
 772   }
 773 
 774   // Extract bhint from boint.
 775   inline static int inv_boint_bhint(const int boint) {
 776     int r_bhint = boint &amp; 0x03;
 777     assert(r_bhint == bhintatNoHint ||
 778            r_bhint == bhintatIsNotTaken ||
 779            r_bhint == bhintatIsTaken,
 780            "bad branch hint");
 781     return r_bhint;
 782   }
 783 
 784   // Calculate opposite of given bcond.
 785   inline static int opposite_bcond(const int bcond) {
 786     switch (bcond) {
 787       case bcondCRbiIs0:
 788         return bcondCRbiIs1;
 789       case bcondCRbiIs1:
 790         return bcondCRbiIs0;
 791       default:
 792         ShouldNotReachHere();
 793         return 0;
 794     }
 795   }
 796 
 797   // Calculate opposite of given bhint.
 798   inline static int opposite_bhint(const int bhint) {
 799     switch (bhint) {
 800       case bhintatNoHint:
 801         return bhintatNoHint;
 802       case bhintatIsNotTaken:
 803         return bhintatIsTaken;
 804       case bhintatIsTaken:
 805         return bhintatIsNotTaken;
 806       default:
 807         ShouldNotReachHere();
 808         return 0;
 809     }
 810   }
 811 
 812   // PPC branch instructions
 813   enum ppcops {
 814     b_op    = 18,
 815     bc_op   = 16,
 816     bcr_op  = 19
 817   };
 818 
 819   enum Condition {
 820     negative         = 0,
 821     less             = 0,
 822     positive         = 1,
 823     greater          = 1,
 824     zero             = 2,
 825     equal            = 2,
 826     summary_overflow = 3,
 827   };
 828 
 829  public:
 830   // Helper functions for groups of instructions
 831 
 832   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 833 
 834   // instruction must start at passed address
 835   static int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 836 
 837   // instruction must be left-justified in argument
 838   static int instr_len(unsigned long instr)  { return BytesPerInstWord; }
 839 
 840   // longest instructions
 841   static int instr_maxlen() { return BytesPerInstWord; }
 842 
 843   // Test if x is within signed immediate range for nbits.
 844   static bool is_simm(int x, unsigned int nbits) {
 845     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 846     const int   min      = -( ((int)1) &lt;&lt; nbits-1 );
 847     const int   maxplus1 =  ( ((int)1) &lt;&lt; nbits-1 );
 848     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 849   }
 850 
 851   static bool is_simm(jlong x, unsigned int nbits) {
 852     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 853     const jlong min      = -( ((jlong)1) &lt;&lt; nbits-1 );
 854     const jlong maxplus1 =  ( ((jlong)1) &lt;&lt; nbits-1 );
 855     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 856   }
 857 
 858   // Test if x is within unsigned immediate range for nbits
 859   static bool is_uimm(int x, unsigned int nbits) {
 860     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 861     const int   maxplus1 = ( ((int)1) &lt;&lt; nbits );
 862     return 0 &lt;= x &amp;&amp; x &lt; maxplus1;
 863   }
 864 
 865   static bool is_uimm(jlong x, unsigned int nbits) {
 866     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 867     const jlong maxplus1 =  ( ((jlong)1) &lt;&lt; nbits );
 868     return 0 &lt;= x &amp;&amp; x &lt; maxplus1;
 869   }
 870 
 871  protected:
 872   // helpers
 873 
 874   // X is supposed to fit in a field "nbits" wide
 875   // and be sign-extended. Check the range.
 876   static void assert_signed_range(intptr_t x, int nbits) {
 877     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 878            "value out of range");
 879   }
 880 
 881   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 882     assert((x &amp; 3) == 0, "not word aligned");
 883     assert_signed_range(x, nbits + 2);
 884   }
 885 
 886   static void assert_unsigned_const(int x, int nbits) {
 887     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), "unsigned constant out of range");
 888   }
 889 
 890   static int fmask(juint hi_bit, juint lo_bit) {
 891     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, "bad bits");
 892     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 893   }
 894 
 895   // inverse of u_field
 896   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 897     juint r = juint(x) &gt;&gt; lo_bit;
 898     r &amp;= fmask(hi_bit, lo_bit);
 899     return int(r);
 900   }
 901 
 902   // signed version: extract from field and sign-extend
 903   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
 904     x = x &lt;&lt; (31-hi_bit);
 905     x = x &gt;&gt; (31-hi_bit+lo_bit);
 906     return x;
 907   }
 908 
 909   static int u_field(int x, int hi_bit, int lo_bit) {
 910     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, "value out of range");
 911     int r = x &lt;&lt; lo_bit;
 912     assert(inv_u_field(r, hi_bit, lo_bit) == x, "just checking");
 913     return r;
 914   }
 915 
 916   // Same as u_field for signed values
 917   static int s_field(int x, int hi_bit, int lo_bit) {
 918     int nbits = hi_bit - lo_bit + 1;
 919     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 920       "value out of range");
 921     x &amp;= fmask(hi_bit, lo_bit);
 922     int r = x &lt;&lt; lo_bit;
 923     return r;
 924   }
 925 
 926   // inv_op for ppc instructions
 927   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
 928 
 929   // Determine target address from li, bd field of branch instruction.
 930   static intptr_t inv_li_field(int x) {
 931     intptr_t r = inv_s_field_ppc(x, 25, 2);
 932     r = (r &lt;&lt; 2);
 933     return r;
 934   }
 935   static intptr_t inv_bd_field(int x, intptr_t pos) {
 936     intptr_t r = inv_s_field_ppc(x, 15, 2);
 937     r = (r &lt;&lt; 2) + pos;
 938     return r;
 939   }
 940 
 941   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
 942   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
 943   // Extract instruction fields from instruction words.
 944  public:
 945   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
 946   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
 947   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
 948   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
 949   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
 950   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
 951   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
 952   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
 953   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
 954   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
 955   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
 956   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
 957   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
 958   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
 959 
 960   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
 961   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
 962 
 963   // instruction fields
 964   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
 965   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
 966   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
 967   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
 968   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
 969   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
 970   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
 971   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
 972   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
 973   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
 974   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
 975   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
 976   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
 977   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
 978   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
 979   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, "unaligned offset"); return opp_s_field(x, 31, 16); }
 980   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
 981   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
 982   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
 983   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
 984   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
 985   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
 986   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
 987   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
 988   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
 989   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
 990   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
 991   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
 992   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
 993   static int l10(      int         x)  { return  opp_u_field(x,             10, 10); }
 994   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
 995   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
 996   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
 997   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
 998   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
 999   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1000   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1001   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1002   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1003   static int me2126(   int         x)  { return  mb2126(x); }
1004   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1005   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1006   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1007   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1008   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1009   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1010   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1011   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1012   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1013   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1014   // we don't want to use R0 in memory accesses, because it has value `0' then
1015   static int ra0mem(   Register    r)  { assert(r != R0, "cannot use register R0 in memory access"); return ra(r); }
1016   static int ra0mem(   int         x)  { assert(x != 0,  "cannot use register 0 in memory access");  return ra(x); }
1017 
1018   // register r is target
1019   static int rt(       Register    r)  { return rs(r); }
1020   static int rt(       int         x)  { return rs(x); }
1021   static int rta(      Register    r)  { return ra(r); }
1022   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1023 
1024   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1025   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1026   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1027   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1028   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1029   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1030   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1031   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1032   static int thct(     int         x)  { assert((x&amp;8) == 0, "must be valid cache specification");  return th(x); }
1033   static int thds(     int         x)  { assert((x&amp;8) == 8, "must be valid stream specification"); return th(x); }
1034   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1035   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1036   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1037 
1038   // Support vector instructions for &gt;= Power6.
1039   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1040   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1041   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1042   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1043   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1044 
1045   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1046   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1047   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1048   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1049   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1050 
1051   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1052   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1053   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1054   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1055 
1056   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1057   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1058   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1059   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1060   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1061   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1062   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1063 
1064  protected:
1065   // Compute relative address for branch.
1066   static intptr_t disp(intptr_t x, intptr_t off) {
1067     int xx = x - off;
1068     xx = xx &gt;&gt; 2;
1069     return xx;
1070   }
1071 
1072  public:
1073   // signed immediate, in low bits, nbits long
1074   static int simm(int x, int nbits) {
1075     assert_signed_range(x, nbits);
1076     return x &amp; ((1 &lt;&lt; nbits) - 1);
1077   }
1078 
1079   // unsigned immediate, in low bits, nbits long
1080   static int uimm(int x, int nbits) {
1081     assert_unsigned_const(x, nbits);
1082     return x &amp; ((1 &lt;&lt; nbits) - 1);
1083   }
1084 
1085   static void set_imm(int* instr, short s) {
1086     // imm is always in the lower 16 bits of the instruction,
1087     // so this is endian-neutral. Same for the get_imm below.
1088     uint32_t w = *(uint32_t *)instr;
1089     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1090   }
1091 
1092   static int get_imm(address a, int instruction_number) {
1093     return (short)((int *)a)[instruction_number];
1094   }
1095 
1096   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1097   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1098 
1099  protected:
1100 
1101   // Extract the top 32 bits in a 64 bit word.
1102   static int32_t hi32(int64_t x) {
1103     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1104     return r;
1105   }
1106 
1107  public:
1108 
1109   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1110     return ((addr + (a - 1)) &amp; ~(a - 1));
1111   }
1112 
1113   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1114     return (0 == addr % a);
1115   }
1116 
1117   void flush() {
1118     AbstractAssembler::flush();
1119   }
1120 
1121   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1122   inline void emit_data(int);
1123   inline void emit_data(int, RelocationHolder const&amp;);
1124   inline void emit_data(int, relocInfo::relocType rtype);
1125 
1126   // Emit an address.
1127   inline address emit_addr(const address addr = NULL);
1128 
1129 #if !defined(ABI_ELFv2)
1130   // Emit a function descriptor with the specified entry point, TOC,
1131   // and ENV. If the entry point is NULL, the descriptor will point
1132   // just past the descriptor.
1133   // Use values from friend functions as defaults.
1134   inline address emit_fd(address entry = NULL,
1135                          address toc = (address) FunctionDescriptor::friend_toc,
1136                          address env = (address) FunctionDescriptor::friend_env);
1137 #endif
1138 
1139   /////////////////////////////////////////////////////////////////////////////////////
1140   // PPC instructions
1141   /////////////////////////////////////////////////////////////////////////////////////
1142 
1143   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1144   // immediates. The normal instruction encoders enforce that r0 is not
1145   // passed to them. Use either extended mnemonics encoders or the special ra0
1146   // versions.
1147 
1148   // Issue an illegal instruction.
1149   inline void illtrap();
1150   static inline bool is_illtrap(int x);
1151 
1152   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1153   inline void addi( Register d, Register a, int si16);
1154   inline void addis(Register d, Register a, int si16);
1155  private:
1156   inline void addi_r0ok( Register d, Register a, int si16);
1157   inline void addis_r0ok(Register d, Register a, int si16);
1158  public:
1159   inline void addic_( Register d, Register a, int si16);
1160   inline void subfic( Register d, Register a, int si16);
1161   inline void add(    Register d, Register a, Register b);
1162   inline void add_(   Register d, Register a, Register b);
1163   inline void subf(   Register d, Register a, Register b);  // d = b - a    "Sub_from", as in ppc spec.
1164   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1165   inline void subf_(  Register d, Register a, Register b);
1166   inline void addc(   Register d, Register a, Register b);
1167   inline void addc_(  Register d, Register a, Register b);
1168   inline void subfc(  Register d, Register a, Register b);
1169   inline void subfc_( Register d, Register a, Register b);
1170   inline void adde(   Register d, Register a, Register b);
1171   inline void adde_(  Register d, Register a, Register b);
1172   inline void subfe(  Register d, Register a, Register b);
1173   inline void subfe_( Register d, Register a, Register b);
1174   inline void neg(    Register d, Register a);
1175   inline void neg_(   Register d, Register a);
1176   inline void mulli(  Register d, Register a, int si16);
1177   inline void mulld(  Register d, Register a, Register b);
1178   inline void mulld_( Register d, Register a, Register b);
1179   inline void mullw(  Register d, Register a, Register b);
1180   inline void mullw_( Register d, Register a, Register b);
1181   inline void mulhw(  Register d, Register a, Register b);
1182   inline void mulhw_( Register d, Register a, Register b);
<a name="1" id="anc1"></a><span class="new">1183   inline void mulhwu( Register d, Register a, Register b);</span>
<span class="new">1184   inline void mulhwu_(Register d, Register a, Register b);</span>
1185   inline void mulhd(  Register d, Register a, Register b);
1186   inline void mulhd_( Register d, Register a, Register b);
1187   inline void mulhdu( Register d, Register a, Register b);
1188   inline void mulhdu_(Register d, Register a, Register b);
1189   inline void divd(   Register d, Register a, Register b);
1190   inline void divd_(  Register d, Register a, Register b);
1191   inline void divw(   Register d, Register a, Register b);
1192   inline void divw_(  Register d, Register a, Register b);
1193 
1194   // extended mnemonics
1195   inline void li(   Register d, int si16);
1196   inline void lis(  Register d, int si16);
1197   inline void addir(Register d, int si16, Register a);
1198 
1199   static bool is_addi(int x) {
1200      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1201   }
1202   static bool is_addis(int x) {
1203      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1204   }
1205   static bool is_bxx(int x) {
1206      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1207   }
1208   static bool is_b(int x) {
1209      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1210   }
1211   static bool is_bl(int x) {
1212      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1213   }
1214   static bool is_bcxx(int x) {
1215      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1216   }
1217   static bool is_bxx_or_bcxx(int x) {
1218      return is_bxx(x) || is_bcxx(x);
1219   }
1220   static bool is_bctrl(int x) {
1221      return x == 0x4e800421;
1222   }
1223   static bool is_bctr(int x) {
1224      return x == 0x4e800420;
1225   }
1226   static bool is_bclr(int x) {
1227      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1228   }
1229   static bool is_li(int x) {
1230      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1231   }
1232   static bool is_lis(int x) {
1233      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1234   }
1235   static bool is_mtctr(int x) {
1236      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1237   }
1238   static bool is_ld(int x) {
1239      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1240   }
1241   static bool is_std(int x) {
1242      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1243   }
1244   static bool is_stdu(int x) {
1245      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1246   }
1247   static bool is_stdx(int x) {
1248      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1249   }
1250   static bool is_stdux(int x) {
1251      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1252   }
1253   static bool is_stwx(int x) {
1254      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1255   }
1256   static bool is_stwux(int x) {
1257      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1258   }
1259   static bool is_stw(int x) {
1260      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1261   }
1262   static bool is_stwu(int x) {
1263      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1264   }
1265   static bool is_ori(int x) {
1266      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1267   };
1268   static bool is_oris(int x) {
1269      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1270   };
1271   static bool is_rldicr(int x) {
1272      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1273   };
1274   static bool is_nop(int x) {
1275     return x == 0x60000000;
1276   }
1277   // endgroup opcode for Power6
1278   static bool is_endgroup(int x) {
1279     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1280   }
1281 
1282 
1283  private:
1284   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1285   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1286   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1287   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1288   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1289 
1290  public:
1291   // extended mnemonics of Compare Instructions
1292   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1293   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1294   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1295   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1296   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1297   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1298   inline void cmplw( ConditionRegister crx, Register a, Register b);
1299   inline void cmpld( ConditionRegister crx, Register a, Register b);
1300 
1301   inline void isel(   Register d, Register a, Register b, int bc);
1302   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1303   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1304   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1305   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1306 
1307   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1308          void andi(   Register a, Register s, int ui16);   // optimized version
1309   inline void andi_(  Register a, Register s, int ui16);
1310   inline void andis_( Register a, Register s, int ui16);
1311   inline void ori(    Register a, Register s, int ui16);
1312   inline void oris(   Register a, Register s, int ui16);
1313   inline void xori(   Register a, Register s, int ui16);
1314   inline void xoris(  Register a, Register s, int ui16);
1315   inline void andr(   Register a, Register s, Register b);  // suffixed by 'r' as 'and' is C++ keyword
1316   inline void and_(   Register a, Register s, Register b);
1317   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1318   // SMT-priority change instruction (see SMT instructions below).
1319   inline void or_unchecked(Register a, Register s, Register b);
1320   inline void orr(    Register a, Register s, Register b);  // suffixed by 'r' as 'or' is C++ keyword
1321   inline void or_(    Register a, Register s, Register b);
1322   inline void xorr(   Register a, Register s, Register b);  // suffixed by 'r' as 'xor' is C++ keyword
1323   inline void xor_(   Register a, Register s, Register b);
1324   inline void nand(   Register a, Register s, Register b);
1325   inline void nand_(  Register a, Register s, Register b);
1326   inline void nor(    Register a, Register s, Register b);
1327   inline void nor_(   Register a, Register s, Register b);
1328   inline void andc(   Register a, Register s, Register b);
1329   inline void andc_(  Register a, Register s, Register b);
1330   inline void orc(    Register a, Register s, Register b);
1331   inline void orc_(   Register a, Register s, Register b);
1332   inline void extsb(  Register a, Register s);
1333   inline void extsh(  Register a, Register s);
1334   inline void extsw(  Register a, Register s);
1335 
1336   // extended mnemonics
1337   inline void nop();
1338   // NOP for FP and BR units (different versions to allow them to be in one group)
1339   inline void fpnop0();
1340   inline void fpnop1();
1341   inline void brnop0();
1342   inline void brnop1();
1343   inline void brnop2();
1344 
1345   inline void mr(      Register d, Register s);
1346   inline void ori_opt( Register d, int ui16);
1347   inline void oris_opt(Register d, int ui16);
1348 
1349   // endgroup opcode for Power6
1350   inline void endgroup();
1351 
1352   // count instructions
1353   inline void cntlzw(  Register a, Register s);
1354   inline void cntlzw_( Register a, Register s);
1355   inline void cntlzd(  Register a, Register s);
1356   inline void cntlzd_( Register a, Register s);
1357 
1358   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1359   inline void sld(     Register a, Register s, Register b);
1360   inline void sld_(    Register a, Register s, Register b);
1361   inline void slw(     Register a, Register s, Register b);
1362   inline void slw_(    Register a, Register s, Register b);
1363   inline void srd(     Register a, Register s, Register b);
1364   inline void srd_(    Register a, Register s, Register b);
1365   inline void srw(     Register a, Register s, Register b);
1366   inline void srw_(    Register a, Register s, Register b);
1367   inline void srad(    Register a, Register s, Register b);
1368   inline void srad_(   Register a, Register s, Register b);
1369   inline void sraw(    Register a, Register s, Register b);
1370   inline void sraw_(   Register a, Register s, Register b);
1371   inline void sradi(   Register a, Register s, int sh6);
1372   inline void sradi_(  Register a, Register s, int sh6);
1373   inline void srawi(   Register a, Register s, int sh5);
1374   inline void srawi_(  Register a, Register s, int sh5);
1375 
1376   // extended mnemonics for Shift Instructions
1377   inline void sldi(    Register a, Register s, int sh6);
1378   inline void sldi_(   Register a, Register s, int sh6);
1379   inline void slwi(    Register a, Register s, int sh5);
1380   inline void slwi_(   Register a, Register s, int sh5);
1381   inline void srdi(    Register a, Register s, int sh6);
1382   inline void srdi_(   Register a, Register s, int sh6);
1383   inline void srwi(    Register a, Register s, int sh5);
1384   inline void srwi_(   Register a, Register s, int sh5);
1385 
1386   inline void clrrdi(  Register a, Register s, int ui6);
1387   inline void clrrdi_( Register a, Register s, int ui6);
1388   inline void clrldi(  Register a, Register s, int ui6);
1389   inline void clrldi_( Register a, Register s, int ui6);
1390   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1391   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1392   inline void extrdi(  Register a, Register s, int n, int b);
1393   // testbit with condition register
1394   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1395 
1396   // rotate instructions
1397   inline void rotldi(  Register a, Register s, int n);
1398   inline void rotrdi(  Register a, Register s, int n);
1399   inline void rotlwi(  Register a, Register s, int n);
1400   inline void rotrwi(  Register a, Register s, int n);
1401 
1402   // Rotate Instructions
1403   inline void rldic(   Register a, Register s, int sh6, int mb6);
1404   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1405   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1406   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1407   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1408   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1409   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1410   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1411   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1412   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1413   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1414   inline void insrdi(  Register a, Register s, int n,   int b);
1415   inline void insrwi(  Register a, Register s, int n,   int b);
1416 
1417   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1418   // 4 bytes
1419   inline void lwzx( Register d, Register s1, Register s2);
1420   inline void lwz(  Register d, int si16,    Register s1);
1421   inline void lwzu( Register d, int si16,    Register s1);
1422 
1423   // 4 bytes
1424   inline void lwax( Register d, Register s1, Register s2);
1425   inline void lwa(  Register d, int si16,    Register s1);
1426 
1427   // 4 bytes reversed
1428   inline void lwbrx( Register d, Register s1, Register s2);
1429 
1430   // 2 bytes
1431   inline void lhzx( Register d, Register s1, Register s2);
1432   inline void lhz(  Register d, int si16,    Register s1);
1433   inline void lhzu( Register d, int si16,    Register s1);
1434 
1435   // 2 bytes reversed
1436   inline void lhbrx( Register d, Register s1, Register s2);
1437 
1438   // 2 bytes
1439   inline void lhax( Register d, Register s1, Register s2);
1440   inline void lha(  Register d, int si16,    Register s1);
1441   inline void lhau( Register d, int si16,    Register s1);
1442 
1443   // 1 byte
1444   inline void lbzx( Register d, Register s1, Register s2);
1445   inline void lbz(  Register d, int si16,    Register s1);
1446   inline void lbzu( Register d, int si16,    Register s1);
1447 
1448   // 8 bytes
1449   inline void ldx(  Register d, Register s1, Register s2);
1450   inline void ld(   Register d, int si16,    Register s1);
1451   inline void ldu(  Register d, int si16,    Register s1);
1452 
1453   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1454   inline void stwx( Register d, Register s1, Register s2);
1455   inline void stw(  Register d, int si16,    Register s1);
1456   inline void stwu( Register d, int si16,    Register s1);
1457 
1458   inline void sthx( Register d, Register s1, Register s2);
1459   inline void sth(  Register d, int si16,    Register s1);
1460   inline void sthu( Register d, int si16,    Register s1);
1461 
1462   inline void stbx( Register d, Register s1, Register s2);
1463   inline void stb(  Register d, int si16,    Register s1);
1464   inline void stbu( Register d, int si16,    Register s1);
1465 
1466   inline void stdx( Register d, Register s1, Register s2);
1467   inline void std(  Register d, int si16,    Register s1);
1468   inline void stdu( Register d, int si16,    Register s1);
1469   inline void stdux(Register s, Register a,  Register b);
1470 
1471   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1472   inline void mtlr( Register s1);
1473   inline void mflr( Register d);
1474   inline void mtctr(Register s1);
1475   inline void mfctr(Register d);
1476   inline void mtcrf(int fxm, Register s);
1477   inline void mfcr( Register d);
1478   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1479   inline void mtcr( Register s);
1480 
1481   // Special purpose registers
1482   // Exception Register
1483   inline void mtxer(Register s1);
1484   inline void mfxer(Register d);
1485   // Vector Register Save Register
1486   inline void mtvrsave(Register s1);
1487   inline void mfvrsave(Register d);
1488   // Timebase
1489   inline void mftb(Register d);
1490   // Introduced with Power 8:
1491   // Data Stream Control Register
1492   inline void mtdscr(Register s1);
1493   inline void mfdscr(Register d );
1494   // Transactional Memory Registers
1495   inline void mftfhar(Register d);
1496   inline void mftfiar(Register d);
1497   inline void mftexasr(Register d);
1498   inline void mftexasru(Register d);
1499 
1500   // PPC 1, section 2.4.1 Branch Instructions
1501   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1502   inline void b(  Label&amp; L);
1503   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1504   inline void bl( Label&amp; L);
1505   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1506   inline void bc( int boint, int biint, Label&amp; L);
1507   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1508   inline void bcl(int boint, int biint, Label&amp; L);
1509 
1510   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1511   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1512   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1513                          relocInfo::relocType rt = relocInfo::none);
1514   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1515                          relocInfo::relocType rt = relocInfo::none);
1516 
1517   // helper function for b, bcxx
1518   inline bool is_within_range_of_b(address a, address pc);
1519   inline bool is_within_range_of_bcxx(address a, address pc);
1520 
1521   // get the destination of a bxx branch (b, bl, ba, bla)
1522   static inline address  bxx_destination(address baddr);
1523   static inline address  bxx_destination(int instr, address pc);
1524   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1525 
1526   // extended mnemonics for branch instructions
1527   inline void blt(ConditionRegister crx, Label&amp; L);
1528   inline void bgt(ConditionRegister crx, Label&amp; L);
1529   inline void beq(ConditionRegister crx, Label&amp; L);
1530   inline void bso(ConditionRegister crx, Label&amp; L);
1531   inline void bge(ConditionRegister crx, Label&amp; L);
1532   inline void ble(ConditionRegister crx, Label&amp; L);
1533   inline void bne(ConditionRegister crx, Label&amp; L);
1534   inline void bns(ConditionRegister crx, Label&amp; L);
1535 
1536   // Branch instructions with static prediction hints.
1537   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1538   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1539   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1540   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1541   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1542   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1543   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1544   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1545   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1546   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1547   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1548   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1549   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1550   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1551   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1552   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1553 
1554   // for use in conjunction with testbitdi:
1555   inline void btrue( ConditionRegister crx, Label&amp; L);
1556   inline void bfalse(ConditionRegister crx, Label&amp; L);
1557 
1558   inline void bltl(ConditionRegister crx, Label&amp; L);
1559   inline void bgtl(ConditionRegister crx, Label&amp; L);
1560   inline void beql(ConditionRegister crx, Label&amp; L);
1561   inline void bsol(ConditionRegister crx, Label&amp; L);
1562   inline void bgel(ConditionRegister crx, Label&amp; L);
1563   inline void blel(ConditionRegister crx, Label&amp; L);
1564   inline void bnel(ConditionRegister crx, Label&amp; L);
1565   inline void bnsl(ConditionRegister crx, Label&amp; L);
1566 
1567   // extended mnemonics for Branch Instructions via LR
1568   // We use `blr' for returns.
1569   inline void blr(relocInfo::relocType rt = relocInfo::none);
1570 
1571   // extended mnemonics for Branch Instructions with CTR
1572   // bdnz means `decrement CTR and jump to L if CTR is not zero'
1573   inline void bdnz(Label&amp; L);
1574   // Decrement and branch if result is zero.
1575   inline void bdz(Label&amp; L);
1576   // we use `bctr[l]' for jumps/calls in function descriptor glue
1577   // code, e.g. calls to runtime functions
1578   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1579   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1580   // conditional jumps/branches via CTR
1581   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1582   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1583   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1584   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1585 
1586   // condition register logic instructions
1587   inline void crand( int d, int s1, int s2);
1588   inline void crnand(int d, int s1, int s2);
1589   inline void cror(  int d, int s1, int s2);
1590   inline void crxor( int d, int s1, int s2);
1591   inline void crnor( int d, int s1, int s2);
1592   inline void creqv( int d, int s1, int s2);
1593   inline void crandc(int d, int s1, int s2);
1594   inline void crorc( int d, int s1, int s2);
1595 
1596   // icache and dcache related instructions
1597   inline void icbi(  Register s1, Register s2);
1598   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1599   inline void dcbz(  Register s1, Register s2);
1600   inline void dcbst( Register s1, Register s2);
1601   inline void dcbf(  Register s1, Register s2);
1602 
1603   enum ct_cache_specification {
1604     ct_primary_cache   = 0,
1605     ct_secondary_cache = 2
1606   };
1607   // dcache read hint
1608   inline void dcbt(    Register s1, Register s2);
1609   inline void dcbtct(  Register s1, Register s2, int ct);
1610   inline void dcbtds(  Register s1, Register s2, int ds);
1611   // dcache write hint
1612   inline void dcbtst(  Register s1, Register s2);
1613   inline void dcbtstct(Register s1, Register s2, int ct);
1614 
1615   //  machine barrier instructions:
1616   //
1617   //  - sync    two-way memory barrier, aka fence
1618   //  - lwsync  orders  Store|Store,
1619   //                     Load|Store,
1620   //                     Load|Load,
1621   //            but not Store|Load
1622   //  - eieio   orders memory accesses for device memory (only)
1623   //  - isync   invalidates speculatively executed instructions
1624   //            From the Power ISA 2.06 documentation:
1625   //             "[...] an isync instruction prevents the execution of
1626   //            instructions following the isync until instructions
1627   //            preceding the isync have completed, [...]"
1628   //            From IBM's AIX assembler reference:
1629   //             "The isync [...] instructions causes the processor to
1630   //            refetch any instructions that might have been fetched
1631   //            prior to the isync instruction. The instruction isync
1632   //            causes the processor to wait for all previous instructions
1633   //            to complete. Then any instructions already fetched are
1634   //            discarded and instruction processing continues in the
1635   //            environment established by the previous instructions."
1636   //
1637   //  semantic barrier instructions:
1638   //  (as defined in orderAccess.hpp)
1639   //
1640   //  - release  orders Store|Store,       (maps to lwsync)
1641   //                     Load|Store
1642   //  - acquire  orders  Load|Store,       (maps to lwsync)
1643   //                     Load|Load
1644   //  - fence    orders Store|Store,       (maps to sync)
1645   //                     Load|Store,
1646   //                     Load|Load,
1647   //                    Store|Load
1648   //
1649  private:
1650   inline void sync(int l);
1651  public:
1652   inline void sync();
1653   inline void lwsync();
1654   inline void ptesync();
1655   inline void eieio();
1656   inline void isync();
1657   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1658 
1659   // atomics
1660   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1661   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1662   inline bool lxarx_hint_exclusive_access();
1663   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1664   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1665   inline void stwcx_( Register s, Register a, Register b);
1666   inline void stdcx_( Register s, Register a, Register b);
1667 
1668   // Instructions for adjusting thread priority for simultaneous
1669   // multithreading (SMT) on Power5.
1670  private:
1671   inline void smt_prio_very_low();
1672   inline void smt_prio_medium_high();
1673   inline void smt_prio_high();
1674 
1675  public:
1676   inline void smt_prio_low();
1677   inline void smt_prio_medium_low();
1678   inline void smt_prio_medium();
1679 
1680   // trap instructions
1681   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can't occur)
1682   // NOT FOR DIRECT USE!!
1683  protected:
1684   inline void tdi_unchecked(int tobits, Register a, int si16);
1685   inline void twi_unchecked(int tobits, Register a, int si16);
1686   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1687   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1688   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1689   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1690 
1691   static bool is_tdi(int x, int tobits, int ra, int si16) {
1692      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1693          &amp;&amp; (tobits == inv_to_field(x))
1694          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1695          &amp;&amp; (si16 == inv_si_field(x));
1696   }
1697 
1698   static bool is_twi(int x, int tobits, int ra, int si16) {
1699      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1700          &amp;&amp; (tobits == inv_to_field(x))
1701          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1702          &amp;&amp; (si16 == inv_si_field(x));
1703   }
1704 
1705   static bool is_twi(int x, int tobits, int ra) {
1706      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1707          &amp;&amp; (tobits == inv_to_field(x))
1708          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1709   }
1710 
1711   static bool is_td(int x, int tobits, int ra, int rb) {
1712      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1713          &amp;&amp; (tobits == inv_to_field(x))
1714          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1715          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1716   }
1717 
1718   static bool is_tw(int x, int tobits, int ra, int rb) {
1719      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1720          &amp;&amp; (tobits == inv_to_field(x))
1721          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1722          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1723   }
1724 
1725  public:
1726   // PPC floating point instructions
1727   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1728   inline void lfs(  FloatRegister d, int si16,   Register a);
1729   inline void lfsu( FloatRegister d, int si16,   Register a);
1730   inline void lfsx( FloatRegister d, Register a, Register b);
1731   inline void lfd(  FloatRegister d, int si16,   Register a);
1732   inline void lfdu( FloatRegister d, int si16,   Register a);
1733   inline void lfdx( FloatRegister d, Register a, Register b);
1734 
1735   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1736   inline void stfs(  FloatRegister s, int si16,   Register a);
1737   inline void stfsu( FloatRegister s, int si16,   Register a);
1738   inline void stfsx( FloatRegister s, Register a, Register b);
1739   inline void stfd(  FloatRegister s, int si16,   Register a);
1740   inline void stfdu( FloatRegister s, int si16,   Register a);
1741   inline void stfdx( FloatRegister s, Register a, Register b);
1742 
1743   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1744   inline void fmr(  FloatRegister d, FloatRegister b);
1745   inline void fmr_( FloatRegister d, FloatRegister b);
1746 
1747   //  inline void mffgpr( FloatRegister d, Register b);
1748   //  inline void mftgpr( Register d, FloatRegister b);
1749   inline void cmpb(   Register a, Register s, Register b);
1750   inline void popcntb(Register a, Register s);
1751   inline void popcntw(Register a, Register s);
1752   inline void popcntd(Register a, Register s);
1753 
1754   inline void fneg(  FloatRegister d, FloatRegister b);
1755   inline void fneg_( FloatRegister d, FloatRegister b);
1756   inline void fabs(  FloatRegister d, FloatRegister b);
1757   inline void fabs_( FloatRegister d, FloatRegister b);
1758   inline void fnabs( FloatRegister d, FloatRegister b);
1759   inline void fnabs_(FloatRegister d, FloatRegister b);
1760 
1761   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
1762   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
1763   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
1764   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
1765   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
1766   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
1767   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
1768   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
1769   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
1770   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
1771   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
1772   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
1773   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
1774   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
1775   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
1776   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
1777   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
1778 
1779   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
1780   inline void frsp(  FloatRegister d, FloatRegister b);
1781   inline void fctid( FloatRegister d, FloatRegister b);
1782   inline void fctidz(FloatRegister d, FloatRegister b);
1783   inline void fctiw( FloatRegister d, FloatRegister b);
1784   inline void fctiwz(FloatRegister d, FloatRegister b);
1785   inline void fcfid( FloatRegister d, FloatRegister b);
1786   inline void fcfids(FloatRegister d, FloatRegister b);
1787 
1788   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
1789   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
1790 
1791   inline void fsqrt( FloatRegister d, FloatRegister b);
1792   inline void fsqrts(FloatRegister d, FloatRegister b);
1793 
1794   // Vector instructions for &gt;= Power6.
1795   inline void lvebx(    VectorRegister d, Register s1, Register s2);
1796   inline void lvehx(    VectorRegister d, Register s1, Register s2);
1797   inline void lvewx(    VectorRegister d, Register s1, Register s2);
1798   inline void lvx(      VectorRegister d, Register s1, Register s2);
1799   inline void lvxl(     VectorRegister d, Register s1, Register s2);
1800   inline void stvebx(   VectorRegister d, Register s1, Register s2);
1801   inline void stvehx(   VectorRegister d, Register s1, Register s2);
1802   inline void stvewx(   VectorRegister d, Register s1, Register s2);
1803   inline void stvx(     VectorRegister d, Register s1, Register s2);
1804   inline void stvxl(    VectorRegister d, Register s1, Register s2);
1805   inline void lvsl(     VectorRegister d, Register s1, Register s2);
1806   inline void lvsr(     VectorRegister d, Register s1, Register s2);
1807   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
1808   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
1809   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
1810   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
1811   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
1812   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
1813   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
1814   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
1815   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
1816   inline void vupkhpx(  VectorRegister d, VectorRegister b);
1817   inline void vupkhsb(  VectorRegister d, VectorRegister b);
1818   inline void vupkhsh(  VectorRegister d, VectorRegister b);
1819   inline void vupklpx(  VectorRegister d, VectorRegister b);
1820   inline void vupklsb(  VectorRegister d, VectorRegister b);
1821   inline void vupklsh(  VectorRegister d, VectorRegister b);
1822   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
1823   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
1824   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
1825   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
1826   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
1827   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
1828   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
1829   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
1830   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
1831   inline void vspltisb( VectorRegister d, int si5);
1832   inline void vspltish( VectorRegister d, int si5);
1833   inline void vspltisw( VectorRegister d, int si5);
1834   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1835   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1836   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
1837   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int si4);
1838   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
1839   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
1840   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
1841   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
1842   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
1843   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
1844   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
1845   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
1846   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
1847   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
1848   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
1849   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
1850   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
1851   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
1852   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
1853   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
1854   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
1855   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
1856   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
1857   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
1858   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
1859   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
1860   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
1861   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
1862   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
1863   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
1864   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
1865   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
1866   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
1867   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
1868   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
1869   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1870   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
1871   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1872   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1873   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1874   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1875   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1876   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1877   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1878   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
1879   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
1880   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
1881   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
1882   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
1883   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
1884   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
1885   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
1886   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
1887   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
1888   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
1889   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
1890   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
1891   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
1892   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
1893   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
1894   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
1895   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
1896   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
1897   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
1898   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
1899   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
1900   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
1901   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
1902   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
1903   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
1904   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
1905   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
1906   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
1907   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
1908   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
1909   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
1910   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
1911   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
1912   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
1913   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
1914   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
1915   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
1916   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
1917   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
1918   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
1919   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
1920   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
1921   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
1922   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
1923   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
1924   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
1925   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
1926   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
1927   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
1928   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
1929   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
1930   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
1931   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
1932   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
1933   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
1934   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
1935   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
1936   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
1937   // Vector Floating-Point not implemented yet
1938   inline void mtvscr(   VectorRegister b);
1939   inline void mfvscr(   VectorRegister d);
1940 
1941   // AES (introduced with Power 8)
1942   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
1943   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
1944   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
1945   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
1946   inline void vsbox(       VectorRegister d, VectorRegister a);
1947 
1948   // SHA (introduced with Power 8)
1949   // Not yet implemented.
1950 
1951   // Vector Binary Polynomial Multiplication (introduced with Power 8)
1952   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
1953   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
1954   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
1955   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
1956 
1957   // Vector Permute and Xor (introduced with Power 8)
1958   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
1959 
1960   // Transactional Memory instructions (introduced with Power 8)
1961   inline void tbegin_();    // R=0
1962   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
1963   inline void tend_();    // A=0
1964   inline void tendall_(); // A=1
1965   inline void tabort_(Register a);
1966   inline void tabortwc_(int t, Register a, Register b);
1967   inline void tabortwci_(int t, Register a, int si);
1968   inline void tabortdc_(int t, Register a, Register b);
1969   inline void tabortdci_(int t, Register a, int si);
1970   inline void tsuspend_(); // tsr with L=0
1971   inline void tresume_();  // tsr with L=1
1972   inline void tcheck(int f);
1973 
1974   // The following encoders use r0 as second operand. These instructions
1975   // read r0 as '0'.
1976   inline void lwzx( Register d, Register s2);
1977   inline void lwz(  Register d, int si16);
1978   inline void lwax( Register d, Register s2);
1979   inline void lwa(  Register d, int si16);
1980   inline void lwbrx(Register d, Register s2);
1981   inline void lhzx( Register d, Register s2);
1982   inline void lhz(  Register d, int si16);
1983   inline void lhax( Register d, Register s2);
1984   inline void lha(  Register d, int si16);
1985   inline void lhbrx(Register d, Register s2);
1986   inline void lbzx( Register d, Register s2);
1987   inline void lbz(  Register d, int si16);
1988   inline void ldx(  Register d, Register s2);
1989   inline void ld(   Register d, int si16);
1990   inline void stwx( Register d, Register s2);
1991   inline void stw(  Register d, int si16);
1992   inline void sthx( Register d, Register s2);
1993   inline void sth(  Register d, int si16);
1994   inline void stbx( Register d, Register s2);
1995   inline void stb(  Register d, int si16);
1996   inline void stdx( Register d, Register s2);
1997   inline void std(  Register d, int si16);
1998 
1999   // PPC 2, section 3.2.1 Instruction Cache Instructions
2000   inline void icbi(    Register s2);
2001   // PPC 2, section 3.2.2 Data Cache Instructions
2002   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2003   inline void dcbz(    Register s2);
2004   inline void dcbst(   Register s2);
2005   inline void dcbf(    Register s2);
2006   // dcache read hint
2007   inline void dcbt(    Register s2);
2008   inline void dcbtct(  Register s2, int ct);
2009   inline void dcbtds(  Register s2, int ds);
2010   // dcache write hint
2011   inline void dcbtst(  Register s2);
2012   inline void dcbtstct(Register s2, int ct);
2013 
2014   // Atomics: use ra0mem to disallow R0 as base.
2015   inline void lwarx_unchecked(Register d, Register b, int eh1);
2016   inline void ldarx_unchecked(Register d, Register b, int eh1);
2017   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2018   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2019   inline void stwcx_(Register s, Register b);
2020   inline void stdcx_(Register s, Register b);
2021   inline void lfs(   FloatRegister d, int si16);
2022   inline void lfsx(  FloatRegister d, Register b);
2023   inline void lfd(   FloatRegister d, int si16);
2024   inline void lfdx(  FloatRegister d, Register b);
2025   inline void stfs(  FloatRegister s, int si16);
2026   inline void stfsx( FloatRegister s, Register b);
2027   inline void stfd(  FloatRegister s, int si16);
2028   inline void stfdx( FloatRegister s, Register b);
2029   inline void lvebx( VectorRegister d, Register s2);
2030   inline void lvehx( VectorRegister d, Register s2);
2031   inline void lvewx( VectorRegister d, Register s2);
2032   inline void lvx(   VectorRegister d, Register s2);
2033   inline void lvxl(  VectorRegister d, Register s2);
2034   inline void stvebx(VectorRegister d, Register s2);
2035   inline void stvehx(VectorRegister d, Register s2);
2036   inline void stvewx(VectorRegister d, Register s2);
2037   inline void stvx(  VectorRegister d, Register s2);
2038   inline void stvxl( VectorRegister d, Register s2);
2039   inline void lvsl(  VectorRegister d, Register s2);
2040   inline void lvsr(  VectorRegister d, Register s2);
2041 
2042   // RegisterOrConstant versions.
2043   // These emitters choose between the versions using two registers and
2044   // those with register and immediate, depending on the content of roc.
2045   // If the constant is not encodable as immediate, instructions to
2046   // load the constant are emitted beforehand. Store instructions need a
2047   // tmp reg if the constant is not encodable as immediate.
2048   // Size unpredictable.
2049   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2050   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2051   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2052   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2053   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2054   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2055   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2056   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2057   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2058   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2059   void add( Register d, RegisterOrConstant roc, Register s1);
2060   void subf(Register d, RegisterOrConstant roc, Register s1);
2061   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2062 
2063 
2064   // Emit several instructions to load a 64 bit constant. This issues a fixed
2065   // instruction pattern so that the constant can be patched later on.
2066   enum {
2067     load_const_size = 5 * BytesPerInstWord
2068   };
2069          void load_const(Register d, long a,            Register tmp = noreg);
2070   inline void load_const(Register d, void* a,           Register tmp = noreg);
2071   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2072   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2073 
2074   // Load a 64 bit constant, optimized, not identifyable.
2075   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2076   // 16 bit immediate offset. This is useful if the offset can be encoded in
2077   // a succeeding instruction.
2078          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2079   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2080     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2081   }
2082 
2083   // Creation
2084   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2085 #ifdef CHECK_DELAY
2086     delay_state = no_delay;
2087 #endif
2088   }
2089 
2090   // Testing
2091 #ifndef PRODUCT
2092   void test_asm();
2093 #endif
2094 };
2095 
2096 
2097 #endif // CPU_PPC_VM_ASSEMBLER_PPC_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>

<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/cpu/ppc/vm/ppc.ad</title>
<body id="SUNWwebrev">
<pre>
   1 //
   2 // Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3 // Copyright (c) 2012, 2016 SAP SE. All rights reserved.
   4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5 //
   6 // This code is free software; you can redistribute it and/or modify it
   7 // under the terms of the GNU General Public License version 2 only, as
   8 // published by the Free Software Foundation.
   9 //
  10 // This code is distributed in the hope that it will be useful, but WITHOUT
  11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13 // version 2 for more details (a copy is included in the LICENSE file that
  14 // accompanied this code).
  15 //
  16 // You should have received a copy of the GNU General Public License version
  17 // 2 along with this work; if not, write to the Free Software Foundation,
  18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19 //
  20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21 // or visit www.oracle.com if you need additional information or have any
  22 // questions.
  23 //
  24 //
  25 
  26 //
  27 // PPC64 Architecture Description File
  28 //
  29 
  30 //----------REGISTER DEFINITION BLOCK------------------------------------------
  31 // This information is used by the matcher and the register allocator to
  32 // describe individual registers and classes of registers within the target
  33 // architecture.
  34 register %{
  35 //----------Architecture Description Register Definitions----------------------
  36 // General Registers
  37 // "reg_def"  name (register save type, C convention save type,
  38 //                  ideal register type, encoding);
  39 //
  40 // Register Save Types:
  41 //
  42 //   NS  = No-Save:     The register allocator assumes that these registers
  43 //                      can be used without saving upon entry to the method, &amp;
  44 //                      that they do not need to be saved at call sites.
  45 //
  46 //   SOC = Save-On-Call: The register allocator assumes that these registers
  47 //                      can be used without saving upon entry to the method,
  48 //                      but that they must be saved at call sites.
  49 //                      These are called "volatiles" on ppc.
  50 //
  51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
  52 //                      must be saved before using them upon entry to the
  53 //                      method, but they do not need to be saved at call
  54 //                      sites.
  55 //                      These are called "nonvolatiles" on ppc.
  56 //
  57 //   AS  = Always-Save:   The register allocator assumes that these registers
  58 //                      must be saved before using them upon entry to the
  59 //                      method, &amp; that they must be saved at call sites.
  60 //
  61 // Ideal Register Type is used to determine how to save &amp; restore a
  62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
  64 //
  65 // The encoding number is the actual bit-pattern placed into the opcodes.
  66 //
  67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
  68 // Supplement Version 1.7 as of 2003-10-29.
  69 //
  70 // For each 64-bit register we must define two registers: the register
  71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)'half',
  72 // e.g. R3_H, which is needed by the allocator, but is not used
  73 // for stores, loads, etc.
  74 
  75 // ----------------------------
  76 // Integer/Long Registers
  77 // ----------------------------
  78 
  79   // PPC64 has 32 64-bit integer registers.
  80 
  81   // types: v = volatile, nv = non-volatile, s = system
  82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
  83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
  84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
  85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
  86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
  87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
  88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
  89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
  90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
  91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
  92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
  93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
  94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
  95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
  96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
  97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
  98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
  99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
 100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
 101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
 102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
 103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
 104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
 105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
 106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
 107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
 108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
 109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
 110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
 111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
 112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
 113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
 114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
 115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
 116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
 117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
 118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
 119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
 120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
 121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
 122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
 123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
 124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
 125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
 126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
 127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
 128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
 129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
 130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
 131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
 132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
 133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
 134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
 135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
 136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
 137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
 138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
 139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
 140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
 141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
 142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
 143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
 144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
 145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
 146 
 147 
 148 // ----------------------------
 149 // Float/Double Registers
 150 // ----------------------------
 151 
 152   // Double Registers
 153   // The rules of ADL require that double registers be defined in pairs.
 154   // Each pair must be two 32-bit values, but not necessarily a pair of
 155   // single float registers. In each pair, ADLC-assigned register numbers
 156   // must be adjacent, with the lower number even. Finally, when the
 157   // CPU stores such a register pair to memory, the word associated with
 158   // the lower ADLC-assigned number must be stored to the lower address.
 159 
 160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
 161   // or double precision floating-point value.
 162 
 163   // types: v = volatile, nv = non-volatile, s = system
 164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
 165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
 166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
 167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
 168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
 169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
 170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
 171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
 172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
 173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
 174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
 175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
 176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
 177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
 178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
 179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
 180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
 181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
 182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
 183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
 184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
 185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
 186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
 187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
 188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
 189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
 190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
 191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
 192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
 193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
 194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
 195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
 196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
 197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
 198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
 199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
 200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
 201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
 202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
 203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
 204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
 205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
 206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
 207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
 208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
 209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
 210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
 211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
 212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
 213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
 214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
 215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
 216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
 217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
 218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
 219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
 220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
 221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
 222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
 223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
 224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
 225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
 226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
 227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
 228 
 229 // ----------------------------
 230 // Special Registers
 231 // ----------------------------
 232 
 233 // Condition Codes Flag Registers
 234 
 235   // PPC64 has 8 condition code "registers" which are all contained
 236   // in the CR register.
 237 
 238   // types: v = volatile, nv = non-volatile, s = system
 239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
 240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
 241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
 242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
 243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
 244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
 245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
 246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
 247 
 248   // Special registers of PPC64
 249 
 250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
 251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
 252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
 253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
 254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
 255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
 256 
 257 
 258 // ----------------------------
 259 // Specify priority of register selection within phases of register
 260 // allocation. Highest priority is first. A useful heuristic is to
 261 // give registers a low priority when they are required by machine
 262 // instructions, like EAX and EDX on I486, and choose no-save registers
 263 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
 264 // which participate in fixed calling sequences should come last.
 265 // Registers which are used as pairs must fall on an even boundary.
 266 
 267 // It's worth about 1% on SPEC geomean to get this right.
 268 
 269 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
 270 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
 271 // R3_num. Therefore, R3_num may not be (and in reality is not)
 272 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
 273 // assumptions on ordering, e.g. R3_num may be less than R2_num.
 274 // Additionally, the function
 275 //   static enum RC rc_class(OptoReg::Name reg )
 276 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
 277 // and its current implementation relies on chunk0 and chunk1 having a
 278 // size of 64 each.
 279 
 280 // If you change this allocation class, please have a look at the
 281 // default values for the parameters RoundRobinIntegerRegIntervalStart
 282 // and RoundRobinFloatRegIntervalStart
 283 
 284 alloc_class chunk0 (
 285   // Chunk0 contains *all* 64 integer registers halves.
 286 
 287   // "non-volatile" registers
 288   R14, R14_H,
 289   R15, R15_H,
 290   R17, R17_H,
 291   R18, R18_H,
 292   R19, R19_H,
 293   R20, R20_H,
 294   R21, R21_H,
 295   R22, R22_H,
 296   R23, R23_H,
 297   R24, R24_H,
 298   R25, R25_H,
 299   R26, R26_H,
 300   R27, R27_H,
 301   R28, R28_H,
 302   R29, R29_H,
 303   R31, R31_H,
 304 
 305   // scratch/special registers
 306   R11, R11_H,
 307   R12, R12_H,
 308 
 309   // argument registers
 310   R10, R10_H,
 311   R9,  R9_H,
 312   R8,  R8_H,
 313   R7,  R7_H,
 314   R6,  R6_H,
 315   R5,  R5_H,
 316   R4,  R4_H,
 317   R3,  R3_H,
 318 
 319   // special registers, not available for allocation
 320   R30, R30_H,     // R30_zero
 321   R16, R16_H,     // R16_thread
 322   R13, R13_H,     // system thread id
 323   R2,  R2_H,      // may be used for TOC
 324   R1,  R1_H,      // SP
 325   R0,  R0_H       // R0 (scratch)
 326 );
 327 
 328 // If you change this allocation class, please have a look at the
 329 // default values for the parameters RoundRobinIntegerRegIntervalStart
 330 // and RoundRobinFloatRegIntervalStart
 331 
 332 alloc_class chunk1 (
 333   // Chunk1 contains *all* 64 floating-point registers halves.
 334 
 335   // scratch register
 336   F0,  F0_H,
 337 
 338   // argument registers
 339   F13, F13_H,
 340   F12, F12_H,
 341   F11, F11_H,
 342   F10, F10_H,
 343   F9,  F9_H,
 344   F8,  F8_H,
 345   F7,  F7_H,
 346   F6,  F6_H,
 347   F5,  F5_H,
 348   F4,  F4_H,
 349   F3,  F3_H,
 350   F2,  F2_H,
 351   F1,  F1_H,
 352 
 353   // non-volatile registers
 354   F14, F14_H,
 355   F15, F15_H,
 356   F16, F16_H,
 357   F17, F17_H,
 358   F18, F18_H,
 359   F19, F19_H,
 360   F20, F20_H,
 361   F21, F21_H,
 362   F22, F22_H,
 363   F23, F23_H,
 364   F24, F24_H,
 365   F25, F25_H,
 366   F26, F26_H,
 367   F27, F27_H,
 368   F28, F28_H,
 369   F29, F29_H,
 370   F30, F30_H,
 371   F31, F31_H
 372 );
 373 
 374 alloc_class chunk2 (
 375   // Chunk2 contains *all* 8 condition code registers.
 376 
 377   CCR0,
 378   CCR1,
 379   CCR2,
 380   CCR3,
 381   CCR4,
 382   CCR5,
 383   CCR6,
 384   CCR7
 385 );
 386 
 387 alloc_class chunk3 (
 388   // special registers
 389   // These registers are not allocated, but used for nodes generated by postalloc expand.
 390   SR_XER,
 391   SR_LR,
 392   SR_CTR,
 393   SR_VRSAVE,
 394   SR_SPEFSCR,
 395   SR_PPR
 396 );
 397 
 398 //-------Architecture Description Register Classes-----------------------
 399 
 400 // Several register classes are automatically defined based upon
 401 // information in this architecture description.
 402 
 403 // 1) reg_class inline_cache_reg           ( as defined in frame section )
 404 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
 405 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
 406 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 407 //
 408 
 409 // ----------------------------
 410 // 32 Bit Register Classes
 411 // ----------------------------
 412 
 413 // We specify registers twice, once as read/write, and once read-only.
 414 // We use the read-only registers for source operands. With this, we
 415 // can include preset read only registers in this class, as a hard-coded
 416 // '0'-register. (We used to simulate this on ppc.)
 417 
 418 // 32 bit registers that can be read and written i.e. these registers
 419 // can be dest (or src) of normal instructions.
 420 reg_class bits32_reg_rw(
 421 /*R0*/              // R0
 422 /*R1*/              // SP
 423   R2,               // TOC
 424   R3,
 425   R4,
 426   R5,
 427   R6,
 428   R7,
 429   R8,
 430   R9,
 431   R10,
 432   R11,
 433   R12,
 434 /*R13*/             // system thread id
 435   R14,
 436   R15,
 437 /*R16*/             // R16_thread
 438   R17,
 439   R18,
 440   R19,
 441   R20,
 442   R21,
 443   R22,
 444   R23,
 445   R24,
 446   R25,
 447   R26,
 448   R27,
 449   R28,
 450 /*R29,*/             // global TOC
 451 /*R30,*/             // R30_zero
 452   R31
 453 );
 454 
 455 // 32 bit registers that can only be read i.e. these registers can
 456 // only be src of all instructions.
 457 reg_class bits32_reg_ro(
 458 /*R0*/              // R0
 459 /*R1*/              // SP
 460   R2                // TOC
 461   R3,
 462   R4,
 463   R5,
 464   R6,
 465   R7,
 466   R8,
 467   R9,
 468   R10,
 469   R11,
 470   R12,
 471 /*R13*/             // system thread id
 472   R14,
 473   R15,
 474 /*R16*/             // R16_thread
 475   R17,
 476   R18,
 477   R19,
 478   R20,
 479   R21,
 480   R22,
 481   R23,
 482   R24,
 483   R25,
 484   R26,
 485   R27,
 486   R28,
 487 /*R29,*/
 488 /*R30,*/            // R30_zero
 489   R31
 490 );
 491 
 492 reg_class rscratch1_bits32_reg(R11);
 493 reg_class rscratch2_bits32_reg(R12);
 494 reg_class rarg1_bits32_reg(R3);
 495 reg_class rarg2_bits32_reg(R4);
 496 reg_class rarg3_bits32_reg(R5);
 497 reg_class rarg4_bits32_reg(R6);
 498 
 499 // ----------------------------
 500 // 64 Bit Register Classes
 501 // ----------------------------
 502 // 64-bit build means 64-bit pointers means hi/lo pairs
 503 
 504 reg_class rscratch1_bits64_reg(R11_H, R11);
 505 reg_class rscratch2_bits64_reg(R12_H, R12);
 506 reg_class rarg1_bits64_reg(R3_H, R3);
 507 reg_class rarg2_bits64_reg(R4_H, R4);
 508 reg_class rarg3_bits64_reg(R5_H, R5);
 509 reg_class rarg4_bits64_reg(R6_H, R6);
 510 // Thread register, 'written' by tlsLoadP, see there.
 511 reg_class thread_bits64_reg(R16_H, R16);
 512 
 513 reg_class r19_bits64_reg(R19_H, R19);
 514 
 515 // 64 bit registers that can be read and written i.e. these registers
 516 // can be dest (or src) of normal instructions.
 517 reg_class bits64_reg_rw(
 518 /*R0_H,  R0*/     // R0
 519 /*R1_H,  R1*/     // SP
 520   R2_H,  R2,      // TOC
 521   R3_H,  R3,
 522   R4_H,  R4,
 523   R5_H,  R5,
 524   R6_H,  R6,
 525   R7_H,  R7,
 526   R8_H,  R8,
 527   R9_H,  R9,
 528   R10_H, R10,
 529   R11_H, R11,
 530   R12_H, R12,
 531 /*R13_H, R13*/   // system thread id
 532   R14_H, R14,
 533   R15_H, R15,
 534 /*R16_H, R16*/   // R16_thread
 535   R17_H, R17,
 536   R18_H, R18,
 537   R19_H, R19,
 538   R20_H, R20,
 539   R21_H, R21,
 540   R22_H, R22,
 541   R23_H, R23,
 542   R24_H, R24,
 543   R25_H, R25,
 544   R26_H, R26,
 545   R27_H, R27,
 546   R28_H, R28,
 547 /*R29_H, R29,*/
 548 /*R30_H, R30,*/  // R30_zero
 549   R31_H, R31
 550 );
 551 
 552 // 64 bit registers used excluding r2, r11 and r12
 553 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
 554 // r2, r11 and r12 internally.
 555 reg_class bits64_reg_leaf_call(
 556 /*R0_H,  R0*/     // R0
 557 /*R1_H,  R1*/     // SP
 558 /*R2_H,  R2*/     // TOC
 559   R3_H,  R3,
 560   R4_H,  R4,
 561   R5_H,  R5,
 562   R6_H,  R6,
 563   R7_H,  R7,
 564   R8_H,  R8,
 565   R9_H,  R9,
 566   R10_H, R10,
 567 /*R11_H, R11*/
 568 /*R12_H, R12*/
 569 /*R13_H, R13*/   // system thread id
 570   R14_H, R14,
 571   R15_H, R15,
 572 /*R16_H, R16*/   // R16_thread
 573   R17_H, R17,
 574   R18_H, R18,
 575   R19_H, R19,
 576   R20_H, R20,
 577   R21_H, R21,
 578   R22_H, R22,
 579   R23_H, R23,
 580   R24_H, R24,
 581   R25_H, R25,
 582   R26_H, R26,
 583   R27_H, R27,
 584   R28_H, R28,
 585 /*R29_H, R29,*/
 586 /*R30_H, R30,*/  // R30_zero
 587   R31_H, R31
 588 );
 589 
 590 // Used to hold the TOC to avoid collisions with expanded DynamicCall
 591 // which uses r19 as inline cache internally and expanded LeafCall which uses
 592 // r2, r11 and r12 internally.
 593 reg_class bits64_constant_table_base(
 594 /*R0_H,  R0*/     // R0
 595 /*R1_H,  R1*/     // SP
 596 /*R2_H,  R2*/     // TOC
 597   R3_H,  R3,
 598   R4_H,  R4,
 599   R5_H,  R5,
 600   R6_H,  R6,
 601   R7_H,  R7,
 602   R8_H,  R8,
 603   R9_H,  R9,
 604   R10_H, R10,
 605 /*R11_H, R11*/
 606 /*R12_H, R12*/
 607 /*R13_H, R13*/   // system thread id
 608   R14_H, R14,
 609   R15_H, R15,
 610 /*R16_H, R16*/   // R16_thread
 611   R17_H, R17,
 612   R18_H, R18,
 613 /*R19_H, R19*/
 614   R20_H, R20,
 615   R21_H, R21,
 616   R22_H, R22,
 617   R23_H, R23,
 618   R24_H, R24,
 619   R25_H, R25,
 620   R26_H, R26,
 621   R27_H, R27,
 622   R28_H, R28,
 623 /*R29_H, R29,*/
 624 /*R30_H, R30,*/  // R30_zero
 625   R31_H, R31
 626 );
 627 
 628 // 64 bit registers that can only be read i.e. these registers can
 629 // only be src of all instructions.
 630 reg_class bits64_reg_ro(
 631 /*R0_H,  R0*/     // R0
 632   R1_H,  R1,
 633   R2_H,  R2,       // TOC
 634   R3_H,  R3,
 635   R4_H,  R4,
 636   R5_H,  R5,
 637   R6_H,  R6,
 638   R7_H,  R7,
 639   R8_H,  R8,
 640   R9_H,  R9,
 641   R10_H, R10,
 642   R11_H, R11,
 643   R12_H, R12,
 644 /*R13_H, R13*/   // system thread id
 645   R14_H, R14,
 646   R15_H, R15,
 647   R16_H, R16,    // R16_thread
 648   R17_H, R17,
 649   R18_H, R18,
 650   R19_H, R19,
 651   R20_H, R20,
 652   R21_H, R21,
 653   R22_H, R22,
 654   R23_H, R23,
 655   R24_H, R24,
 656   R25_H, R25,
 657   R26_H, R26,
 658   R27_H, R27,
 659   R28_H, R28,
 660 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
 661 /*R30_H, R30,*/  // R30_zero
 662   R31_H, R31
 663 );
 664 
 665 
 666 // ----------------------------
 667 // Special Class for Condition Code Flags Register
 668 
 669 reg_class int_flags(
 670 /*CCR0*/             // scratch
 671 /*CCR1*/             // scratch
 672 /*CCR2*/             // nv!
 673 /*CCR3*/             // nv!
 674 /*CCR4*/             // nv!
 675   CCR5,
 676   CCR6,
 677   CCR7
 678 );
 679 
 680 reg_class int_flags_ro(
 681   CCR0,
 682   CCR1,
 683   CCR2,
 684   CCR3,
 685   CCR4,
 686   CCR5,
 687   CCR6,
 688   CCR7
 689 );
 690 
 691 reg_class int_flags_CR0(CCR0);
 692 reg_class int_flags_CR1(CCR1);
 693 reg_class int_flags_CR6(CCR6);
 694 reg_class ctr_reg(SR_CTR);
 695 
 696 // ----------------------------
 697 // Float Register Classes
 698 // ----------------------------
 699 
 700 reg_class flt_reg(
 701   F0,
 702   F1,
 703   F2,
 704   F3,
 705   F4,
 706   F5,
 707   F6,
 708   F7,
 709   F8,
 710   F9,
 711   F10,
 712   F11,
 713   F12,
 714   F13,
 715   F14,              // nv!
 716   F15,              // nv!
 717   F16,              // nv!
 718   F17,              // nv!
 719   F18,              // nv!
 720   F19,              // nv!
 721   F20,              // nv!
 722   F21,              // nv!
 723   F22,              // nv!
 724   F23,              // nv!
 725   F24,              // nv!
 726   F25,              // nv!
 727   F26,              // nv!
 728   F27,              // nv!
 729   F28,              // nv!
 730   F29,              // nv!
 731   F30,              // nv!
 732   F31               // nv!
 733 );
 734 
 735 // Double precision float registers have virtual `high halves' that
 736 // are needed by the allocator.
 737 reg_class dbl_reg(
 738   F0,  F0_H,
 739   F1,  F1_H,
 740   F2,  F2_H,
 741   F3,  F3_H,
 742   F4,  F4_H,
 743   F5,  F5_H,
 744   F6,  F6_H,
 745   F7,  F7_H,
 746   F8,  F8_H,
 747   F9,  F9_H,
 748   F10, F10_H,
 749   F11, F11_H,
 750   F12, F12_H,
 751   F13, F13_H,
 752   F14, F14_H,    // nv!
 753   F15, F15_H,    // nv!
 754   F16, F16_H,    // nv!
 755   F17, F17_H,    // nv!
 756   F18, F18_H,    // nv!
 757   F19, F19_H,    // nv!
 758   F20, F20_H,    // nv!
 759   F21, F21_H,    // nv!
 760   F22, F22_H,    // nv!
 761   F23, F23_H,    // nv!
 762   F24, F24_H,    // nv!
 763   F25, F25_H,    // nv!
 764   F26, F26_H,    // nv!
 765   F27, F27_H,    // nv!
 766   F28, F28_H,    // nv!
 767   F29, F29_H,    // nv!
 768   F30, F30_H,    // nv!
 769   F31, F31_H     // nv!
 770 );
 771 
 772  %}
 773 
 774 //----------DEFINITION BLOCK---------------------------------------------------
 775 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
 776 // Current support includes integer values in the range [0, 0x7FFFFFFF]
 777 // Format:
 778 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
 779 // Generated Code in ad_&lt;arch&gt;.hpp
 780 //        #define  &lt;name&gt;   (&lt;expression&gt;)
 781 //        // value == &lt;int_value&gt;
 782 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
 783 //        assert( &lt;name&gt; == &lt;int_value&gt;, "Expect (&lt;expression&gt;) to equal &lt;int_value&gt;");
 784 //
 785 definitions %{
 786   // The default cost (of an ALU instruction).
 787   int_def DEFAULT_COST_LOW        (     30,      30);
 788   int_def DEFAULT_COST            (    100,     100);
 789   int_def HUGE_COST               (1000000, 1000000);
 790 
 791   // Memory refs
 792   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
 793   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
 794 
 795   // Branches are even more expensive.
 796   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
 797   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
 798 %}
 799 
 800 
 801 //----------SOURCE BLOCK-------------------------------------------------------
 802 // This is a block of C++ code which provides values, functions, and
 803 // definitions necessary in the rest of the architecture description.
 804 source_hpp %{
 805   // Header information of the source block.
 806   // Method declarations/definitions which are used outside
 807   // the ad-scope can conveniently be defined here.
 808   //
 809   // To keep related declarations/definitions/uses close together,
 810   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 811 
 812   // Returns true if Node n is followed by a MemBar node that
 813   // will do an acquire. If so, this node must not do the acquire
 814   // operation.
 815   bool followed_by_acquire(const Node *n);
 816 %}
 817 
 818 source %{
 819 
 820 // Should the Matcher clone shifts on addressing modes, expecting them
 821 // to be subsumed into complex addressing expressions or compute them
 822 // into registers?
 823 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 824   return clone_base_plus_offset_address(m, mstack, address_visited);
 825 }
 826 
 827 void Compile::reshape_address(AddPNode* addp) {
 828 }
 829 
 830 // Optimize load-acquire.
 831 //
 832 // Check if acquire is unnecessary due to following operation that does
 833 // acquire anyways.
 834 // Walk the pattern:
 835 //
 836 //      n: Load.acq
 837 //           |
 838 //      MemBarAcquire
 839 //       |         |
 840 //  Proj(ctrl)  Proj(mem)
 841 //       |         |
 842 //   MemBarRelease/Volatile
 843 //
 844 bool followed_by_acquire(const Node *load) {
 845   assert(load-&gt;is_Load(), "So far implemented only for loads.");
 846 
 847   // Find MemBarAcquire.
 848   const Node *mba = NULL;
 849   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 850     const Node *out = load-&gt;fast_out(i);
 851     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 852       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 853       mba = out;
 854       break;
 855     }
 856   }
 857   if (!mba) return false;
 858 
 859   // Find following MemBar node.
 860   //
 861   // The following node must be reachable by control AND memory
 862   // edge to assure no other operations are in between the two nodes.
 863   //
 864   // So first get the Proj node, mem_proj, to use it to iterate forward.
 865   Node *mem_proj = NULL;
 866   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 867     mem_proj = mba-&gt;fast_out(i);      // Throw out-of-bounds if proj not found
 868     assert(mem_proj-&gt;is_Proj(), "only projections here");
 869     ProjNode *proj = mem_proj-&gt;as_Proj();
 870     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 871         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 872       break;
 873   }
 874   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, "Graph broken");
 875 
 876   // Search MemBar behind Proj. If there are other memory operations
 877   // behind the Proj we lost.
 878   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 879     Node *x = mem_proj-&gt;fast_out(j);
 880     // Proj might have an edge to a store or load node which precedes the membar.
 881     if (x-&gt;is_Mem()) return false;
 882 
 883     // On PPC64 release and volatile are implemented by an instruction
 884     // that also has acquire semantics. I.e. there is no need for an
 885     // acquire before these.
 886     int xop = x-&gt;Opcode();
 887     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 888       // Make sure we're not missing Call/Phi/MergeMem by checking
 889       // control edges. The control edge must directly lead back
 890       // to the MemBarAcquire
 891       Node *ctrl_proj = x-&gt;in(0);
 892       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 893         return true;
 894       }
 895     }
 896   }
 897 
 898   return false;
 899 }
 900 
 901 #define __ _masm.
 902 
 903 // Tertiary op of a LoadP or StoreP encoding.
 904 #define REGP_OP true
 905 
 906 // ****************************************************************************
 907 
 908 // REQUIRED FUNCTIONALITY
 909 
 910 // !!!!! Special hack to get all type of calls to specify the byte offset
 911 //       from the start of the call to the point where the return address
 912 //       will point.
 913 
 914 // PPC port: Removed use of lazy constant construct.
 915 
 916 int MachCallStaticJavaNode::ret_addr_offset() {
 917   // It's only a single branch-and-link instruction.
 918   return 4;
 919 }
 920 
 921 int MachCallDynamicJavaNode::ret_addr_offset() {
 922   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 923   // postalloc expanded calls if we use inline caches and do not update method data.
 924   if (UseInlineCaches)
 925     return 4;
 926 
 927   int vtable_index = this-&gt;_vtable_index;
 928   if (vtable_index &lt; 0) {
 929     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 930     assert(vtable_index == Method::invalid_vtable_index, "correct sentinel value");
 931     return 12;
 932   } else {
 933     assert(!UseInlineCaches, "expect vtable calls only if not using ICs");
 934     return 24;
 935   }
 936 }
 937 
 938 int MachCallRuntimeNode::ret_addr_offset() {
 939 #if defined(ABI_ELFv2)
 940   return 28;
 941 #else
 942   return 40;
 943 #endif
 944 }
 945 
 946 //=============================================================================
 947 
 948 // condition code conversions
 949 
 950 static int cc_to_boint(int cc) {
 951   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 952 }
 953 
 954 static int cc_to_inverse_boint(int cc) {
 955   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 956 }
 957 
 958 static int cc_to_biint(int cc, int flags_reg) {
 959   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 960 }
 961 
 962 //=============================================================================
 963 
 964 // Compute padding required for nodes which need alignment. The padding
 965 // is the number of bytes (not instructions) which will be inserted before
 966 // the instruction. The padding must match the size of a NOP instruction.
 967 
 968 int inlineCallClearArrayNode::compute_padding(int current_offset) const {
 969   int desired_padding = (2*4-current_offset)&amp;31; // see MacroAssembler::clear_memory_doubleword
 970   return (desired_padding &lt;= 3*4) ? desired_padding : 0;
 971 }
 972 
 973 //=============================================================================
 974 
 975 // Indicate if the safepoint node needs the polling page as an input.
 976 bool SafePointNode::needs_polling_address_input() {
 977   // The address is loaded from thread by a seperate node.
 978   return true;
 979 }
 980 
 981 //=============================================================================
 982 
 983 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 984 void emit_break(CodeBuffer &amp;cbuf) {
 985   MacroAssembler _masm(&amp;cbuf);
 986   __ illtrap();
 987 }
 988 
 989 #ifndef PRODUCT
 990 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 991   st-&gt;print("BREAKPOINT");
 992 }
 993 #endif
 994 
 995 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 996   emit_break(cbuf);
 997 }
 998 
 999 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
1000   return MachNode::size(ra_);
1001 }
1002 
1003 //=============================================================================
1004 
1005 void emit_nop(CodeBuffer &amp;cbuf) {
1006   MacroAssembler _masm(&amp;cbuf);
1007   __ nop();
1008 }
1009 
1010 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
1011   *((int*)(cbuf.insts_end())) = value;
1012   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
1013 }
1014 
1015 //=============================================================================
1016 
1017 %} // interrupt source
1018 
1019 source_hpp %{ // Header information of the source block.
1020 
1021 //--------------------------------------------------------------
1022 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
1023 //--------------------------------------------------------------
1024 
1025 class CallStubImpl {
1026 
1027  public:
1028 
1029   // Emit call stub, compiled java to interpreter.
1030   static void emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);
1031 
1032   // Size of call trampoline stub.
1033   // This doesn't need to be accurate to the byte, but it
1034   // must be larger than or equal to the real size of the stub.
1035   static uint size_call_trampoline() {
1036     return MacroAssembler::trampoline_stub_size;
1037   }
1038 
1039   // number of relocations needed by a call trampoline stub
1040   static uint reloc_call_trampoline() {
1041     return 5;
1042   }
1043 
1044 };
1045 
1046 %} // end source_hpp
1047 
1048 source %{
1049 
1050 // Emit a trampoline stub for a call to a target which is too far away.
1051 //
1052 // code sequences:
1053 //
1054 // call-site:
1055 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
1056 //
1057 // Related trampoline stub for this call-site in the stub section:
1058 //   load the call target from the constant pool
1059 //   branch via CTR (LR/link still points to the call-site above)
1060 
1061 void CallStubImpl::emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {
1062   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
1063   if (stub == NULL) {
1064     ciEnv::current()-&gt;record_out_of_memory_failure();
1065   }
1066 }
1067 
1068 //=============================================================================
1069 
1070 // Emit an inline branch-and-link call and a related trampoline stub.
1071 //
1072 // code sequences:
1073 //
1074 // call-site:
1075 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
1076 //
1077 // Related trampoline stub for this call-site in the stub section:
1078 //   load the call target from the constant pool
1079 //   branch via CTR (LR/link still points to the call-site above)
1080 //
1081 
1082 typedef struct {
1083   int insts_call_instruction_offset;
1084   int ret_addr_offset;
1085 } EmitCallOffsets;
1086 
1087 // Emit a branch-and-link instruction that branches to a trampoline.
1088 // - Remember the offset of the branch-and-link instruction.
1089 // - Add a relocation at the branch-and-link instruction.
1090 // - Emit a branch-and-link.
1091 // - Remember the return pc offset.
1092 EmitCallOffsets emit_call_with_trampoline_stub(MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {
1093   EmitCallOffsets offsets = { -1, -1 };
1094   const int start_offset = __ offset();
1095   offsets.insts_call_instruction_offset = __ offset();
1096 
1097   // No entry point given, use the current pc.
1098   if (entry_point == NULL) entry_point = __ pc();
1099 
1100   // Put the entry point as a constant into the constant pool.
1101   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
1102   if (entry_point_toc_addr == NULL) {
1103     ciEnv::current()-&gt;record_out_of_memory_failure();
1104     return offsets;
1105   }
1106   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
1107   
1108   // Emit the trampoline stub which will be related to the branch-and-link below.
1109   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
1110   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
1111   __ relocate(rtype);
1112   
1113   // Note: At this point we do not have the address of the trampoline
1114   // stub, and the entry point might be too far away for bl, so __ pc()
1115   // serves as dummy and the bl will be patched later.
1116   __ bl((address) __ pc());
1117 
1118   offsets.ret_addr_offset = __ offset() - start_offset;
1119 
1120   return offsets;
1121 }
1122 
1123 //=============================================================================
1124 
1125 // Factory for creating loadConL* nodes for large/small constant pool.
1126 
1127 static inline jlong replicate_immF(float con) {
1128   // Replicate float con 2 times and pack into vector.
1129   int val = *((int*)&amp;con);
1130   jlong lval = val;
1131   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
1132   return lval;
1133 }
1134 
1135 //=============================================================================
1136 
1137 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
1138 int Compile::ConstantTable::calculate_table_base_offset() const {
1139   return 0;  // absolute addressing, no offset
1140 }
1141 
1142 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
1143 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
1144   iRegPdstOper *op_dst = new iRegPdstOper();
1145   MachNode *m1 = new loadToc_hiNode();
1146   MachNode *m2 = new loadToc_loNode();
1147 
1148   m1-&gt;add_req(NULL);
1149   m2-&gt;add_req(NULL, m1);
1150   m1-&gt;_opnds[0] = op_dst;
1151   m2-&gt;_opnds[0] = op_dst;
1152   m2-&gt;_opnds[1] = op_dst;
1153   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
1154   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
1155   nodes-&gt;push(m1);
1156   nodes-&gt;push(m2);
1157 }
1158 
1159 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
1160   // Is postalloc expanded.
1161   ShouldNotReachHere();
1162 }
1163 
1164 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
1165   return 0;
1166 }
1167 
1168 #ifndef PRODUCT
1169 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
1170   st-&gt;print("-- \t// MachConstantBaseNode (empty encoding)");
1171 }
1172 #endif
1173 
1174 //=============================================================================
1175 
1176 #ifndef PRODUCT
1177 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1178   Compile* C = ra_-&gt;C;
1179   const long framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
1180 
1181   st-&gt;print("PROLOG\n\t");
1182   if (C-&gt;need_stack_bang(framesize)) {
1183     st-&gt;print("stack_overflow_check\n\t");
1184   }
1185 
1186   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
1187     st-&gt;print("save return pc\n\t");
1188     st-&gt;print("push frame %ld\n\t", -framesize);
1189   }
1190 }
1191 #endif
1192 
1193 // Macro used instead of the common __ to emulate the pipes of PPC.
1194 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
1195 // micro scheduler to cope with "hand written" assembler like in the prolog. Though
1196 // still no scheduling of this code is possible, the micro scheduler is aware of the
1197 // code and can update its internal data. The following mechanism is used to achieve this:
1198 // The micro scheduler calls size() of each compound node during scheduling. size() does a
1199 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
1200 #if 0 // TODO: PPC port
1201 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
1202                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
1203                 _masm.
1204 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
1205                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
1206 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
1207                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
1208 #else
1209 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
1210                   Unimplemented();                                                    \
1211                 _masm.
1212 #define ___stop if (UsePower6SchedulerPPC64)                                          \
1213                   Unimplemented()
1214 #define ___advance if (UsePower6SchedulerPPC64)                                       \
1215                   Unimplemented()
1216 #endif
1217 
1218 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1219   Compile* C = ra_-&gt;C;
1220   MacroAssembler _masm(&amp;cbuf);
1221 
1222   const long framesize = C-&gt;frame_size_in_bytes();
1223   assert(framesize % (2 * wordSize) == 0, "must preserve 2*wordSize alignment");
1224 
1225   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
1226 
1227   const Register return_pc            = R20; // Must match return_addr() in frame section.
1228   const Register callers_sp           = R21;
1229   const Register push_frame_temp      = R22;
1230   const Register toc_temp             = R23;
1231   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
1232 
1233   if (method_is_frameless) {
1234     // Add nop at beginning of all frameless methods to prevent any
1235     // oop instructions from getting overwritten by make_not_entrant
1236     // (patching attempt would fail).
1237     ___(nop) nop();
1238   } else {
1239     // Get return pc.
1240     ___(mflr) mflr(return_pc);
1241   }
1242 
1243   // Calls to C2R adapters often do not accept exceptional returns.
1244   // We require that their callers must bang for them. But be
1245   // careful, because some VM calls (such as call site linkage) can
1246   // use several kilobytes of stack. But the stack safety zone should
1247   // account for that. See bugs 4446381, 4468289, 4497237.
1248 
1249   int bangsize = C-&gt;bang_size_in_bytes();
1250   assert(bangsize &gt;= framesize || bangsize &lt;= 0, "stack bang size incorrect");
1251   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
1252     // Unfortunately we cannot use the function provided in
1253     // assembler.cpp as we have to emulate the pipes. So I had to
1254     // insert the code of generate_stack_overflow_check(), see
1255     // assembler.cpp for some illuminative comments.
1256     const int page_size = os::vm_page_size();
1257     int bang_end = JavaThread::stack_shadow_zone_size();
1258 
1259     // This is how far the previous frame's stack banging extended.
1260     const int bang_end_safe = bang_end;
1261 
1262     if (bangsize &gt; page_size) {
1263       bang_end += bangsize;
1264     }
1265 
1266     int bang_offset = bang_end_safe;
1267 
1268     while (bang_offset &lt;= bang_end) {
1269       // Need at least one stack bang at end of shadow zone.
1270 
1271       // Again I had to copy code, this time from assembler_ppc.cpp,
1272       // bang_stack_with_offset - see there for comments.
1273 
1274       // Stack grows down, caller passes positive offset.
1275       assert(bang_offset &gt; 0, "must bang with positive offset");
1276 
1277       long stdoffset = -bang_offset;
1278 
1279       if (Assembler::is_simm(stdoffset, 16)) {
1280         // Signed 16 bit offset, a simple std is ok.
1281         if (UseLoadInstructionsForStackBangingPPC64) {
1282           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
1283         } else {
1284           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
1285         }
1286       } else if (Assembler::is_simm(stdoffset, 31)) {
1287         // Use largeoffset calculations for addis &amp; ld/std.
1288         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
1289         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
1290 
1291         Register tmp = R11;
1292         ___(addis) addis(tmp, R1_SP, hi);
1293         if (UseLoadInstructionsForStackBangingPPC64) {
1294           ___(ld) ld(R0, lo, tmp);
1295         } else {
1296           ___(std) std(R0, lo, tmp);
1297         }
1298       } else {
1299         ShouldNotReachHere();
1300       }
1301 
1302       bang_offset += page_size;
1303     }
1304     // R11 trashed
1305   } // C-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging
1306 
1307   unsigned int bytes = (unsigned int)framesize;
1308   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
1309   ciMethod *currMethod = C-&gt;method();
1310 
1311   // Optimized version for most common case.
1312   if (UsePower6SchedulerPPC64 &amp;&amp;
1313       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
1314       !(false /* ConstantsALot TODO: PPC port*/)) {
1315     ___(or) mr(callers_sp, R1_SP);
1316     ___(std) std(return_pc, _abi(lr), R1_SP);
1317     ___(stdu) stdu(R1_SP, -offset, R1_SP);
1318     return;
1319   }
1320 
1321   if (!method_is_frameless) {
1322     // Get callers sp.
1323     ___(or) mr(callers_sp, R1_SP);
1324 
1325     // Push method's frame, modifies SP.
1326     assert(Assembler::is_uimm(framesize, 32U), "wrong type");
1327     // The ABI is already accounted for in 'framesize' via the
1328     // 'out_preserve' area.
1329     Register tmp = push_frame_temp;
1330     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
1331     if (Assembler::is_simm(-offset, 16)) {
1332       ___(stdu) stdu(R1_SP, -offset, R1_SP);
1333     } else {
1334       long x = -offset;
1335       // Had to insert load_const(tmp, -offset).
1336       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
1337       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
1338       ___(rldicr) sldi(tmp, tmp, 32);
1339       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
1340       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
1341 
1342       ___(stdux) stdux(R1_SP, R1_SP, tmp);
1343     }
1344   }
1345 #if 0 // TODO: PPC port
1346   // For testing large constant pools, emit a lot of constants to constant pool.
1347   // "Randomize" const_size.
1348   if (ConstantsALot) {
1349     const int num_consts = const_size();
1350     for (int i = 0; i &lt; num_consts; i++) {
1351       __ long_constant(0xB0B5B00BBABE);
1352     }
1353   }
1354 #endif
1355   if (!method_is_frameless) {
1356     // Save return pc.
1357     ___(std) std(return_pc, _abi(lr), callers_sp);
1358   }
1359   
1360   C-&gt;set_frame_complete(cbuf.insts_size());
1361 }
1362 #undef ___
1363 #undef ___stop
1364 #undef ___advance
1365 
1366 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
1367   // Variable size. determine dynamically.
1368   return MachNode::size(ra_);
1369 }
1370 
1371 int MachPrologNode::reloc() const {
1372   // Return number of relocatable values contained in this instruction.
1373   return 1; // 1 reloc entry for load_const(toc).
1374 }
1375 
1376 //=============================================================================
1377 
1378 #ifndef PRODUCT
1379 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1380   Compile* C = ra_-&gt;C;
1381 
1382   st-&gt;print("EPILOG\n\t");
1383   st-&gt;print("restore return pc\n\t");
1384   st-&gt;print("pop frame\n\t");
1385 
1386   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
1387     st-&gt;print("touch polling page\n\t");
1388   }
1389 }
1390 #endif
1391 
1392 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1393   Compile* C = ra_-&gt;C;
1394   MacroAssembler _masm(&amp;cbuf);
1395 
1396   const long framesize = ((long)C-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;
1397   assert(framesize &gt;= 0, "negative frame-size?");
1398 
1399   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
1400   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
1401   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
1402   const Register polling_page     = R12;
1403 
1404   if (!method_is_frameless) {
1405     // Restore return pc relative to callers' sp.
1406     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
1407   }
1408 
1409   if (method_needs_polling) {
1410     if (LoadPollAddressFromThread) {
1411       // TODO: PPC port __ ld(polling_page, in_bytes(JavaThread::poll_address_offset()), R16_thread);
1412       Unimplemented();
1413     } else {
1414       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page()); // TODO: PPC port: get_standard_polling_page()
1415     }
1416   }
1417 
1418   if (!method_is_frameless) {
1419     // Move return pc to LR.
1420     __ mtlr(return_pc);
1421     // Pop frame (fixed frame-size).
1422     __ addi(R1_SP, R1_SP, (int)framesize);
1423   }
1424 
1425   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
1426     __ reserved_stack_check(return_pc);
1427   }
1428 
1429   if (method_needs_polling) {
1430     // We need to mark the code position where the load from the safepoint
1431     // polling page was emitted as relocInfo::poll_return_type here.
1432     __ relocate(relocInfo::poll_return_type);
1433     __ load_from_polling_page(polling_page);
1434   }
1435 }
1436 
1437 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
1438   // Variable size. Determine dynamically.
1439   return MachNode::size(ra_);
1440 }
1441 
1442 int MachEpilogNode::reloc() const {
1443   // Return number of relocatable values contained in this instruction.
1444   return 1; // 1 for load_from_polling_page.
1445 }
1446 
1447 const Pipeline * MachEpilogNode::pipeline() const {
1448   return MachNode::pipeline_class();
1449 }
1450 
1451 // This method seems to be obsolete. It is declared in machnode.hpp
1452 // and defined in all *.ad files, but it is never called. Should we
1453 // get rid of it?
1454 int MachEpilogNode::safepoint_offset() const {
1455   assert(do_polling(), "no return for this epilog node");
1456   return 0;
1457 }
1458 
1459 #if 0 // TODO: PPC port
1460 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
1461   MacroAssembler _masm(&amp;cbuf);
1462   if (LoadPollAddressFromThread) {
1463     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
1464   } else {
1465     _masm.nop();
1466   }
1467 }
1468 
1469 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
1470   if (LoadPollAddressFromThread) {
1471     return 4;
1472   } else {
1473     return 4;
1474   }
1475 }
1476 
1477 #ifndef PRODUCT
1478 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
1479   st-&gt;print_cr(" LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread");
1480 }
1481 #endif
1482 
1483 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
1484   return RSCRATCH1_BITS64_REG_mask();
1485 }
1486 #endif // PPC port
1487 
1488 // =============================================================================
1489 
1490 // Figure out which register class each belongs in: rc_int, rc_float or
1491 // rc_stack.
1492 enum RC { rc_bad, rc_int, rc_float, rc_stack };
1493 
1494 static enum RC rc_class(OptoReg::Name reg) {
1495   // Return the register class for the given register. The given register
1496   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
1497   // enumeration in adGlobals_ppc.hpp.
1498 
1499   if (reg == OptoReg::Bad) return rc_bad;
1500 
1501   // We have 64 integer register halves, starting at index 0.
1502   if (reg &lt; 64) return rc_int;
1503 
1504   // We have 64 floating-point register halves, starting at index 64.
1505   if (reg &lt; 64+64) return rc_float;
1506 
1507   // Between float regs &amp; stack are the flags regs.
1508   assert(OptoReg::is_stack(reg), "blow up if spilling flags");
1509 
1510   return rc_stack;
1511 }
1512 
1513 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
1514                         bool do_print, Compile* C, outputStream *st) {
1515 
1516   assert(opcode == Assembler::LD_OPCODE   ||
1517          opcode == Assembler::STD_OPCODE  ||
1518          opcode == Assembler::LWZ_OPCODE  ||
1519          opcode == Assembler::STW_OPCODE  ||
1520          opcode == Assembler::LFD_OPCODE  ||
1521          opcode == Assembler::STFD_OPCODE ||
1522          opcode == Assembler::LFS_OPCODE  ||
1523          opcode == Assembler::STFS_OPCODE,
1524          "opcode not supported");
1525 
1526   if (cbuf) {
1527     int d =
1528       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
1529         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
1530       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
1531     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
1532   }
1533 #ifndef PRODUCT
1534   else if (do_print) {
1535     st-&gt;print("%-7s %s, [R1_SP + #%d+%d] \t// spill copy",
1536               op_str,
1537               Matcher::regName[reg],
1538               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
1539   }
1540 #endif
1541   return 4; // size
1542 }
1543 
1544 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
1545   Compile* C = ra_-&gt;C;
1546 
1547   // Get registers to move.
1548   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
1549   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
1550   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
1551   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
1552 
1553   enum RC src_hi_rc = rc_class(src_hi);
1554   enum RC src_lo_rc = rc_class(src_lo);
1555   enum RC dst_hi_rc = rc_class(dst_hi);
1556   enum RC dst_lo_rc = rc_class(dst_lo);
1557 
1558   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, "must move at least 1 register");
1559   if (src_hi != OptoReg::Bad)
1560     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
1561            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
1562            "expected aligned-adjacent pairs");
1563   // Generate spill code!
1564   int size = 0;
1565 
1566   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
1567     return size;            // Self copy, no move.
1568 
1569   // --------------------------------------
1570   // Memory-&gt;Memory Spill. Use R0 to hold the value.
1571   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
1572     int src_offset = ra_-&gt;reg2offset(src_lo);
1573     int dst_offset = ra_-&gt;reg2offset(dst_lo);
1574     if (src_hi != OptoReg::Bad) {
1575       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
1576              "expected same type of move for high parts");
1577       size += ld_st_helper(cbuf, "LD  ", Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
1578       if (!cbuf &amp;&amp; !do_size) st-&gt;print("\n\t");
1579       size += ld_st_helper(cbuf, "STD ", Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
1580     } else {
1581       size += ld_st_helper(cbuf, "LWZ ", Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
1582       if (!cbuf &amp;&amp; !do_size) st-&gt;print("\n\t");
1583       size += ld_st_helper(cbuf, "STW ", Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
1584     }
1585     return size;
1586   }
1587 
1588   // --------------------------------------
1589   // Check for float-&gt;int copy; requires a trip through memory.
1590   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
1591     Unimplemented();
1592   }
1593 
1594   // --------------------------------------
1595   // Check for integer reg-reg copy.
1596   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
1597       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
1598       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
1599       size = (Rsrc != Rdst) ? 4 : 0;
1600 
1601       if (cbuf) {
1602         MacroAssembler _masm(cbuf);
1603         if (size) {
1604           __ mr(Rdst, Rsrc);
1605         }
1606       }
1607 #ifndef PRODUCT
1608       else if (!do_size) {
1609         if (size) {
1610           st-&gt;print("%-7s %s, %s \t// spill copy", "MR", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
1611         } else {
1612           st-&gt;print("%-7s %s, %s \t// spill copy", "MR-NOP", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
1613         }
1614       }
1615 #endif
1616       return size;
1617   }
1618 
1619   // Check for integer store.
1620   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
1621     int dst_offset = ra_-&gt;reg2offset(dst_lo);
1622     if (src_hi != OptoReg::Bad) {
1623       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
1624              "expected same type of move for high parts");
1625       size += ld_st_helper(cbuf, "STD ", Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
1626     } else {
1627       size += ld_st_helper(cbuf, "STW ", Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
1628     }
1629     return size;
1630   }
1631 
1632   // Check for integer load.
1633   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
1634     int src_offset = ra_-&gt;reg2offset(src_lo);
1635     if (src_hi != OptoReg::Bad) {
1636       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
1637              "expected same type of move for high parts");
1638       size += ld_st_helper(cbuf, "LD  ", Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
1639     } else {
1640       size += ld_st_helper(cbuf, "LWZ ", Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
1641     }
1642     return size;
1643   }
1644 
1645   // Check for float reg-reg copy.
1646   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
1647     if (cbuf) {
1648       MacroAssembler _masm(cbuf);
1649       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
1650       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
1651       __ fmr(Rdst, Rsrc);
1652     }
1653 #ifndef PRODUCT
1654     else if (!do_size) {
1655       st-&gt;print("%-7s %s, %s \t// spill copy", "FMR", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
1656     }
1657 #endif
1658     return 4;
1659   }
1660 
1661   // Check for float store.
1662   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
1663     int dst_offset = ra_-&gt;reg2offset(dst_lo);
1664     if (src_hi != OptoReg::Bad) {
1665       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
1666              "expected same type of move for high parts");
1667       size += ld_st_helper(cbuf, "STFD", Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
1668     } else {
1669       size += ld_st_helper(cbuf, "STFS", Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
1670     }
1671     return size;
1672   }
1673 
1674   // Check for float load.
1675   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
1676     int src_offset = ra_-&gt;reg2offset(src_lo);
1677     if (src_hi != OptoReg::Bad) {
1678       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
1679              "expected same type of move for high parts");
1680       size += ld_st_helper(cbuf, "LFD ", Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
1681     } else {
1682       size += ld_st_helper(cbuf, "LFS ", Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
1683     }
1684     return size;
1685   }
1686 
1687   // --------------------------------------------------------------------
1688   // Check for hi bits still needing moving. Only happens for misaligned
1689   // arguments to native calls.
1690   if (src_hi == dst_hi)
1691     return size;               // Self copy; no move.
1692 
1693   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, "src_hi &amp; dst_hi cannot be Bad");
1694   ShouldNotReachHere(); // Unimplemented
1695   return 0;
1696 }
1697 
1698 #ifndef PRODUCT
1699 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1700   if (!ra_)
1701     st-&gt;print("N%d = SpillCopy(N%d)", _idx, in(1)-&gt;_idx);
1702   else
1703     implementation(NULL, ra_, false, st);
1704 }
1705 #endif
1706 
1707 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1708   implementation(&amp;cbuf, ra_, false, NULL);
1709 }
1710 
1711 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1712   return implementation(NULL, ra_, true, NULL);
1713 }
1714 
1715 #if 0 // TODO: PPC port
1716 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
1717 #ifndef PRODUCT
1718   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
1719 #endif
1720   assert(ra_-&gt;node_regs_max_index() != 0, "");
1721 
1722   // Get registers to move.
1723   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
1724   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
1725   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
1726   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
1727 
1728   enum RC src_lo_rc = rc_class(src_lo);
1729   enum RC dst_lo_rc = rc_class(dst_lo);
1730 
1731   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
1732     return ppc64Opcode_none;            // Self copy, no move.
1733 
1734   // --------------------------------------
1735   // Memory-&gt;Memory Spill. Use R0 to hold the value.
1736   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
1737     return ppc64Opcode_compound;
1738   }
1739 
1740   // --------------------------------------
1741   // Check for float-&gt;int copy; requires a trip through memory.
1742   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
1743     Unimplemented();
1744   }
1745 
1746   // --------------------------------------
1747   // Check for integer reg-reg copy.
1748   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
1749     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
1750     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
1751     if (Rsrc == Rdst) {
1752       return ppc64Opcode_none;
1753     } else {
1754       return ppc64Opcode_or;
1755     }
1756   }
1757 
1758   // Check for integer store.
1759   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
1760     if (src_hi != OptoReg::Bad) {
1761       return ppc64Opcode_std;
1762     } else {
1763       return ppc64Opcode_stw;
1764     }
1765   }
1766 
1767   // Check for integer load.
1768   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
1769     if (src_hi != OptoReg::Bad) {
1770       return ppc64Opcode_ld;
1771     } else {
1772       return ppc64Opcode_lwz;
1773     }
1774   }
1775 
1776   // Check for float reg-reg copy.
1777   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
1778     return ppc64Opcode_fmr;
1779   }
1780 
1781   // Check for float store.
1782   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
1783     if (src_hi != OptoReg::Bad) {
1784       return ppc64Opcode_stfd;
1785     } else {
1786       return ppc64Opcode_stfs;
1787     }
1788   }
1789 
1790   // Check for float load.
1791   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
1792     if (src_hi != OptoReg::Bad) {
1793       return ppc64Opcode_lfd;
1794     } else {
1795       return ppc64Opcode_lfs;
1796     }
1797   }
1798 
1799   // --------------------------------------------------------------------
1800   // Check for hi bits still needing moving. Only happens for misaligned
1801   // arguments to native calls.
1802   if (src_hi == dst_hi) {
1803     return ppc64Opcode_none;               // Self copy; no move.
1804   }
1805 
1806   ShouldNotReachHere();
1807   return ppc64Opcode_undefined;
1808 }
1809 #endif // PPC port
1810 
1811 #ifndef PRODUCT
1812 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1813   st-&gt;print("NOP \t// %d nops to pad for loops.", _count);
1814 }
1815 #endif
1816 
1817 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
1818   MacroAssembler _masm(&amp;cbuf);
1819   // _count contains the number of nops needed for padding.
1820   for (int i = 0; i &lt; _count; i++) {
1821     __ nop();
1822   }
1823 }
1824 
1825 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
1826   return _count * 4;
1827 }
1828 
1829 #ifndef PRODUCT
1830 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1831   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1832   char reg_str[128];
1833   ra_-&gt;dump_register(this, reg_str);
1834   st-&gt;print("ADDI    %s, SP, %d \t// box node", reg_str, offset);
1835 }
1836 #endif
1837 
1838 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1839   MacroAssembler _masm(&amp;cbuf);
1840 
1841   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1842   int reg    = ra_-&gt;get_encode(this);
1843 
1844   if (Assembler::is_simm(offset, 16)) {
1845     __ addi(as_Register(reg), R1, offset);
1846   } else {
1847     ShouldNotReachHere();
1848   }
1849 }
1850 
1851 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
1852   // BoxLockNode is not a MachNode, so we can't just call MachNode::size(ra_).
1853   return 4;
1854 }
1855 
1856 #ifndef PRODUCT
1857 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
1858   st-&gt;print_cr("---- MachUEPNode ----");
1859   st-&gt;print_cr("...");
1860 }
1861 #endif
1862 
1863 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1864   // This is the unverified entry point.
1865   MacroAssembler _masm(&amp;cbuf);
1866 
1867   // Inline_cache contains a klass.
1868   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
1869   Register receiver_klass = R12_scratch2;  // tmp
1870 
1871   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
1872   assert(R11_scratch1 == R11, "need prologue scratch register");
1873 
1874   // Check for NULL argument if we don't have implicit null checks.
1875   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
1876     if (TrapBasedNullChecks) {
1877       __ trap_null_check(R3_ARG1);
1878     } else {
1879       Label valid;
1880       __ cmpdi(CCR0, R3_ARG1, 0);
1881       __ bne_predict_taken(CCR0, valid);
1882       // We have a null argument, branch to ic_miss_stub.
1883       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1884                            relocInfo::runtime_call_type);
1885       __ bind(valid);
1886     }
1887   }
1888   // Assume argument is not NULL, load klass from receiver.
1889   __ load_klass(receiver_klass, R3_ARG1);
1890 
1891   if (TrapBasedICMissChecks) {
1892     __ trap_ic_miss_check(receiver_klass, ic_klass);
1893   } else {
1894     Label valid;
1895     __ cmpd(CCR0, receiver_klass, ic_klass);
1896     __ beq_predict_taken(CCR0, valid);
1897     // We have an unexpected klass, branch to ic_miss_stub.
1898     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1899                          relocInfo::runtime_call_type);
1900     __ bind(valid);
1901   }
1902 
1903   // Argument is valid and klass is as expected, continue.
1904 }
1905 
1906 #if 0 // TODO: PPC port
1907 // Optimize UEP code on z (save a load_const() call in main path).
1908 int MachUEPNode::ep_offset() {
1909   return 0;
1910 }
1911 #endif
1912 
1913 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
1914   // Variable size. Determine dynamically.
1915   return MachNode::size(ra_);
1916 }
1917 
1918 //=============================================================================
1919 
1920 %} // interrupt source
1921 
1922 source_hpp %{ // Header information of the source block.
1923 
1924 class HandlerImpl {
1925 
1926  public:
1927 
1928   static int emit_exception_handler(CodeBuffer &amp;cbuf);
1929   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
1930 
1931   static uint size_exception_handler() {
1932     // The exception_handler is a b64_patchable.
1933     return MacroAssembler::b64_patchable_size;
1934   }
1935 
1936   static uint size_deopt_handler() {
1937     // The deopt_handler is a bl64_patchable.
1938     return MacroAssembler::bl64_patchable_size;
1939   }
1940 
1941 };
1942 
1943 %} // end source_hpp
1944 
1945 source %{
1946 
1947 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
1948   MacroAssembler _masm(&amp;cbuf);
1949 
1950   address base = __ start_a_stub(size_exception_handler());
1951   if (base == NULL) return 0; // CodeBuffer::expand failed
1952 
1953   int offset = __ offset();
1954   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
1955                        relocInfo::runtime_call_type);
1956   assert(__ offset() - offset == (int)size_exception_handler(), "must be fixed size");
1957   __ end_a_stub();
1958 
1959   return offset;
1960 }
1961 
1962 // The deopt_handler is like the exception handler, but it calls to
1963 // the deoptimization blob instead of jumping to the exception blob.
1964 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
1965   MacroAssembler _masm(&amp;cbuf);
1966 
1967   address base = __ start_a_stub(size_deopt_handler());
1968   if (base == NULL) return 0; // CodeBuffer::expand failed
1969 
1970   int offset = __ offset();
1971   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
1972                         relocInfo::runtime_call_type);
1973   assert(__ offset() - offset == (int) size_deopt_handler(), "must be fixed size");
1974   __ end_a_stub();
1975 
1976   return offset;
1977 }
1978 
1979 //=============================================================================
1980 
1981 // Use a frame slots bias for frameless methods if accessing the stack.
1982 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
1983   if (as_Register(reg_enc) == R1_SP) {
1984     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
1985   }
1986   return 0;
1987 }
1988 
1989 const bool Matcher::match_rule_supported(int opcode) {
1990   if (!has_match_rule(opcode))
1991     return false;
1992 
1993   switch (opcode) {
1994   case Op_SqrtD:
1995     return VM_Version::has_fsqrt();
1996   case Op_CountLeadingZerosI:
1997   case Op_CountLeadingZerosL:
1998   case Op_CountTrailingZerosI:
1999   case Op_CountTrailingZerosL:
2000     if (!UseCountLeadingZerosInstructionsPPC64)
2001       return false;
2002     break;
2003 
2004   case Op_PopCountI:
2005   case Op_PopCountL:
2006     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
2007 
2008   case Op_StrComp:
2009     return SpecialStringCompareTo;
2010   case Op_StrEquals:
2011     return SpecialStringEquals;
2012   case Op_StrIndexOf:
2013     return SpecialStringIndexOf;
2014   case Op_StrIndexOfChar:
2015     return SpecialStringIndexOf;
2016   }
2017 
2018   return true;  // Per default match rules are supported.
2019 }
2020 
2021 const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {
2022 
2023   // TODO
2024   // identify extra cases that we might want to provide match rules for
2025   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
2026   bool ret_value = match_rule_supported(opcode);
2027   // Add rules here.
2028 
2029   return ret_value;  // Per default match rules are supported.
2030 }
2031 
2032 const bool Matcher::has_predicated_vectors(void) {
2033   return false;
2034 }
2035 
2036 const int Matcher::float_pressure(int default_pressure_threshold) {
2037   return default_pressure_threshold;
2038 }
2039 
2040 int Matcher::regnum_to_fpu_offset(int regnum) {
2041   // No user for this method?
2042   Unimplemented();
2043   return 999;
2044 }
2045 
2046 const bool Matcher::convL2FSupported(void) {
2047   // fcfids can do the conversion (&gt;= Power7).
2048   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
2049   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
2050 }
2051 
2052 // Vector width in bytes.
2053 const int Matcher::vector_width_in_bytes(BasicType bt) {
2054   assert(MaxVectorSize == 8, "");
2055   return 8;
2056 }
2057 
2058 // Vector ideal reg.
2059 const int Matcher::vector_ideal_reg(int size) {
2060   assert(MaxVectorSize == 8 &amp;&amp; size == 8, "");
2061   return Op_RegL;
2062 }
2063 
2064 const int Matcher::vector_shift_count_ideal_reg(int size) {
2065   fatal("vector shift is not supported");
2066   return Node::NotAMachineReg;
2067 }
2068 
2069 // Limits on vector size (number of elements) loaded into vector.
2070 const int Matcher::max_vector_size(const BasicType bt) {
2071   assert(is_java_primitive(bt), "only primitive type vectors");
2072   return vector_width_in_bytes(bt)/type2aelembytes(bt);
2073 }
2074 
2075 const int Matcher::min_vector_size(const BasicType bt) {
2076   return max_vector_size(bt); // Same as max.
2077 }
2078 
2079 // PPC doesn't support misaligned vectors store/load.
2080 const bool Matcher::misaligned_vectors_ok() {
2081   return false;
2082 }
2083 
2084 // PPC AES support not yet implemented
2085 const bool Matcher::pass_original_key_for_aes() {
2086   return false;
2087 }
2088 
2089 // RETURNS: whether this branch offset is short enough that a short
2090 // branch can be used.
2091 //
2092 // If the platform does not provide any short branch variants, then
2093 // this method should return `false' for offset 0.
2094 //
2095 // `Compile::Fill_buffer' will decide on basis of this information
2096 // whether to do the pass `Compile::Shorten_branches' at all.
2097 //
2098 // And `Compile::Shorten_branches' will decide on basis of this
2099 // information whether to replace particular branch sites by short
2100 // ones.
2101 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
2102   // Is the offset within the range of a ppc64 pc relative branch?
2103   bool b;
2104 
2105   const int safety_zone = 3 * BytesPerInstWord;
2106   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
2107                          29 - 16 + 1 + 2);
2108   return b;
2109 }
2110 
2111 const bool Matcher::isSimpleConstant64(jlong value) {
2112   // Probably always true, even if a temp register is required.
2113   return true;
2114 }
2115 /* TODO: PPC port
2116 // Make a new machine dependent decode node (with its operands).
2117 MachTypeNode *Matcher::make_decode_node() {
2118   assert(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0,
2119          "This method is only implemented for unscaled cOops mode so far");
2120   MachTypeNode *decode = new decodeN_unscaledNode();
2121   decode-&gt;set_opnd_array(0, new iRegPdstOper());
2122   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
2123   return decode;
2124 }
2125 */
2126 
2127 // false =&gt; size gets scaled to BytesPerLong, ok.
2128 const bool Matcher::init_array_count_is_in_bytes = false;
2129 
2130 // Use conditional move (CMOVL) on Power7.
2131 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
2132 
2133 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
2134 // fsel doesn't accept a condition register as input, so this would be slightly different.
2135 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
2136 
2137 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
2138 const bool Matcher::require_postalloc_expand = true;
2139 
2140 // Do we need to mask the count passed to shift instructions or does
2141 // the cpu only look at the lower 5/6 bits anyway?
2142 // PowerPC requires masked shift counts.
2143 const bool Matcher::need_masked_shift_count = true;
2144 
2145 // This affects two different things:
2146 //  - how Decode nodes are matched
2147 //  - how ImplicitNullCheck opportunities are recognized
2148 // If true, the matcher will try to remove all Decodes and match them
2149 // (as operands) into nodes. NullChecks are not prepared to deal with
2150 // Decodes by final_graph_reshaping().
2151 // If false, final_graph_reshaping() forces the decode behind the Cmp
2152 // for a NullCheck. The matcher matches the Decode node into a register.
2153 // Implicit_null_check optimization moves the Decode along with the
2154 // memory operation back up before the NullCheck.
2155 bool Matcher::narrow_oop_use_complex_address() {
2156   // TODO: PPC port if (MatchDecodeNodes) return true;
2157   return false;
2158 }
2159 
2160 bool Matcher::narrow_klass_use_complex_address() {
2161   NOT_LP64(ShouldNotCallThis());
2162   assert(UseCompressedClassPointers, "only for compressed klass code");
2163   // TODO: PPC port if (MatchDecodeNodes) return true;
2164   return false;
2165 }
2166 
2167 bool Matcher::const_oop_prefer_decode() {
2168   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
2169   return Universe::narrow_oop_base() == NULL;
2170 }
2171 
2172 bool Matcher::const_klass_prefer_decode() {
2173   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
2174   return Universe::narrow_klass_base() == NULL;
2175 }
2176 
2177 // Is it better to copy float constants, or load them directly from memory?
2178 // Intel can load a float constant from a direct address, requiring no
2179 // extra registers. Most RISCs will have to materialize an address into a
2180 // register first, so they would do better to copy the constant from stack.
2181 const bool Matcher::rematerialize_float_constants = false;
2182 
2183 // If CPU can load and store mis-aligned doubles directly then no fixup is
2184 // needed. Else we split the double into 2 integer pieces and move it
2185 // piece-by-piece. Only happens when passing doubles into C code as the
2186 // Java calling convention forces doubles to be aligned.
2187 const bool Matcher::misaligned_doubles_ok = true;
2188 
2189 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
2190  Unimplemented();
2191 }
2192 
2193 // Advertise here if the CPU requires explicit rounding operations
2194 // to implement the UseStrictFP mode.
2195 const bool Matcher::strict_fp_requires_explicit_rounding = false;
2196 
2197 // Do floats take an entire double register or just half?
2198 //
2199 // A float occupies a ppc64 double register. For the allocator, a
2200 // ppc64 double register appears as a pair of float registers.
2201 bool Matcher::float_in_double() { return true; }
2202 
2203 // Do ints take an entire long register or just half?
2204 // The relevant question is how the int is callee-saved:
2205 // the whole long is written but de-opt'ing will have to extract
2206 // the relevant 32 bits.
2207 const bool Matcher::int_in_long = true;
2208 
2209 // Constants for c2c and c calling conventions.
2210 
2211 const MachRegisterNumbers iarg_reg[8] = {
2212   R3_num, R4_num, R5_num, R6_num,
2213   R7_num, R8_num, R9_num, R10_num
2214 };
2215 
2216 const MachRegisterNumbers farg_reg[13] = {
2217   F1_num, F2_num, F3_num, F4_num,
2218   F5_num, F6_num, F7_num, F8_num,
2219   F9_num, F10_num, F11_num, F12_num,
2220   F13_num
2221 };
2222 
2223 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
2224 
2225 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
2226 
2227 // Return whether or not this register is ever used as an argument. This
2228 // function is used on startup to build the trampoline stubs in generateOptoStub.
2229 // Registers not mentioned will be killed by the VM call in the trampoline, and
2230 // arguments in those registers not be available to the callee.
2231 bool Matcher::can_be_java_arg(int reg) {
2232   // We return true for all registers contained in iarg_reg[] and
2233   // farg_reg[] and their virtual halves.
2234   // We must include the virtual halves in order to get STDs and LDs
2235   // instead of STWs and LWs in the trampoline stubs.
2236 
2237   if (   reg == R3_num  || reg == R3_H_num
2238       || reg == R4_num  || reg == R4_H_num
2239       || reg == R5_num  || reg == R5_H_num
2240       || reg == R6_num  || reg == R6_H_num
2241       || reg == R7_num  || reg == R7_H_num
2242       || reg == R8_num  || reg == R8_H_num
2243       || reg == R9_num  || reg == R9_H_num
2244       || reg == R10_num || reg == R10_H_num)
2245     return true;
2246 
2247   if (   reg == F1_num  || reg == F1_H_num
2248       || reg == F2_num  || reg == F2_H_num
2249       || reg == F3_num  || reg == F3_H_num
2250       || reg == F4_num  || reg == F4_H_num
2251       || reg == F5_num  || reg == F5_H_num
2252       || reg == F6_num  || reg == F6_H_num
2253       || reg == F7_num  || reg == F7_H_num
2254       || reg == F8_num  || reg == F8_H_num
2255       || reg == F9_num  || reg == F9_H_num
2256       || reg == F10_num || reg == F10_H_num
2257       || reg == F11_num || reg == F11_H_num
2258       || reg == F12_num || reg == F12_H_num
2259       || reg == F13_num || reg == F13_H_num)
2260     return true;
2261 
2262   return false;
2263 }
2264 
2265 bool Matcher::is_spillable_arg(int reg) {
2266   return can_be_java_arg(reg);
2267 }
2268 
2269 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
2270   return false;
2271 }
2272 
2273 // Register for DIVI projection of divmodI.
2274 RegMask Matcher::divI_proj_mask() {
2275   ShouldNotReachHere();
2276   return RegMask();
2277 }
2278 
2279 // Register for MODI projection of divmodI.
2280 RegMask Matcher::modI_proj_mask() {
2281   ShouldNotReachHere();
2282   return RegMask();
2283 }
2284 
2285 // Register for DIVL projection of divmodL.
2286 RegMask Matcher::divL_proj_mask() {
2287   ShouldNotReachHere();
2288   return RegMask();
2289 }
2290 
2291 // Register for MODL projection of divmodL.
2292 RegMask Matcher::modL_proj_mask() {
2293   ShouldNotReachHere();
2294   return RegMask();
2295 }
2296 
2297 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
2298   return RegMask();
2299 }
2300 
2301 const bool Matcher::convi2l_type_required = true;
2302 
2303 %}
2304 
2305 //----------ENCODING BLOCK-----------------------------------------------------
2306 // This block specifies the encoding classes used by the compiler to output
2307 // byte streams. Encoding classes are parameterized macros used by
2308 // Machine Instruction Nodes in order to generate the bit encoding of the
2309 // instruction. Operands specify their base encoding interface with the
2310 // interface keyword. There are currently supported four interfaces,
2311 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
2312 // operand to generate a function which returns its register number when
2313 // queried. CONST_INTER causes an operand to generate a function which
2314 // returns the value of the constant when queried. MEMORY_INTER causes an
2315 // operand to generate four functions which return the Base Register, the
2316 // Index Register, the Scale Value, and the Offset Value of the operand when
2317 // queried. COND_INTER causes an operand to generate six functions which
2318 // return the encoding code (ie - encoding bits for the instruction)
2319 // associated with each basic boolean condition for a conditional instruction.
2320 //
2321 // Instructions specify two basic values for encoding. Again, a function
2322 // is available to check if the constant displacement is an oop. They use the
2323 // ins_encode keyword to specify their encoding classes (which must be
2324 // a sequence of enc_class names, and their parameters, specified in
2325 // the encoding block), and they use the
2326 // opcode keyword to specify, in order, their primary, secondary, and
2327 // tertiary opcode. Only the opcode sections which a particular instruction
2328 // needs for encoding need to be specified.
2329 encode %{
2330   enc_class enc_unimplemented %{
2331     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2332     MacroAssembler _masm(&amp;cbuf);
2333     __ unimplemented("Unimplemented mach node encoding in AD file.", 13);
2334   %}
2335 
2336   enc_class enc_untested %{
2337 #ifdef ASSERT
2338     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2339     MacroAssembler _masm(&amp;cbuf);
2340     __ untested("Untested mach node encoding in AD file.");
2341 #else
2342     // TODO: PPC port $archOpcode(ppc64Opcode_none);
2343 #endif
2344   %}
2345 
2346   enc_class enc_lbz(iRegIdst dst, memory mem) %{
2347     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
2348     MacroAssembler _masm(&amp;cbuf);
2349     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2350     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
2351   %}
2352 
2353   // Load acquire.
2354   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
2355     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2356     MacroAssembler _masm(&amp;cbuf);
2357     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2358     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
2359     __ twi_0($dst$$Register);
2360     __ isync();
2361   %}
2362 
2363   enc_class enc_lhz(iRegIdst dst, memory mem) %{
2364     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
2365 
2366     MacroAssembler _masm(&amp;cbuf);
2367     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2368     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
2369   %}
2370 
2371   // Load acquire.
2372   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
2373     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2374 
2375     MacroAssembler _masm(&amp;cbuf);
2376     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2377     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
2378     __ twi_0($dst$$Register);
2379     __ isync();
2380   %}
2381 
2382   enc_class enc_lwz(iRegIdst dst, memory mem) %{
2383     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
2384 
2385     MacroAssembler _masm(&amp;cbuf);
2386     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2387     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
2388   %}
2389 
2390   // Load acquire.
2391   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
2392     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2393 
2394     MacroAssembler _masm(&amp;cbuf);
2395     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2396     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
2397     __ twi_0($dst$$Register);
2398     __ isync();
2399   %}
2400 
2401   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
2402     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
2403     MacroAssembler _masm(&amp;cbuf);
2404     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2405     // Operand 'ds' requires 4-alignment.
2406     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
2407     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
2408   %}
2409 
2410   // Load acquire.
2411   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
2412     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2413     MacroAssembler _masm(&amp;cbuf);
2414     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2415     // Operand 'ds' requires 4-alignment.
2416     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
2417     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
2418     __ twi_0($dst$$Register);
2419     __ isync();
2420   %}
2421 
2422   enc_class enc_lfd(RegF dst, memory mem) %{
2423     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
2424     MacroAssembler _masm(&amp;cbuf);
2425     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2426     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
2427   %}
2428 
2429   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
2430     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
2431 
2432     MacroAssembler _masm(&amp;cbuf);
2433     int toc_offset = 0;
2434 
2435     address const_toc_addr;
2436     // Create a non-oop constant, no relocation needed.
2437     // If it is an IC, it has a virtual_call_Relocation.
2438     const_toc_addr = __ long_constant((jlong)$src$$constant);
2439     if (const_toc_addr == NULL) {
2440       ciEnv::current()-&gt;record_out_of_memory_failure();
2441       return;
2442     }
2443     
2444     // Get the constant's TOC offset.
2445     toc_offset = __ offset_to_method_toc(const_toc_addr);
2446     
2447     // Keep the current instruction offset in mind.
2448     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
2449   
2450     __ ld($dst$$Register, toc_offset, $toc$$Register);
2451   %}
2452 
2453   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
2454     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
2455 
2456     MacroAssembler _masm(&amp;cbuf);
2457 
2458     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
2459       address const_toc_addr;
2460       // Create a non-oop constant, no relocation needed.
2461       // If it is an IC, it has a virtual_call_Relocation.
2462       const_toc_addr = __ long_constant((jlong)$src$$constant);
2463       if (const_toc_addr == NULL) {
2464         ciEnv::current()-&gt;record_out_of_memory_failure();
2465         return;
2466       }
2467 
2468       // Get the constant's TOC offset.
2469       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
2470       // Store the toc offset of the constant.
2471       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
2472 
2473       // Also keep the current instruction offset in mind.
2474       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
2475     }
2476 
2477     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
2478   %}
2479 
2480 %} // encode
2481 
2482 source %{
2483 
2484 typedef struct {
2485   loadConL_hiNode *_large_hi;
2486   loadConL_loNode *_large_lo;
2487   loadConLNode    *_small;
2488   MachNode        *_last;
2489 } loadConLNodesTuple;
2490 
2491 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
2492                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
2493   loadConLNodesTuple nodes;
2494 
2495   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2496   if (large_constant_pool) {
2497     // Create new nodes.
2498     loadConL_hiNode *m1 = new loadConL_hiNode();
2499     loadConL_loNode *m2 = new loadConL_loNode();
2500 
2501     // inputs for new nodes
2502     m1-&gt;add_req(NULL, toc);
2503     m2-&gt;add_req(NULL, m1);
2504 
2505     // operands for new nodes
2506     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
2507     m1-&gt;_opnds[1] = immSrc;             // src
2508     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
2509     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
2510     m2-&gt;_opnds[1] = immSrc;             // src
2511     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
2512 
2513     // Initialize ins_attrib TOC fields.
2514     m1-&gt;_const_toc_offset = -1;
2515     m2-&gt;_const_toc_offset_hi_node = m1;
2516 
2517     // Initialize ins_attrib instruction offset.
2518     m1-&gt;_cbuf_insts_offset = -1;
2519 
2520     // register allocation for new nodes
2521     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
2522     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
2523 
2524     // Create result.
2525     nodes._large_hi = m1;
2526     nodes._large_lo = m2;
2527     nodes._small = NULL;
2528     nodes._last = nodes._large_lo;
2529     assert(m2-&gt;bottom_type()-&gt;isa_long(), "must be long");
2530   } else {
2531     loadConLNode *m2 = new loadConLNode();
2532 
2533     // inputs for new nodes
2534     m2-&gt;add_req(NULL, toc);
2535 
2536     // operands for new nodes
2537     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
2538     m2-&gt;_opnds[1] = immSrc;             // src
2539     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
2540 
2541     // Initialize ins_attrib instruction offset.
2542     m2-&gt;_cbuf_insts_offset = -1;
2543 
2544     // register allocation for new nodes
2545     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
2546 
2547     // Create result.
2548     nodes._large_hi = NULL;
2549     nodes._large_lo = NULL;
2550     nodes._small = m2;
2551     nodes._last = nodes._small;
2552     assert(m2-&gt;bottom_type()-&gt;isa_long(), "must be long");
2553   }
2554 
2555   return nodes;
2556 }
2557 
2558 %} // source
2559 
2560 encode %{
2561   // Postalloc expand emitter for loading a long constant from the method's TOC.
2562   // Enc_class needed as consttanttablebase is not supported by postalloc
2563   // expand.
2564   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
2565     // Create new nodes.
2566     loadConLNodesTuple loadConLNodes =
2567       loadConLNodesTuple_create(ra_, n_toc, op_src,
2568                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2569 
2570     // Push new nodes.
2571     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
2572     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
2573 
2574     // some asserts
2575     assert(nodes-&gt;length() &gt;= 1, "must have created at least 1 node");
2576     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), "must be long");
2577   %}
2578 
2579   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
2580     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
2581 
2582     MacroAssembler _masm(&amp;cbuf);
2583     int toc_offset = 0;
2584 
2585     intptr_t val = $src$$constant;
2586     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
2587     address const_toc_addr;
2588     if (constant_reloc == relocInfo::oop_type) {
2589       // Create an oop constant and a corresponding relocation.
2590       AddressLiteral a = __ allocate_oop_address((jobject)val);
2591       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2592       __ relocate(a.rspec());
2593     } else if (constant_reloc == relocInfo::metadata_type) {
2594       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
2595       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2596       __ relocate(a.rspec());
2597     } else {
2598       // Create a non-oop constant, no relocation needed.
2599       const_toc_addr = __ long_constant((jlong)$src$$constant);
2600     }
2601 
2602     if (const_toc_addr == NULL) {
2603       ciEnv::current()-&gt;record_out_of_memory_failure();
2604       return;
2605     }
2606     // Get the constant's TOC offset.
2607     toc_offset = __ offset_to_method_toc(const_toc_addr);
2608 
2609     __ ld($dst$$Register, toc_offset, $toc$$Register);
2610   %}
2611 
2612   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
2613     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
2614 
2615     MacroAssembler _masm(&amp;cbuf);
2616     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
2617       intptr_t val = $src$$constant;
2618       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
2619       address const_toc_addr;
2620       if (constant_reloc == relocInfo::oop_type) {
2621         // Create an oop constant and a corresponding relocation.
2622         AddressLiteral a = __ allocate_oop_address((jobject)val);
2623         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2624         __ relocate(a.rspec());
2625       } else if (constant_reloc == relocInfo::metadata_type) {
2626         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
2627         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
2628         __ relocate(a.rspec());
2629       } else {  // non-oop pointers, e.g. card mark base, heap top
2630         // Create a non-oop constant, no relocation needed.
2631         const_toc_addr = __ long_constant((jlong)$src$$constant);
2632       }
2633 
2634       if (const_toc_addr == NULL) {
2635         ciEnv::current()-&gt;record_out_of_memory_failure();
2636         return;
2637       }
2638       // Get the constant's TOC offset.
2639       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
2640       // Store the toc offset of the constant.
2641       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
2642     }
2643 
2644     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
2645   %}
2646 
2647   // Postalloc expand emitter for loading a ptr constant from the method's TOC.
2648   // Enc_class needed as consttanttablebase is not supported by postalloc
2649   // expand.
2650   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
2651     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2652     if (large_constant_pool) {
2653       // Create new nodes.
2654       loadConP_hiNode *m1 = new loadConP_hiNode();
2655       loadConP_loNode *m2 = new loadConP_loNode();
2656 
2657       // inputs for new nodes
2658       m1-&gt;add_req(NULL, n_toc);
2659       m2-&gt;add_req(NULL, m1);
2660 
2661       // operands for new nodes
2662       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
2663       m1-&gt;_opnds[1] = op_src;             // src
2664       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
2665       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
2666       m2-&gt;_opnds[1] = op_src;             // src
2667       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
2668 
2669       // Initialize ins_attrib TOC fields.
2670       m1-&gt;_const_toc_offset = -1;
2671       m2-&gt;_const_toc_offset_hi_node = m1;
2672 
2673       // Register allocation for new nodes.
2674       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2675       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2676 
2677       nodes-&gt;push(m1);
2678       nodes-&gt;push(m2);
2679       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), "must be ptr");
2680     } else {
2681       loadConPNode *m2 = new loadConPNode();
2682 
2683       // inputs for new nodes
2684       m2-&gt;add_req(NULL, n_toc);
2685 
2686       // operands for new nodes
2687       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
2688       m2-&gt;_opnds[1] = op_src;             // src
2689       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
2690 
2691       // Register allocation for new nodes.
2692       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2693 
2694       nodes-&gt;push(m2);
2695       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), "must be ptr");
2696     }
2697   %}
2698 
2699   // Enc_class needed as consttanttablebase is not supported by postalloc
2700   // expand.
2701   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
2702     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2703 
2704     MachNode *m2;
2705     if (large_constant_pool) {
2706       m2 = new loadConFCompNode();
2707     } else {
2708       m2 = new loadConFNode();
2709     }
2710     // inputs for new nodes
2711     m2-&gt;add_req(NULL, n_toc);
2712 
2713     // operands for new nodes
2714     m2-&gt;_opnds[0] = op_dst;
2715     m2-&gt;_opnds[1] = op_src;
2716     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
2717 
2718     // register allocation for new nodes
2719     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2720     nodes-&gt;push(m2);
2721   %}
2722 
2723   // Enc_class needed as consttanttablebase is not supported by postalloc
2724   // expand.
2725   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
2726     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
2727 
2728     MachNode *m2;
2729     if (large_constant_pool) {
2730       m2 = new loadConDCompNode();
2731     } else {
2732       m2 = new loadConDNode();
2733     }
2734     // inputs for new nodes
2735     m2-&gt;add_req(NULL, n_toc);
2736 
2737     // operands for new nodes
2738     m2-&gt;_opnds[0] = op_dst;
2739     m2-&gt;_opnds[1] = op_src;
2740     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
2741 
2742     // register allocation for new nodes
2743     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2744     nodes-&gt;push(m2);
2745   %}
2746 
2747   enc_class enc_stw(iRegIsrc src, memory mem) %{
2748     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
2749     MacroAssembler _masm(&amp;cbuf);
2750     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2751     __ stw($src$$Register, Idisp, $mem$$base$$Register);
2752   %}
2753 
2754   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
2755     // TODO: PPC port $archOpcode(ppc64Opcode_std);
2756     MacroAssembler _masm(&amp;cbuf);
2757     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2758     // Operand 'ds' requires 4-alignment.
2759     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
2760     __ std($src$$Register, Idisp, $mem$$base$$Register);
2761   %}
2762 
2763   enc_class enc_stfs(RegF src, memory mem) %{
2764     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
2765     MacroAssembler _masm(&amp;cbuf);
2766     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2767     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
2768   %}
2769 
2770   enc_class enc_stfd(RegF src, memory mem) %{
2771     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
2772     MacroAssembler _masm(&amp;cbuf);
2773     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
2774     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
2775   %}
2776 
2777   // Use release_store for card-marking to ensure that previous
2778   // oop-stores are visible before the card-mark change.
2779   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
2780     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
2781     // FIXME: Implement this as a cmove and use a fixed condition code
2782     // register which is written on every transition to compiled code,
2783     // e.g. in call-stub and when returning from runtime stubs.
2784     //
2785     // Proposed code sequence for the cmove implementation:
2786     //
2787     // Label skip_release;
2788     // __ beq(CCRfixed, skip_release);
2789     // __ release();
2790     // __ bind(skip_release);
2791     // __ stb(card mark);
2792 
2793     MacroAssembler _masm(&amp;cbuf);
2794     Label skip_storestore;
2795 
2796 #if 0 // TODO: PPC port
2797     // Check CMSCollectorCardTableModRefBSExt::_requires_release and do the
2798     // StoreStore barrier conditionally.
2799     __ lwz(R0, 0, $releaseFieldAddr$$Register);
2800     __ cmpwi($crx$$CondRegister, R0, 0);
2801     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
2802 #endif
2803     __ li(R0, 0);
2804     __ membar(Assembler::StoreStore);
2805 #if 0 // TODO: PPC port
2806     __ bind(skip_storestore);
2807 #endif
2808 
2809     // Do the store.
2810     if ($mem$$index == 0) {
2811       __ stb(R0, $mem$$disp, $mem$$base$$Register);
2812     } else {
2813       assert(0 == $mem$$disp, "no displacement possible with indexed load/stores on ppc");
2814       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
2815     }
2816   %}
2817 
2818   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
2819 
2820     if (VM_Version::has_isel()) {
2821       // use isel instruction with Power 7
2822       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
2823       encodeP_subNode    *n_sub_base = new encodeP_subNode();
2824       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
2825       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
2826 
2827       n_compare-&gt;add_req(n_region, n_src);
2828       n_compare-&gt;_opnds[0] = op_crx;
2829       n_compare-&gt;_opnds[1] = op_src;
2830       n_compare-&gt;_opnds[2] = new immL16Oper(0);
2831 
2832       n_sub_base-&gt;add_req(n_region, n_src);
2833       n_sub_base-&gt;_opnds[0] = op_dst;
2834       n_sub_base-&gt;_opnds[1] = op_src;
2835       n_sub_base-&gt;_bottom_type = _bottom_type;
2836 
2837       n_shift-&gt;add_req(n_region, n_sub_base);
2838       n_shift-&gt;_opnds[0] = op_dst;
2839       n_shift-&gt;_opnds[1] = op_dst;
2840       n_shift-&gt;_bottom_type = _bottom_type;
2841 
2842       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
2843       n_cond_set-&gt;_opnds[0] = op_dst;
2844       n_cond_set-&gt;_opnds[1] = op_crx;
2845       n_cond_set-&gt;_opnds[2] = op_dst;
2846       n_cond_set-&gt;_bottom_type = _bottom_type;
2847 
2848       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2849       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2850       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2851       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2852 
2853       nodes-&gt;push(n_compare);
2854       nodes-&gt;push(n_sub_base);
2855       nodes-&gt;push(n_shift);
2856       nodes-&gt;push(n_cond_set);
2857 
2858     } else {
2859       // before Power 7
2860       moveRegNode        *n_move     = new moveRegNode();
2861       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
2862       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
2863       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
2864 
2865       n_move-&gt;add_req(n_region, n_src);
2866       n_move-&gt;_opnds[0] = op_dst;
2867       n_move-&gt;_opnds[1] = op_src;
2868       ra_-&gt;set_oop(n_move, true); // Until here, 'n_move' still produces an oop.
2869 
2870       n_compare-&gt;add_req(n_region, n_src);
2871       n_compare-&gt;add_prec(n_move);
2872 
2873       n_compare-&gt;_opnds[0] = op_crx;
2874       n_compare-&gt;_opnds[1] = op_src;
2875       n_compare-&gt;_opnds[2] = new immL16Oper(0);
2876 
2877       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
2878       n_sub_base-&gt;_opnds[0] = op_dst;
2879       n_sub_base-&gt;_opnds[1] = op_crx;
2880       n_sub_base-&gt;_opnds[2] = op_src;
2881       n_sub_base-&gt;_bottom_type = _bottom_type;
2882 
2883       n_shift-&gt;add_req(n_region, n_sub_base);
2884       n_shift-&gt;_opnds[0] = op_dst;
2885       n_shift-&gt;_opnds[1] = op_dst;
2886       n_shift-&gt;_bottom_type = _bottom_type;
2887 
2888       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2889       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2890       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2891       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2892 
2893       nodes-&gt;push(n_move);
2894       nodes-&gt;push(n_compare);
2895       nodes-&gt;push(n_sub_base);
2896       nodes-&gt;push(n_shift);
2897     }
2898 
2899     assert(!(ra_-&gt;is_oop(this)), "sanity"); // This is not supposed to be GC'ed.
2900   %}
2901 
2902   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
2903 
2904     encodeP_subNode *n1 = new encodeP_subNode();
2905     n1-&gt;add_req(n_region, n_src);
2906     n1-&gt;_opnds[0] = op_dst;
2907     n1-&gt;_opnds[1] = op_src;
2908     n1-&gt;_bottom_type = _bottom_type;
2909 
2910     encodeP_shiftNode *n2 = new encodeP_shiftNode();
2911     n2-&gt;add_req(n_region, n1);
2912     n2-&gt;_opnds[0] = op_dst;
2913     n2-&gt;_opnds[1] = op_dst;
2914     n2-&gt;_bottom_type = _bottom_type;
2915     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2916     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2917 
2918     nodes-&gt;push(n1);
2919     nodes-&gt;push(n2);
2920     assert(!(ra_-&gt;is_oop(this)), "sanity"); // This is not supposed to be GC'ed.
2921   %}
2922 
2923   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
2924     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
2925     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
2926 
2927     n_compare-&gt;add_req(n_region, n_src);
2928     n_compare-&gt;_opnds[0] = op_crx;
2929     n_compare-&gt;_opnds[1] = op_src;
2930     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
2931 
2932     n_shift-&gt;add_req(n_region, n_src);
2933     n_shift-&gt;_opnds[0] = op_dst;
2934     n_shift-&gt;_opnds[1] = op_src;
2935     n_shift-&gt;_bottom_type = _bottom_type;
2936 
2937     if (VM_Version::has_isel()) {
2938       // use isel instruction with Power 7
2939 
2940       decodeN_addNode *n_add_base = new decodeN_addNode();
2941       n_add_base-&gt;add_req(n_region, n_shift);
2942       n_add_base-&gt;_opnds[0] = op_dst;
2943       n_add_base-&gt;_opnds[1] = op_dst;
2944       n_add_base-&gt;_bottom_type = _bottom_type;
2945 
2946       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
2947       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
2948       n_cond_set-&gt;_opnds[0] = op_dst;
2949       n_cond_set-&gt;_opnds[1] = op_crx;
2950       n_cond_set-&gt;_opnds[2] = op_dst;
2951       n_cond_set-&gt;_bottom_type = _bottom_type;
2952 
2953       assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
2954       ra_-&gt;set_oop(n_cond_set, true);
2955 
2956       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2957       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2958       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2959       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2960 
2961       nodes-&gt;push(n_compare);
2962       nodes-&gt;push(n_shift);
2963       nodes-&gt;push(n_add_base);
2964       nodes-&gt;push(n_cond_set);
2965 
2966     } else {
2967       // before Power 7
2968       cond_add_baseNode *n_add_base = new cond_add_baseNode();
2969 
2970       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
2971       n_add_base-&gt;_opnds[0] = op_dst;
2972       n_add_base-&gt;_opnds[1] = op_crx;
2973       n_add_base-&gt;_opnds[2] = op_dst;
2974       n_add_base-&gt;_bottom_type = _bottom_type;
2975 
2976       assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
2977       ra_-&gt;set_oop(n_add_base, true);
2978 
2979       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2980       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
2981       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
2982 
2983       nodes-&gt;push(n_compare);
2984       nodes-&gt;push(n_shift);
2985       nodes-&gt;push(n_add_base);
2986     }
2987   %}
2988 
2989   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
2990     decodeN_shiftNode *n1 = new decodeN_shiftNode();
2991     n1-&gt;add_req(n_region, n_src);
2992     n1-&gt;_opnds[0] = op_dst;
2993     n1-&gt;_opnds[1] = op_src;
2994     n1-&gt;_bottom_type = _bottom_type;
2995 
2996     decodeN_addNode *n2 = new decodeN_addNode();
2997     n2-&gt;add_req(n_region, n1);
2998     n2-&gt;_opnds[0] = op_dst;
2999     n2-&gt;_opnds[1] = op_dst;
3000     n2-&gt;_bottom_type = _bottom_type;
3001     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
3002     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
3003 
3004     assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
3005     ra_-&gt;set_oop(n2, true);
3006 
3007     nodes-&gt;push(n1);
3008     nodes-&gt;push(n2);
3009   %}
3010 
3011   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
3012     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
3013 
3014     MacroAssembler _masm(&amp;cbuf);
3015     int cc        = $cmp$$cmpcode;
3016     int flags_reg = $crx$$reg;
3017     Label done;
3018     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
3019     // Branch if not (cmp crx).
3020     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
3021     __ mr($dst$$Register, $src$$Register);
3022     // TODO PPC port __ endgroup_if_needed(_size == 12);
3023     __ bind(done);
3024   %}
3025 
3026   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
3027     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
3028 
3029     MacroAssembler _masm(&amp;cbuf);
3030     Label done;
3031     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
3032     // Branch if not (cmp crx).
3033     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
3034     __ li($dst$$Register, $src$$constant);
3035     // TODO PPC port __ endgroup_if_needed(_size == 12);
3036     __ bind(done);
3037   %}
3038 
3039   // This enc_class is needed so that scheduler gets proper
3040   // input mapping for latency computation.
3041   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
3042     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
3043     MacroAssembler _masm(&amp;cbuf);
3044     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
3045   %}
3046 
3047   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
3048     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3049 
3050     MacroAssembler _masm(&amp;cbuf);
3051 
3052     Label done;
3053     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
3054     __ li($dst$$Register, $zero$$constant);
3055     __ beq($crx$$CondRegister, done);
3056     __ li($dst$$Register, $notzero$$constant);
3057     __ bind(done);
3058   %}
3059 
3060   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
3061     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3062 
3063     MacroAssembler _masm(&amp;cbuf);
3064 
3065     Label done;
3066     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
3067     __ li($dst$$Register, $zero$$constant);
3068     __ beq($crx$$CondRegister, done);
3069     __ li($dst$$Register, $notzero$$constant);
3070     __ bind(done);
3071   %}
3072 
3073   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
3074     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
3075 
3076     MacroAssembler _masm(&amp;cbuf);
3077     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
3078     Label done;
3079     __ bso($crx$$CondRegister, done);
3080     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
3081     // TODO PPC port __ endgroup_if_needed(_size == 12);
3082     __ bind(done);
3083   %}
3084 
3085   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
3086     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
3087 
3088     MacroAssembler _masm(&amp;cbuf);
3089     Label d;   // dummy
3090     __ bind(d);
3091     Label* p = ($lbl$$label);
3092     // `p' is `NULL' when this encoding class is used only to
3093     // determine the size of the encoded instruction.
3094     Label&amp; l = (NULL == p)? d : *(p);
3095     int cc = $cmp$$cmpcode;
3096     int flags_reg = $crx$$reg;
3097     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
3098     int bhint = Assembler::bhintNoHint;
3099 
3100     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
3101       if (_prob &lt;= PROB_NEVER) {
3102         bhint = Assembler::bhintIsNotTaken;
3103       } else if (_prob &gt;= PROB_ALWAYS) {
3104         bhint = Assembler::bhintIsTaken;
3105       }
3106     }
3107 
3108     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3109           cc_to_biint(cc, flags_reg),
3110           l);
3111   %}
3112 
3113   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
3114     // The scheduler doesn't know about branch shortening, so we set the opcode
3115     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
3116     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
3117 
3118     MacroAssembler _masm(&amp;cbuf);
3119     Label d;    // dummy
3120     __ bind(d);
3121     Label* p = ($lbl$$label);
3122     // `p' is `NULL' when this encoding class is used only to
3123     // determine the size of the encoded instruction.
3124     Label&amp; l = (NULL == p)? d : *(p);
3125     int cc = $cmp$$cmpcode;
3126     int flags_reg = $crx$$reg;
3127     int bhint = Assembler::bhintNoHint;
3128 
3129     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
3130       if (_prob &lt;= PROB_NEVER) {
3131         bhint = Assembler::bhintIsNotTaken;
3132       } else if (_prob &gt;= PROB_ALWAYS) {
3133         bhint = Assembler::bhintIsTaken;
3134       }
3135     }
3136 
3137     // Tell the conditional far branch to optimize itself when being relocated.
3138     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3139                   cc_to_biint(cc, flags_reg),
3140                   l,
3141                   MacroAssembler::bc_far_optimize_on_relocate);
3142   %}
3143 
3144   // Branch used with Power6 scheduling (can be shortened without changing the node).
3145   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
3146     // The scheduler doesn't know about branch shortening, so we set the opcode
3147     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
3148     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
3149 
3150     MacroAssembler _masm(&amp;cbuf);
3151     Label d;   // dummy
3152     __ bind(d);
3153     Label* p = ($lbl$$label);
3154     // `p' is `NULL' when this encoding class is used only to
3155     // determine the size of the encoded instruction.
3156     Label&amp; l = (NULL == p)? d : *(p);
3157     int cc = $cmp$$cmpcode;
3158     int flags_reg = $crx$$reg;
3159     int bhint = Assembler::bhintNoHint;
3160 
3161     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
3162       if (_prob &lt;= PROB_NEVER) {
3163         bhint = Assembler::bhintIsNotTaken;
3164       } else if (_prob &gt;= PROB_ALWAYS) {
3165         bhint = Assembler::bhintIsTaken;
3166       }
3167     }
3168 
3169 #if 0 // TODO: PPC port
3170     if (_size == 8) {
3171       // Tell the conditional far branch to optimize itself when being relocated.
3172       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3173                     cc_to_biint(cc, flags_reg),
3174                     l,
3175                     MacroAssembler::bc_far_optimize_on_relocate);
3176     } else {
3177       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
3178                     cc_to_biint(cc, flags_reg),
3179                     l);
3180     }
3181 #endif
3182     Unimplemented();
3183   %}
3184 
3185   // Postalloc expand emitter for loading a replicatef float constant from
3186   // the method's TOC.
3187   // Enc_class needed as consttanttablebase is not supported by postalloc
3188   // expand.
3189   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
3190     // Create new nodes.
3191 
3192     // Make an operand with the bit pattern to load as float.
3193     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
3194 
3195     loadConLNodesTuple loadConLNodes =
3196       loadConLNodesTuple_create(ra_, n_toc, op_repl,
3197                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
3198 
3199     // Push new nodes.
3200     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
3201     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
3202 
3203     assert(nodes-&gt;length() &gt;= 1, "must have created at least 1 node");
3204     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), "must be long");
3205   %}
3206 
3207   // This enc_class is needed so that scheduler gets proper
3208   // input mapping for latency computation.
3209   enc_class enc_poll(immI dst, iRegLdst poll) %{
3210     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
3211     // Fake operand dst needed for PPC scheduler.
3212     assert($dst$$constant == 0x0, "dst must be 0x0");
3213 
3214     MacroAssembler _masm(&amp;cbuf);
3215     // Mark the code position where the load from the safepoint
3216     // polling page was emitted as relocInfo::poll_type.
3217     __ relocate(relocInfo::poll_type);
3218     __ load_from_polling_page($poll$$Register);
3219   %}
3220 
3221   // A Java static call or a runtime call.
3222   //
3223   // Branch-and-link relative to a trampoline.
3224   // The trampoline loads the target address and does a long branch to there.
3225   // In case we call java, the trampoline branches to a interpreter_stub
3226   // which loads the inline cache and the real call target from the constant pool.
3227   //
3228   // This basically looks like this:
3229   //
3230   // &gt;&gt;&gt;&gt; consts      -+  -+
3231   //                   |   |- offset1
3232   // [call target1]    | &lt;-+
3233   // [IC cache]        |- offset2
3234   // [call target2] &lt;--+
3235   //
3236   // &lt;&lt;&lt;&lt; consts
3237   // &gt;&gt;&gt;&gt; insts
3238   //
3239   // bl offset16               -+  -+             ??? // How many bits available?
3240   //                            |   |
3241   // &lt;&lt;&lt;&lt; insts                 |   |
3242   // &gt;&gt;&gt;&gt; stubs                 |   |
3243   //                            |   |- trampoline_stub_Reloc
3244   // trampoline stub:           | &lt;-+
3245   //   r2 = toc                 |
3246   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
3247   //   mtctr r2                 |
3248   //   bctr                     |- static_stub_Reloc
3249   // comp_to_interp_stub:   &lt;---+
3250   //   r1 = toc
3251   //   ICreg = [r1 + IC_offset]         // Load IC from const section
3252   //   r1    = [r1 + offset2]           // Load call target2 from const section
3253   //   mtctr r1
3254   //   bctr
3255   //
3256   // &lt;&lt;&lt;&lt; stubs
3257   //
3258   // The call instruction in the code either
3259   // - Branches directly to a compiled method if the offset is encodable in instruction.
3260   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
3261   // - Branches to the compiled_to_interp stub if the target is interpreted.
3262   //
3263   // Further there are three relocations from the loads to the constants in
3264   // the constant section.
3265   //
3266   // Usage of r1 and r2 in the stubs allows to distinguish them.
3267   enc_class enc_java_static_call(method meth) %{
3268     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
3269 
3270     MacroAssembler _masm(&amp;cbuf);
3271     address entry_point = (address)$meth$$method;
3272 
3273     if (!_method) {
3274       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
3275       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
3276     } else {
3277       // Remember the offset not the address.
3278       const int start_offset = __ offset();
3279 
3280       // The trampoline stub.
3281       // No entry point given, use the current pc.
3282       // Make sure branch fits into
3283       if (entry_point == 0) entry_point = __ pc();
3284 
3285       // Put the entry point as a constant into the constant pool.
3286       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
3287       if (entry_point_toc_addr == NULL) {
3288         ciEnv::current()-&gt;record_out_of_memory_failure();
3289         return;
3290       }
3291       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
3292 
3293       // Emit the trampoline stub which will be related to the branch-and-link below.
3294       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
3295       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
3296       int method_index = resolved_method_index(cbuf);
3297       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
3298                   : static_call_Relocation::spec(method_index));
3299 
3300       // The real call.
3301       // Note: At this point we do not have the address of the trampoline
3302       // stub, and the entry point might be too far away for bl, so __ pc()
3303       // serves as dummy and the bl will be patched later.
3304       cbuf.set_insts_mark();
3305       __ bl(__ pc());  // Emits a relocation.
3306 
3307       // The stub for call to interpreter.
3308       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
3309       if (stub == NULL) {
3310         ciEnv::current()-&gt;record_failure("CodeCache is full");
3311         return;
3312       }
3313     }
3314   %}
3315 
3316   // Second node of expanded dynamic call - the call.
3317   enc_class enc_java_dynamic_call_sched(method meth) %{
3318     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
3319 
3320     MacroAssembler _masm(&amp;cbuf);
3321 
3322     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
3323       // Create a call trampoline stub for the given method.
3324       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
3325       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
3326       if (entry_point_const == NULL) {
3327         ciEnv::current()-&gt;record_out_of_memory_failure();
3328         return;
3329       }
3330       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
3331       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
3332       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
3333 
3334       // Build relocation at call site with ic position as data.
3335       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
3336              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
3337              "must have one, but can't have both");
3338       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
3339              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
3340              "must contain instruction offset");
3341       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
3342         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
3343         : _load_ic_node-&gt;_cbuf_insts_offset;
3344       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
3345       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
3346              "should be load from TOC");
3347       int method_index = resolved_method_index(cbuf);
3348       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
3349     }
3350 
3351     // At this point I do not have the address of the trampoline stub,
3352     // and the entry point might be too far away for bl. Pc() serves
3353     // as dummy and bl will be patched later.
3354     __ bl((address) __ pc());
3355   %}
3356 
3357   // postalloc expand emitter for virtual calls.
3358   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
3359 
3360     // Create the nodes for loading the IC from the TOC.
3361     loadConLNodesTuple loadConLNodes_IC =
3362       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
3363                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
3364 
3365     // Create the call node.
3366     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
3367     call-&gt;_method_handle_invoke = _method_handle_invoke;
3368     call-&gt;_vtable_index      = _vtable_index;
3369     call-&gt;_method            = _method;
3370     call-&gt;_bci               = _bci;
3371     call-&gt;_optimized_virtual = _optimized_virtual;
3372     call-&gt;_tf                = _tf;
3373     call-&gt;_entry_point       = _entry_point;
3374     call-&gt;_cnt               = _cnt;
3375     call-&gt;_argsize           = _argsize;
3376     call-&gt;_oop_map           = _oop_map;
3377     call-&gt;_jvms              = _jvms;
3378     call-&gt;_jvmadj            = _jvmadj;
3379     call-&gt;_in_rms            = _in_rms;
3380     call-&gt;_nesting           = _nesting;
3381     call-&gt;_override_symbolic_info = _override_symbolic_info;
3382 
3383     // New call needs all inputs of old call.
3384     // Req...
3385     for (uint i = 0; i &lt; req(); ++i) {
3386       // The expanded node does not need toc any more.
3387       // Add the inline cache constant here instead. This expresses the
3388       // register of the inline cache must be live at the call.
3389       // Else we would have to adapt JVMState by -1.
3390       if (i == mach_constant_base_node_input()) {
3391         call-&gt;add_req(loadConLNodes_IC._last);
3392       } else {
3393         call-&gt;add_req(in(i));
3394       }
3395     }
3396     // ...as well as prec
3397     for (uint i = req(); i &lt; len(); ++i) {
3398       call-&gt;add_prec(in(i));
3399     }
3400 
3401     // Remember nodes loading the inline cache into r19.
3402     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
3403     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
3404 
3405     // Operands for new nodes.
3406     call-&gt;_opnds[0] = _opnds[0];
3407     call-&gt;_opnds[1] = _opnds[1];
3408 
3409     // Only the inline cache is associated with a register.
3410     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), "ic reg should be R19");
3411 
3412     // Push new nodes.
3413     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
3414     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
3415     nodes-&gt;push(call);
3416   %}
3417 
3418   // Compound version of call dynamic
3419   // Toc is only passed so that it can be used in ins_encode statement.
3420   // In the code we have to use $constanttablebase.
3421   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
3422     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3423     MacroAssembler _masm(&amp;cbuf);
3424     int start_offset = __ offset();
3425 
3426     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
3427 #if 0
3428     int vtable_index = this-&gt;_vtable_index;
3429     if (_vtable_index &lt; 0) {
3430       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
3431       assert(_vtable_index == Method::invalid_vtable_index, "correct sentinel value");
3432       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
3433 
3434       // Virtual call relocation will point to ic load.
3435       address virtual_call_meta_addr = __ pc();
3436       // Load a clear inline cache.
3437       AddressLiteral empty_ic((address) Universe::non_oop_word());
3438       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
3439       if (!success) {
3440         ciEnv::current()-&gt;record_out_of_memory_failure();
3441         return;
3442       }
3443       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
3444       // to determine who we intended to call.
3445       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
3446       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
3447       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
3448              "Fix constant in ret_addr_offset()");
3449     } else {
3450       assert(!UseInlineCaches, "expect vtable calls only if not using ICs");
3451       // Go thru the vtable. Get receiver klass. Receiver already
3452       // checked for non-null. If we'll go thru a C2I adapter, the
3453       // interpreter expects method in R19_method.
3454 
3455       __ load_klass(R11_scratch1, R3);
3456 
3457       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
3458       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
3459       __ li(R19_method, v_off);
3460       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
3461       // NOTE: for vtable dispatches, the vtable entry will never be
3462       // null. However it may very well end up in handle_wrong_method
3463       // if the method is abstract for the particular class.
3464       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
3465       // Call target. Either compiled code or C2I adapter.
3466       __ mtctr(R11_scratch1);
3467       __ bctrl();
3468       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
3469         tty-&gt;print(" %d, %d\n", ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
3470       }
3471       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
3472              "Fix constant in ret_addr_offset()");
3473     }
3474 #endif
3475     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
3476   %}
3477 
3478   // a runtime call
3479   enc_class enc_java_to_runtime_call (method meth) %{
3480     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
3481 
3482     MacroAssembler _masm(&amp;cbuf);
3483     const address start_pc = __ pc();
3484 
3485 #if defined(ABI_ELFv2)
3486     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
3487     __ call_c(entry, relocInfo::runtime_call_type);
3488 #else
3489     // The function we're going to call.
3490     FunctionDescriptor fdtemp;
3491     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
3492 
3493     Register Rtoc = R12_scratch2;
3494     // Calculate the method's TOC.
3495     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
3496     // Put entry, env, toc into the constant pool, this needs up to 3 constant
3497     // pool entries; call_c_using_toc will optimize the call.
3498     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
3499     if (!success) {
3500       ciEnv::current()-&gt;record_out_of_memory_failure();
3501       return;
3502     }
3503 #endif
3504 
3505     // Check the ret_addr_offset.
3506     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
3507            "Fix constant in ret_addr_offset()");
3508   %}
3509 
3510   // Move to ctr for leaf call.
3511   // This enc_class is needed so that scheduler gets proper
3512   // input mapping for latency computation.
3513   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
3514     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
3515     MacroAssembler _masm(&amp;cbuf);
3516     __ mtctr($src$$Register);
3517   %}
3518 
3519   // Postalloc expand emitter for runtime leaf calls.
3520   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
3521     loadConLNodesTuple loadConLNodes_Entry;
3522 #if defined(ABI_ELFv2)
3523     jlong entry_address = (jlong) this-&gt;entry_point();
3524     assert(entry_address, "need address here");
3525     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
3526                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
3527 #else
3528     // Get the struct that describes the function we are about to call.
3529     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
3530     assert(fd, "need fd here");
3531     jlong entry_address = (jlong) fd-&gt;entry();
3532     // new nodes
3533     loadConLNodesTuple loadConLNodes_Env;
3534     loadConLNodesTuple loadConLNodes_Toc;
3535 
3536     // Create nodes and operands for loading the entry point.
3537     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
3538                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
3539 
3540 
3541     // Create nodes and operands for loading the env pointer.
3542     if (fd-&gt;env() != NULL) {
3543       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
3544                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
3545     } else {
3546       loadConLNodes_Env._large_hi = NULL;
3547       loadConLNodes_Env._large_lo = NULL;
3548       loadConLNodes_Env._small    = NULL;
3549       loadConLNodes_Env._last = new loadConL16Node();
3550       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
3551       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
3552       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
3553     }
3554 
3555     // Create nodes and operands for loading the Toc point.
3556     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
3557                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
3558 #endif // ABI_ELFv2
3559     // mtctr node
3560     MachNode *mtctr = new CallLeafDirect_mtctrNode();
3561 
3562     assert(loadConLNodes_Entry._last != NULL, "entry must exist");
3563     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
3564 
3565     mtctr-&gt;_opnds[0] = new iRegLdstOper();
3566     mtctr-&gt;_opnds[1] = new iRegLdstOper();
3567 
3568     // call node
3569     MachCallLeafNode *call = new CallLeafDirectNode();
3570 
3571     call-&gt;_opnds[0] = _opnds[0];
3572     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
3573 
3574     // Make the new call node look like the old one.
3575     call-&gt;_name        = _name;
3576     call-&gt;_tf          = _tf;
3577     call-&gt;_entry_point = _entry_point;
3578     call-&gt;_cnt         = _cnt;
3579     call-&gt;_argsize     = _argsize;
3580     call-&gt;_oop_map     = _oop_map;
3581     guarantee(!_jvms, "You must clone the jvms and adapt the offsets by fix_jvms().");
3582     call-&gt;_jvms        = NULL;
3583     call-&gt;_jvmadj      = _jvmadj;
3584     call-&gt;_in_rms      = _in_rms;
3585     call-&gt;_nesting     = _nesting;
3586 
3587 
3588     // New call needs all inputs of old call.
3589     // Req...
3590     for (uint i = 0; i &lt; req(); ++i) {
3591       if (i != mach_constant_base_node_input()) {
3592         call-&gt;add_req(in(i));
3593       }
3594     }
3595 
3596     // These must be reqired edges, as the registers are live up to
3597     // the call. Else the constants are handled as kills.
3598     call-&gt;add_req(mtctr);
3599 #if !defined(ABI_ELFv2)
3600     call-&gt;add_req(loadConLNodes_Env._last);
3601     call-&gt;add_req(loadConLNodes_Toc._last);
3602 #endif
3603 
3604     // ...as well as prec
3605     for (uint i = req(); i &lt; len(); ++i) {
3606       call-&gt;add_prec(in(i));
3607     }
3608 
3609     // registers
3610     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
3611 
3612     // Insert the new nodes.
3613     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
3614     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
3615 #if !defined(ABI_ELFv2)
3616     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
3617     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
3618     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
3619     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
3620 #endif
3621     nodes-&gt;push(mtctr);
3622     nodes-&gt;push(call);
3623   %}
3624 %}
3625 
3626 //----------FRAME--------------------------------------------------------------
3627 // Definition of frame structure and management information.
3628 
3629 frame %{
3630   // What direction does stack grow in (assumed to be same for native &amp; Java).
3631   stack_direction(TOWARDS_LOW);
3632 
3633   // These two registers define part of the calling convention between
3634   // compiled code and the interpreter.
3635 
3636   // Inline Cache Register or method for I2C.
3637   inline_cache_reg(R19); // R19_method
3638 
3639   // Method Oop Register when calling interpreter.
3640   interpreter_method_oop_reg(R19); // R19_method
3641 
3642   // Optional: name the operand used by cisc-spilling to access
3643   // [stack_pointer + offset].
3644   cisc_spilling_operand_name(indOffset);
3645 
3646   // Number of stack slots consumed by a Monitor enter.
3647   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
3648 
3649   // Compiled code's Frame Pointer.
3650   frame_pointer(R1); // R1_SP
3651 
3652   // Interpreter stores its frame pointer in a register which is
3653   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
3654   // interpreted java to compiled java.
3655   //
3656   // R14_state holds pointer to caller's cInterpreter.
3657   interpreter_frame_pointer(R14); // R14_state
3658 
3659   stack_alignment(frame::alignment_in_bytes);
3660 
3661   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
3662 
3663   // Number of outgoing stack slots killed above the
3664   // out_preserve_stack_slots for calls to C. Supports the var-args
3665   // backing area for register parms.
3666   //
3667   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
3668 
3669   // The after-PROLOG location of the return address. Location of
3670   // return address specifies a type (REG or STACK) and a number
3671   // representing the register number (i.e. - use a register name) or
3672   // stack slot.
3673   //
3674   // A: Link register is stored in stack slot ...
3675   // M:  ... but it's in the caller's frame according to PPC-64 ABI.
3676   // J: Therefore, we make sure that the link register is also in R11_scratch1
3677   //    at the end of the prolog.
3678   // B: We use R20, now.
3679   //return_addr(REG R20);
3680 
3681   // G: After reading the comments made by all the luminaries on their
3682   //    failure to tell the compiler where the return address really is,
3683   //    I hardly dare to try myself.  However, I'm convinced it's in slot
3684   //    4 what apparently works and saves us some spills.
3685   return_addr(STACK 4);
3686 
3687   // This is the body of the function
3688   //
3689   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
3690   //                                  uint length,      // length of array
3691   //                                  bool is_outgoing)
3692   //
3693   // The `sig' array is to be updated. sig[j] represents the location
3694   // of the j-th argument, either a register or a stack slot.
3695 
3696   // Comment taken from i486.ad:
3697   // Body of function which returns an integer array locating
3698   // arguments either in registers or in stack slots. Passed an array
3699   // of ideal registers called "sig" and a "length" count. Stack-slot
3700   // offsets are based on outgoing arguments, i.e. a CALLER setting up
3701   // arguments for a CALLEE. Incoming stack arguments are
3702   // automatically biased by the preserve_stack_slots field above.
3703   calling_convention %{
3704     // No difference between ingoing/outgoing. Just pass false.
3705     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
3706   %}
3707 
3708   // Comment taken from i486.ad:
3709   // Body of function which returns an integer array locating
3710   // arguments either in registers or in stack slots. Passed an array
3711   // of ideal registers called "sig" and a "length" count. Stack-slot
3712   // offsets are based on outgoing arguments, i.e. a CALLER setting up
3713   // arguments for a CALLEE. Incoming stack arguments are
3714   // automatically biased by the preserve_stack_slots field above.
3715   c_calling_convention %{
3716     // This is obviously always outgoing.
3717     // C argument in register AND stack slot.
3718     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
3719   %}
3720 
3721   // Location of native (C/C++) and interpreter return values. This
3722   // is specified to be the same as Java. In the 32-bit VM, long
3723   // values are actually returned from native calls in O0:O1 and
3724   // returned to the interpreter in I0:I1. The copying to and from
3725   // the register pairs is done by the appropriate call and epilog
3726   // opcodes. This simplifies the register allocator.
3727   c_return_value %{
3728     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
3729             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),
3730             "only return normal values");
3731     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
3732     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
3733     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
3734     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
3735   %}
3736 
3737   // Location of compiled Java return values.  Same as C
3738   return_value %{
3739     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
3740             (ideal_reg == Op_RegN &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0),
3741             "only return normal values");
3742     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
3743     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
3744     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
3745     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
3746   %}
3747 %}
3748 
3749 
3750 //----------ATTRIBUTES---------------------------------------------------------
3751 
3752 //----------Operand Attributes-------------------------------------------------
3753 op_attrib op_cost(1);          // Required cost attribute.
3754 
3755 //----------Instruction Attributes---------------------------------------------
3756 
3757 // Cost attribute. required.
3758 ins_attrib ins_cost(DEFAULT_COST);
3759 
3760 // Is this instruction a non-matching short branch variant of some
3761 // long branch? Not required.
3762 ins_attrib ins_short_branch(0);
3763 
3764 ins_attrib ins_is_TrapBasedCheckNode(true);
3765 
3766 // Number of constants.
3767 // This instruction uses the given number of constants
3768 // (optional attribute).
3769 // This is needed to determine in time whether the constant pool will
3770 // exceed 4000 entries. Before postalloc_expand the overall number of constants
3771 // is determined. It's also used to compute the constant pool size
3772 // in Output().
3773 ins_attrib ins_num_consts(0);
3774 
3775 // Required alignment attribute (must be a power of 2) specifies the
3776 // alignment that some part of the instruction (not necessarily the
3777 // start) requires. If &gt; 1, a compute_padding() function must be
3778 // provided for the instruction.
3779 ins_attrib ins_alignment(1);
3780 
3781 // Enforce/prohibit rematerializations.
3782 // - If an instruction is attributed with 'ins_cannot_rematerialize(true)'
3783 //   then rematerialization of that instruction is prohibited and the
3784 //   instruction's value will be spilled if necessary.
3785 //   Causes that MachNode::rematerialize() returns false.
3786 // - If an instruction is attributed with 'ins_should_rematerialize(true)'
3787 //   then rematerialization should be enforced and a copy of the instruction
3788 //   should be inserted if possible; rematerialization is not guaranteed.
3789 //   Note: this may result in rematerializations in front of every use.
3790 //   Causes that MachNode::rematerialize() can return true.
3791 // (optional attribute)
3792 ins_attrib ins_cannot_rematerialize(false);
3793 ins_attrib ins_should_rematerialize(false);
3794 
3795 // Instruction has variable size depending on alignment.
3796 ins_attrib ins_variable_size_depending_on_alignment(false);
3797 
3798 // Instruction is a nop.
3799 ins_attrib ins_is_nop(false);
3800 
3801 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
3802 ins_attrib ins_use_mach_if_fast_lock_node(false);
3803 
3804 // Field for the toc offset of a constant.
3805 //
3806 // This is needed if the toc offset is not encodable as an immediate in
3807 // the PPC load instruction. If so, the upper (hi) bits of the offset are
3808 // added to the toc, and from this a load with immediate is performed.
3809 // With postalloc expand, we get two nodes that require the same offset
3810 // but which don't know about each other. The offset is only known
3811 // when the constant is added to the constant pool during emitting.
3812 // It is generated in the 'hi'-node adding the upper bits, and saved
3813 // in this node.  The 'lo'-node has a link to the 'hi'-node and reads
3814 // the offset from there when it gets encoded.
3815 ins_attrib ins_field_const_toc_offset(0);
3816 ins_attrib ins_field_const_toc_offset_hi_node(0);
3817 
3818 // A field that can hold the instructions offset in the code buffer.
3819 // Set in the nodes emitter.
3820 ins_attrib ins_field_cbuf_insts_offset(-1);
3821 
3822 // Fields for referencing a call's load-IC-node.
3823 // If the toc offset can not be encoded as an immediate in a load, we
3824 // use two nodes.
3825 ins_attrib ins_field_load_ic_hi_node(0);
3826 ins_attrib ins_field_load_ic_node(0);
3827 
3828 //----------OPERANDS-----------------------------------------------------------
3829 // Operand definitions must precede instruction definitions for correct
3830 // parsing in the ADLC because operands constitute user defined types
3831 // which are used in instruction definitions.
3832 //
3833 // Formats are generated automatically for constants and base registers.
3834 
3835 //----------Simple Operands----------------------------------------------------
3836 // Immediate Operands
3837 
3838 // Integer Immediate: 32-bit
3839 operand immI() %{
3840   match(ConI);
3841   op_cost(40);
3842   format %{ %}
3843   interface(CONST_INTER);
3844 %}
3845 
3846 operand immI8() %{
3847   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
3848   op_cost(0);
3849   match(ConI);
3850   format %{ %}
3851   interface(CONST_INTER);
3852 %}
3853 
3854 // Integer Immediate: 16-bit
3855 operand immI16() %{
3856   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
3857   op_cost(0);
3858   match(ConI);
3859   format %{ %}
3860   interface(CONST_INTER);
3861 %}
3862 
3863 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
3864 operand immIhi16() %{
3865   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
3866   match(ConI);
3867   op_cost(0);
3868   format %{ %}
3869   interface(CONST_INTER);
3870 %}
3871 
3872 operand immInegpow2() %{
3873   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));
3874   match(ConI);
3875   op_cost(0);
3876   format %{ %}
3877   interface(CONST_INTER);
3878 %}
3879 
3880 operand immIpow2minus1() %{
3881   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));
3882   match(ConI);
3883   op_cost(0);
3884   format %{ %}
3885   interface(CONST_INTER);
3886 %}
3887 
3888 operand immIpowerOf2() %{
3889   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));
3890   match(ConI);
3891   op_cost(0);
3892   format %{ %}
3893   interface(CONST_INTER);
3894 %}
3895 
3896 // Unsigned Integer Immediate: the values 0-31
3897 operand uimmI5() %{
3898   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
3899   match(ConI);
3900   op_cost(0);
3901   format %{ %}
3902   interface(CONST_INTER);
3903 %}
3904 
3905 // Unsigned Integer Immediate: 6-bit
3906 operand uimmI6() %{
3907   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
3908   match(ConI);
3909   op_cost(0);
3910   format %{ %}
3911   interface(CONST_INTER);
3912 %}
3913 
3914 // Unsigned Integer Immediate:  6-bit int, greater than 32
3915 operand uimmI6_ge32() %{
3916   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
3917   match(ConI);
3918   op_cost(0);
3919   format %{ %}
3920   interface(CONST_INTER);
3921 %}
3922 
3923 // Unsigned Integer Immediate: 15-bit
3924 operand uimmI15() %{
3925   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
3926   match(ConI);
3927   op_cost(0);
3928   format %{ %}
3929   interface(CONST_INTER);
3930 %}
3931 
3932 // Unsigned Integer Immediate: 16-bit
3933 operand uimmI16() %{
3934   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
3935   match(ConI);
3936   op_cost(0);
3937   format %{ %}
3938   interface(CONST_INTER);
3939 %}
3940 
3941 // constant 'int 0'.
3942 operand immI_0() %{
3943   predicate(n-&gt;get_int() == 0);
3944   match(ConI);
3945   op_cost(0);
3946   format %{ %}
3947   interface(CONST_INTER);
3948 %}
3949 
3950 // constant 'int 1'.
3951 operand immI_1() %{
3952   predicate(n-&gt;get_int() == 1);
3953   match(ConI);
3954   op_cost(0);
3955   format %{ %}
3956   interface(CONST_INTER);
3957 %}
3958 
3959 // constant 'int -1'.
3960 operand immI_minus1() %{
3961   predicate(n-&gt;get_int() == -1);
3962   match(ConI);
3963   op_cost(0);
3964   format %{ %}
3965   interface(CONST_INTER);
3966 %}
3967 
3968 // int value 16.
3969 operand immI_16() %{
3970   predicate(n-&gt;get_int() == 16);
3971   match(ConI);
3972   op_cost(0);
3973   format %{ %}
3974   interface(CONST_INTER);
3975 %}
3976 
3977 // int value 24.
3978 operand immI_24() %{
3979   predicate(n-&gt;get_int() == 24);
3980   match(ConI);
3981   op_cost(0);
3982   format %{ %}
3983   interface(CONST_INTER);
3984 %}
3985 
3986 // Compressed oops constants
3987 // Pointer Immediate
3988 operand immN() %{
3989   match(ConN);
3990 
3991   op_cost(10);
3992   format %{ %}
3993   interface(CONST_INTER);
3994 %}
3995 
3996 // NULL Pointer Immediate
3997 operand immN_0() %{
3998   predicate(n-&gt;get_narrowcon() == 0);
3999   match(ConN);
4000 
4001   op_cost(0);
4002   format %{ %}
4003   interface(CONST_INTER);
4004 %}
4005 
4006 // Compressed klass constants
4007 operand immNKlass() %{
4008   match(ConNKlass);
4009 
4010   op_cost(0);
4011   format %{ %}
4012   interface(CONST_INTER);
4013 %}
4014 
4015 // This operand can be used to avoid matching of an instruct
4016 // with chain rule.
4017 operand immNKlass_NM() %{
4018   match(ConNKlass);
4019   predicate(false);
4020   op_cost(0);
4021   format %{ %}
4022   interface(CONST_INTER);
4023 %}
4024 
4025 // Pointer Immediate: 64-bit
4026 operand immP() %{
4027   match(ConP);
4028   op_cost(0);
4029   format %{ %}
4030   interface(CONST_INTER);
4031 %}
4032 
4033 // Operand to avoid match of loadConP.
4034 // This operand can be used to avoid matching of an instruct
4035 // with chain rule.
4036 operand immP_NM() %{
4037   match(ConP);
4038   predicate(false);
4039   op_cost(0);
4040   format %{ %}
4041   interface(CONST_INTER);
4042 %}
4043 
4044 // costant 'pointer 0'.
4045 operand immP_0() %{
4046   predicate(n-&gt;get_ptr() == 0);
4047   match(ConP);
4048   op_cost(0);
4049   format %{ %}
4050   interface(CONST_INTER);
4051 %}
4052 
4053 // pointer 0x0 or 0x1
4054 operand immP_0or1() %{
4055   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
4056   match(ConP);
4057   op_cost(0);
4058   format %{ %}
4059   interface(CONST_INTER);
4060 %}
4061 
4062 operand immL() %{
4063   match(ConL);
4064   op_cost(40);
4065   format %{ %}
4066   interface(CONST_INTER);
4067 %}
4068 
4069 // Long Immediate: 16-bit
4070 operand immL16() %{
4071   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
4072   match(ConL);
4073   op_cost(0);
4074   format %{ %}
4075   interface(CONST_INTER);
4076 %}
4077 
4078 // Long Immediate: 16-bit, 4-aligned
4079 operand immL16Alg4() %{
4080   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
4081   match(ConL);
4082   op_cost(0);
4083   format %{ %}
4084   interface(CONST_INTER);
4085 %}
4086 
4087 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
4088 operand immL32hi16() %{
4089   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
4090   match(ConL);
4091   op_cost(0);
4092   format %{ %}
4093   interface(CONST_INTER);
4094 %}
4095 
4096 // Long Immediate: 32-bit
4097 operand immL32() %{
4098   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
4099   match(ConL);
4100   op_cost(0);
4101   format %{ %}
4102   interface(CONST_INTER);
4103 %}
4104 
4105 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
4106 operand immLhighest16() %{
4107   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
4108   match(ConL);
4109   op_cost(0);
4110   format %{ %}
4111   interface(CONST_INTER);
4112 %}
4113 
4114 operand immLnegpow2() %{
4115   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));
4116   match(ConL);
4117   op_cost(0);
4118   format %{ %}
4119   interface(CONST_INTER);
4120 %}
4121 
4122 operand immLpow2minus1() %{
4123   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;
4124             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
4125   match(ConL);
4126   op_cost(0);
4127   format %{ %}
4128   interface(CONST_INTER);
4129 %}
4130 
4131 // constant 'long 0'.
4132 operand immL_0() %{
4133   predicate(n-&gt;get_long() == 0L);
4134   match(ConL);
4135   op_cost(0);
4136   format %{ %}
4137   interface(CONST_INTER);
4138 %}
4139 
4140 // constat ' long -1'.
4141 operand immL_minus1() %{
4142   predicate(n-&gt;get_long() == -1L);
4143   match(ConL);
4144   op_cost(0);
4145   format %{ %}
4146   interface(CONST_INTER);
4147 %}
4148 
4149 // Long Immediate: low 32-bit mask
4150 operand immL_32bits() %{
4151   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
4152   match(ConL);
4153   op_cost(0);
4154   format %{ %}
4155   interface(CONST_INTER);
4156 %}
4157 
4158 // Unsigned Long Immediate: 16-bit
4159 operand uimmL16() %{
4160   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
4161   match(ConL);
4162   op_cost(0);
4163   format %{ %}
4164   interface(CONST_INTER);
4165 %}
4166 
4167 // Float Immediate
4168 operand immF() %{
4169   match(ConF);
4170   op_cost(40);
4171   format %{ %}
4172   interface(CONST_INTER);
4173 %}
4174 
4175 // Float Immediate: +0.0f.
4176 operand immF_0() %{
4177   predicate(jint_cast(n-&gt;getf()) == 0);
4178   match(ConF);
4179 
4180   op_cost(0);
4181   format %{ %}
4182   interface(CONST_INTER);
4183 %}
4184 
4185 // Double Immediate
4186 operand immD() %{
4187   match(ConD);
4188   op_cost(40);
4189   format %{ %}
4190   interface(CONST_INTER);
4191 %}
4192 
4193 // Integer Register Operands
4194 // Integer Destination Register
4195 // See definition of reg_class bits32_reg_rw.
4196 operand iRegIdst() %{
4197   constraint(ALLOC_IN_RC(bits32_reg_rw));
4198   match(RegI);
4199   match(rscratch1RegI);
4200   match(rscratch2RegI);
4201   match(rarg1RegI);
4202   match(rarg2RegI);
4203   match(rarg3RegI);
4204   match(rarg4RegI);
4205   format %{ %}
4206   interface(REG_INTER);
4207 %}
4208 
4209 // Integer Source Register
4210 // See definition of reg_class bits32_reg_ro.
4211 operand iRegIsrc() %{
4212   constraint(ALLOC_IN_RC(bits32_reg_ro));
4213   match(RegI);
4214   match(rscratch1RegI);
4215   match(rscratch2RegI);
4216   match(rarg1RegI);
4217   match(rarg2RegI);
4218   match(rarg3RegI);
4219   match(rarg4RegI);
4220   format %{ %}
4221   interface(REG_INTER);
4222 %}
4223 
4224 operand rscratch1RegI() %{
4225   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
4226   match(iRegIdst);
4227   format %{ %}
4228   interface(REG_INTER);
4229 %}
4230 
4231 operand rscratch2RegI() %{
4232   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
4233   match(iRegIdst);
4234   format %{ %}
4235   interface(REG_INTER);
4236 %}
4237 
4238 operand rarg1RegI() %{
4239   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
4240   match(iRegIdst);
4241   format %{ %}
4242   interface(REG_INTER);
4243 %}
4244 
4245 operand rarg2RegI() %{
4246   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
4247   match(iRegIdst);
4248   format %{ %}
4249   interface(REG_INTER);
4250 %}
4251 
4252 operand rarg3RegI() %{
4253   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
4254   match(iRegIdst);
4255   format %{ %}
4256   interface(REG_INTER);
4257 %}
4258 
4259 operand rarg4RegI() %{
4260   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
4261   match(iRegIdst);
4262   format %{ %}
4263   interface(REG_INTER);
4264 %}
4265 
4266 operand rarg1RegL() %{
4267   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
4268   match(iRegLdst);
4269   format %{ %}
4270   interface(REG_INTER);
4271 %}
4272 
4273 operand rarg2RegL() %{
4274   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
4275   match(iRegLdst);
4276   format %{ %}
4277   interface(REG_INTER);
4278 %}
4279 
4280 operand rarg3RegL() %{
4281   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
4282   match(iRegLdst);
4283   format %{ %}
4284   interface(REG_INTER);
4285 %}
4286 
4287 operand rarg4RegL() %{
4288   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
4289   match(iRegLdst);
4290   format %{ %}
4291   interface(REG_INTER);
4292 %}
4293 
4294 // Pointer Destination Register
4295 // See definition of reg_class bits64_reg_rw.
4296 operand iRegPdst() %{
4297   constraint(ALLOC_IN_RC(bits64_reg_rw));
4298   match(RegP);
4299   match(rscratch1RegP);
4300   match(rscratch2RegP);
4301   match(rarg1RegP);
4302   match(rarg2RegP);
4303   match(rarg3RegP);
4304   match(rarg4RegP);
4305   format %{ %}
4306   interface(REG_INTER);
4307 %}
4308 
4309 // Pointer Destination Register
4310 // Operand not using r11 and r12 (killed in epilog).
4311 operand iRegPdstNoScratch() %{
4312   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
4313   match(RegP);
4314   match(rarg1RegP);
4315   match(rarg2RegP);
4316   match(rarg3RegP);
4317   match(rarg4RegP);
4318   format %{ %}
4319   interface(REG_INTER);
4320 %}
4321 
4322 // Pointer Source Register
4323 // See definition of reg_class bits64_reg_ro.
4324 operand iRegPsrc() %{
4325   constraint(ALLOC_IN_RC(bits64_reg_ro));
4326   match(RegP);
4327   match(iRegPdst);
4328   match(rscratch1RegP);
4329   match(rscratch2RegP);
4330   match(rarg1RegP);
4331   match(rarg2RegP);
4332   match(rarg3RegP);
4333   match(rarg4RegP);
4334   match(threadRegP);
4335   format %{ %}
4336   interface(REG_INTER);
4337 %}
4338 
4339 // Thread operand.
4340 operand threadRegP() %{
4341   constraint(ALLOC_IN_RC(thread_bits64_reg));
4342   match(iRegPdst);
4343   format %{ "R16" %}
4344   interface(REG_INTER);
4345 %}
4346 
4347 operand rscratch1RegP() %{
4348   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
4349   match(iRegPdst);
4350   format %{ "R11" %}
4351   interface(REG_INTER);
4352 %}
4353 
4354 operand rscratch2RegP() %{
4355   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
4356   match(iRegPdst);
4357   format %{ %}
4358   interface(REG_INTER);
4359 %}
4360 
4361 operand rarg1RegP() %{
4362   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
4363   match(iRegPdst);
4364   format %{ %}
4365   interface(REG_INTER);
4366 %}
4367 
4368 operand rarg2RegP() %{
4369   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
4370   match(iRegPdst);
4371   format %{ %}
4372   interface(REG_INTER);
4373 %}
4374 
4375 operand rarg3RegP() %{
4376   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
4377   match(iRegPdst);
4378   format %{ %}
4379   interface(REG_INTER);
4380 %}
4381 
4382 operand rarg4RegP() %{
4383   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
4384   match(iRegPdst);
4385   format %{ %}
4386   interface(REG_INTER);
4387 %}
4388 
4389 operand iRegNsrc() %{
4390   constraint(ALLOC_IN_RC(bits32_reg_ro));
4391   match(RegN);
4392   match(iRegNdst);
4393 
4394   format %{ %}
4395   interface(REG_INTER);
4396 %}
4397 
4398 operand iRegNdst() %{
4399   constraint(ALLOC_IN_RC(bits32_reg_rw));
4400   match(RegN);
4401 
4402   format %{ %}
4403   interface(REG_INTER);
4404 %}
4405 
4406 // Long Destination Register
4407 // See definition of reg_class bits64_reg_rw.
4408 operand iRegLdst() %{
4409   constraint(ALLOC_IN_RC(bits64_reg_rw));
4410   match(RegL);
4411   match(rscratch1RegL);
4412   match(rscratch2RegL);
4413   format %{ %}
4414   interface(REG_INTER);
4415 %}
4416 
4417 // Long Source Register
4418 // See definition of reg_class bits64_reg_ro.
4419 operand iRegLsrc() %{
4420   constraint(ALLOC_IN_RC(bits64_reg_ro));
4421   match(RegL);
4422   match(iRegLdst);
4423   match(rscratch1RegL);
4424   match(rscratch2RegL);
4425   format %{ %}
4426   interface(REG_INTER);
4427 %}
4428 
4429 // Special operand for ConvL2I.
4430 operand iRegL2Isrc(iRegLsrc reg) %{
4431   constraint(ALLOC_IN_RC(bits64_reg_ro));
4432   match(ConvL2I reg);
4433   format %{ "ConvL2I($reg)" %}
4434   interface(REG_INTER)
4435 %}
4436 
4437 operand rscratch1RegL() %{
4438   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
4439   match(RegL);
4440   format %{ %}
4441   interface(REG_INTER);
4442 %}
4443 
4444 operand rscratch2RegL() %{
4445   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
4446   match(RegL);
4447   format %{ %}
4448   interface(REG_INTER);
4449 %}
4450 
4451 // Condition Code Flag Registers
4452 operand flagsReg() %{
4453   constraint(ALLOC_IN_RC(int_flags));
4454   match(RegFlags);
4455   format %{ %}
4456   interface(REG_INTER);
4457 %}
4458 
4459 operand flagsRegSrc() %{
4460   constraint(ALLOC_IN_RC(int_flags_ro));
4461   match(RegFlags);
4462   match(flagsReg);
4463   match(flagsRegCR0);
4464   format %{ %}
4465   interface(REG_INTER);
4466 %}
4467 
4468 // Condition Code Flag Register CR0
4469 operand flagsRegCR0() %{
4470   constraint(ALLOC_IN_RC(int_flags_CR0));
4471   match(RegFlags);
4472   format %{ "CR0" %}
4473   interface(REG_INTER);
4474 %}
4475 
4476 operand flagsRegCR1() %{
4477   constraint(ALLOC_IN_RC(int_flags_CR1));
4478   match(RegFlags);
4479   format %{ "CR1" %}
4480   interface(REG_INTER);
4481 %}
4482 
4483 operand flagsRegCR6() %{
4484   constraint(ALLOC_IN_RC(int_flags_CR6));
4485   match(RegFlags);
4486   format %{ "CR6" %}
4487   interface(REG_INTER);
4488 %}
4489 
4490 operand regCTR() %{
4491   constraint(ALLOC_IN_RC(ctr_reg));
4492   // RegFlags should work. Introducing a RegSpecial type would cause a
4493   // lot of changes.
4494   match(RegFlags);
4495   format %{"SR_CTR" %}
4496   interface(REG_INTER);
4497 %}
4498 
4499 operand regD() %{
4500   constraint(ALLOC_IN_RC(dbl_reg));
4501   match(RegD);
4502   format %{ %}
4503   interface(REG_INTER);
4504 %}
4505 
4506 operand regF() %{
4507   constraint(ALLOC_IN_RC(flt_reg));
4508   match(RegF);
4509   format %{ %}
4510   interface(REG_INTER);
4511 %}
4512 
4513 // Special Registers
4514 
4515 // Method Register
4516 operand inline_cache_regP(iRegPdst reg) %{
4517   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
4518   match(reg);
4519   format %{ %}
4520   interface(REG_INTER);
4521 %}
4522 
4523 operand compiler_method_oop_regP(iRegPdst reg) %{
4524   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
4525   match(reg);
4526   format %{ %}
4527   interface(REG_INTER);
4528 %}
4529 
4530 operand interpreter_method_oop_regP(iRegPdst reg) %{
4531   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
4532   match(reg);
4533   format %{ %}
4534   interface(REG_INTER);
4535 %}
4536 
4537 // Operands to remove register moves in unscaled mode.
4538 // Match read/write registers with an EncodeP node if neither shift nor add are required.
4539 operand iRegP2N(iRegPsrc reg) %{
4540   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; Universe::narrow_oop_shift() == 0);
4541   constraint(ALLOC_IN_RC(bits64_reg_ro));
4542   match(EncodeP reg);
4543   format %{ "$reg" %}
4544   interface(REG_INTER)
4545 %}
4546 
4547 operand iRegN2P(iRegNsrc reg) %{
4548   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4549   constraint(ALLOC_IN_RC(bits32_reg_ro));
4550   match(DecodeN reg);
4551   format %{ "$reg" %}
4552   interface(REG_INTER)
4553 %}
4554 
4555 operand iRegN2P_klass(iRegNsrc reg) %{
4556   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4557   constraint(ALLOC_IN_RC(bits32_reg_ro));
4558   match(DecodeNKlass reg);
4559   format %{ "$reg" %}
4560   interface(REG_INTER)
4561 %}
4562 
4563 //----------Complex Operands---------------------------------------------------
4564 // Indirect Memory Reference
4565 operand indirect(iRegPsrc reg) %{
4566   constraint(ALLOC_IN_RC(bits64_reg_ro));
4567   match(reg);
4568   op_cost(100);
4569   format %{ "[$reg]" %}
4570   interface(MEMORY_INTER) %{
4571     base($reg);
4572     index(0x0);
4573     scale(0x0);
4574     disp(0x0);
4575   %}
4576 %}
4577 
4578 // Indirect with Offset
4579 operand indOffset16(iRegPsrc reg, immL16 offset) %{
4580   constraint(ALLOC_IN_RC(bits64_reg_ro));
4581   match(AddP reg offset);
4582   op_cost(100);
4583   format %{ "[$reg + $offset]" %}
4584   interface(MEMORY_INTER) %{
4585     base($reg);
4586     index(0x0);
4587     scale(0x0);
4588     disp($offset);
4589   %}
4590 %}
4591 
4592 // Indirect with 4-aligned Offset
4593 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
4594   constraint(ALLOC_IN_RC(bits64_reg_ro));
4595   match(AddP reg offset);
4596   op_cost(100);
4597   format %{ "[$reg + $offset]" %}
4598   interface(MEMORY_INTER) %{
4599     base($reg);
4600     index(0x0);
4601     scale(0x0);
4602     disp($offset);
4603   %}
4604 %}
4605 
4606 //----------Complex Operands for Compressed OOPs-------------------------------
4607 // Compressed OOPs with narrow_oop_shift == 0.
4608 
4609 // Indirect Memory Reference, compressed OOP
4610 operand indirectNarrow(iRegNsrc reg) %{
4611   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4612   constraint(ALLOC_IN_RC(bits64_reg_ro));
4613   match(DecodeN reg);
4614   op_cost(100);
4615   format %{ "[$reg]" %}
4616   interface(MEMORY_INTER) %{
4617     base($reg);
4618     index(0x0);
4619     scale(0x0);
4620     disp(0x0);
4621   %}
4622 %}
4623 
4624 operand indirectNarrow_klass(iRegNsrc reg) %{
4625   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4626   constraint(ALLOC_IN_RC(bits64_reg_ro));
4627   match(DecodeNKlass reg);
4628   op_cost(100);
4629   format %{ "[$reg]" %}
4630   interface(MEMORY_INTER) %{
4631     base($reg);
4632     index(0x0);
4633     scale(0x0);
4634     disp(0x0);
4635   %}
4636 %}
4637 
4638 // Indirect with Offset, compressed OOP
4639 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
4640   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4641   constraint(ALLOC_IN_RC(bits64_reg_ro));
4642   match(AddP (DecodeN reg) offset);
4643   op_cost(100);
4644   format %{ "[$reg + $offset]" %}
4645   interface(MEMORY_INTER) %{
4646     base($reg);
4647     index(0x0);
4648     scale(0x0);
4649     disp($offset);
4650   %}
4651 %}
4652 
4653 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
4654   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4655   constraint(ALLOC_IN_RC(bits64_reg_ro));
4656   match(AddP (DecodeNKlass reg) offset);
4657   op_cost(100);
4658   format %{ "[$reg + $offset]" %}
4659   interface(MEMORY_INTER) %{
4660     base($reg);
4661     index(0x0);
4662     scale(0x0);
4663     disp($offset);
4664   %}
4665 %}
4666 
4667 // Indirect with 4-aligned Offset, compressed OOP
4668 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
4669   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
4670   constraint(ALLOC_IN_RC(bits64_reg_ro));
4671   match(AddP (DecodeN reg) offset);
4672   op_cost(100);
4673   format %{ "[$reg + $offset]" %}
4674   interface(MEMORY_INTER) %{
4675     base($reg);
4676     index(0x0);
4677     scale(0x0);
4678     disp($offset);
4679   %}
4680 %}
4681 
4682 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
4683   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0);
4684   constraint(ALLOC_IN_RC(bits64_reg_ro));
4685   match(AddP (DecodeNKlass reg) offset);
4686   op_cost(100);
4687   format %{ "[$reg + $offset]" %}
4688   interface(MEMORY_INTER) %{
4689     base($reg);
4690     index(0x0);
4691     scale(0x0);
4692     disp($offset);
4693   %}
4694 %}
4695 
4696 //----------Special Memory Operands--------------------------------------------
4697 // Stack Slot Operand
4698 //
4699 // This operand is used for loading and storing temporary values on
4700 // the stack where a match requires a value to flow through memory.
4701 operand stackSlotI(sRegI reg) %{
4702   constraint(ALLOC_IN_RC(stack_slots));
4703   op_cost(100);
4704   //match(RegI);
4705   format %{ "[sp+$reg]" %}
4706   interface(MEMORY_INTER) %{
4707     base(0x1);   // R1_SP
4708     index(0x0);
4709     scale(0x0);
4710     disp($reg);  // Stack Offset
4711   %}
4712 %}
4713 
4714 operand stackSlotL(sRegL reg) %{
4715   constraint(ALLOC_IN_RC(stack_slots));
4716   op_cost(100);
4717   //match(RegL);
4718   format %{ "[sp+$reg]" %}
4719   interface(MEMORY_INTER) %{
4720     base(0x1);   // R1_SP
4721     index(0x0);
4722     scale(0x0);
4723     disp($reg);  // Stack Offset
4724   %}
4725 %}
4726 
4727 operand stackSlotP(sRegP reg) %{
4728   constraint(ALLOC_IN_RC(stack_slots));
4729   op_cost(100);
4730   //match(RegP);
4731   format %{ "[sp+$reg]" %}
4732   interface(MEMORY_INTER) %{
4733     base(0x1);   // R1_SP
4734     index(0x0);
4735     scale(0x0);
4736     disp($reg);  // Stack Offset
4737   %}
4738 %}
4739 
4740 operand stackSlotF(sRegF reg) %{
4741   constraint(ALLOC_IN_RC(stack_slots));
4742   op_cost(100);
4743   //match(RegF);
4744   format %{ "[sp+$reg]" %}
4745   interface(MEMORY_INTER) %{
4746     base(0x1);   // R1_SP
4747     index(0x0);
4748     scale(0x0);
4749     disp($reg);  // Stack Offset
4750   %}
4751 %}
4752 
4753 operand stackSlotD(sRegD reg) %{
4754   constraint(ALLOC_IN_RC(stack_slots));
4755   op_cost(100);
4756   //match(RegD);
4757   format %{ "[sp+$reg]" %}
4758   interface(MEMORY_INTER) %{
4759     base(0x1);   // R1_SP
4760     index(0x0);
4761     scale(0x0);
4762     disp($reg);  // Stack Offset
4763   %}
4764 %}
4765 
4766 // Operands for expressing Control Flow
4767 // NOTE: Label is a predefined operand which should not be redefined in
4768 //       the AD file. It is generically handled within the ADLC.
4769 
4770 //----------Conditional Branch Operands----------------------------------------
4771 // Comparison Op
4772 //
4773 // This is the operation of the comparison, and is limited to the
4774 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
4775 // (!=).
4776 //
4777 // Other attributes of the comparison, such as unsignedness, are specified
4778 // by the comparison instruction that sets a condition code flags register.
4779 // That result is represented by a flags operand whose subtype is appropriate
4780 // to the unsignedness (etc.) of the comparison.
4781 //
4782 // Later, the instruction which matches both the Comparison Op (a Bool) and
4783 // the flags (produced by the Cmp) specifies the coding of the comparison op
4784 // by matching a specific subtype of Bool operand below.
4785 
4786 // When used for floating point comparisons: unordered same as less.
4787 operand cmpOp() %{
4788   match(Bool);
4789   format %{ "" %}
4790   interface(COND_INTER) %{
4791                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always '100'.
4792                            //           BO          &amp;  BI
4793     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
4794     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
4795     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
4796     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
4797     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
4798     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
4799     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
4800     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
4801   %}
4802 %}
4803 
4804 //----------OPERAND CLASSES----------------------------------------------------
4805 // Operand Classes are groups of operands that are used to simplify
4806 // instruction definitions by not requiring the AD writer to specify
4807 // seperate instructions for every form of operand when the
4808 // instruction accepts multiple operand types with the same basic
4809 // encoding and format. The classic case of this is memory operands.
4810 // Indirect is not included since its use is limited to Compare &amp; Swap.
4811 
4812 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
4813 // Memory operand where offsets are 4-aligned. Required for ld, std.
4814 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
4815 opclass indirectMemory(indirect, indirectNarrow);
4816 
4817 // Special opclass for I and ConvL2I.
4818 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
4819 
4820 // Operand classes to match encode and decode. iRegN_P2N is only used
4821 // for storeN. I have never seen an encode node elsewhere.
4822 opclass iRegN_P2N(iRegNsrc, iRegP2N);
4823 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
4824 
4825 //----------PIPELINE-----------------------------------------------------------
4826 
4827 pipeline %{
4828 
4829 // See J.M.Tendler et al. "Power4 system microarchitecture", IBM
4830 // J. Res. &amp; Dev., No. 1, Jan. 2002.
4831 
4832 //----------ATTRIBUTES---------------------------------------------------------
4833 attributes %{
4834 
4835   // Power4 instructions are of fixed length.
4836   fixed_size_instructions;
4837 
4838   // TODO: if `bundle' means number of instructions fetched
4839   // per cycle, this is 8. If `bundle' means Power4 `group', that is
4840   // max instructions issued per cycle, this is 5.
4841   max_instructions_per_bundle = 8;
4842 
4843   // A Power4 instruction is 4 bytes long.
4844   instruction_unit_size = 4;
4845 
4846   // The Power4 processor fetches 64 bytes...
4847   instruction_fetch_unit_size = 64;
4848 
4849   // ...in one line
4850   instruction_fetch_units = 1
4851 
4852   // Unused, list one so that array generated by adlc is not empty.
4853   // Aix compiler chokes if _nop_count = 0.
4854   nops(fxNop);
4855 %}
4856 
4857 //----------RESOURCES----------------------------------------------------------
4858 // Resources are the functional units available to the machine
4859 resources(
4860    PPC_BR,         // branch unit
4861    PPC_CR,         // condition unit
4862    PPC_FX1,        // integer arithmetic unit 1
4863    PPC_FX2,        // integer arithmetic unit 2
4864    PPC_LDST1,      // load/store unit 1
4865    PPC_LDST2,      // load/store unit 2
4866    PPC_FP1,        // float arithmetic unit 1
4867    PPC_FP2,        // float arithmetic unit 2
4868    PPC_LDST = PPC_LDST1 | PPC_LDST2,
4869    PPC_FX = PPC_FX1 | PPC_FX2,
4870    PPC_FP = PPC_FP1 | PPC_FP2
4871  );
4872 
4873 //----------PIPELINE DESCRIPTION-----------------------------------------------
4874 // Pipeline Description specifies the stages in the machine's pipeline
4875 pipe_desc(
4876    // Power4 longest pipeline path
4877    PPC_IF,   // instruction fetch
4878    PPC_IC,
4879    //PPC_BP, // branch prediction
4880    PPC_D0,   // decode
4881    PPC_D1,   // decode
4882    PPC_D2,   // decode
4883    PPC_D3,   // decode
4884    PPC_Xfer1,
4885    PPC_GD,   // group definition
4886    PPC_MP,   // map
4887    PPC_ISS,  // issue
4888    PPC_RF,   // resource fetch
4889    PPC_EX1,  // execute (all units)
4890    PPC_EX2,  // execute (FP, LDST)
4891    PPC_EX3,  // execute (FP, LDST)
4892    PPC_EX4,  // execute (FP)
4893    PPC_EX5,  // execute (FP)
4894    PPC_EX6,  // execute (FP)
4895    PPC_WB,   // write back
4896    PPC_Xfer2,
4897    PPC_CP
4898  );
4899 
4900 //----------PIPELINE CLASSES---------------------------------------------------
4901 // Pipeline Classes describe the stages in which input and output are
4902 // referenced by the hardware pipeline.
4903 
4904 // Simple pipeline classes.
4905 
4906 // Default pipeline class.
4907 pipe_class pipe_class_default() %{
4908   single_instruction;
4909   fixed_latency(2);
4910 %}
4911 
4912 // Pipeline class for empty instructions.
4913 pipe_class pipe_class_empty() %{
4914   single_instruction;
4915   fixed_latency(0);
4916 %}
4917 
4918 // Pipeline class for compares.
4919 pipe_class pipe_class_compare() %{
4920   single_instruction;
4921   fixed_latency(16);
4922 %}
4923 
4924 // Pipeline class for traps.
4925 pipe_class pipe_class_trap() %{
4926   single_instruction;
4927   fixed_latency(100);
4928 %}
4929 
4930 // Pipeline class for memory operations.
4931 pipe_class pipe_class_memory() %{
4932   single_instruction;
4933   fixed_latency(16);
4934 %}
4935 
4936 // Pipeline class for call.
4937 pipe_class pipe_class_call() %{
4938   single_instruction;
4939   fixed_latency(100);
4940 %}
4941 
4942 // Define the class for the Nop node.
4943 define %{
4944    MachNop = pipe_class_default;
4945 %}
4946 
4947 %}
4948 
4949 //----------INSTRUCTIONS-------------------------------------------------------
4950 
4951 // Naming of instructions:
4952 //   opA_operB / opA_operB_operC:
4953 //     Operation 'op' with one or two source operands 'oper'. Result
4954 //     type is A, source operand types are B and C.
4955 //     Iff A == B == C, B and C are left out.
4956 //
4957 // The instructions are ordered according to the following scheme:
4958 //  - loads
4959 //  - load constants
4960 //  - prefetch
4961 //  - store
4962 //  - encode/decode
4963 //  - membar
4964 //  - conditional moves
4965 //  - compare &amp; swap
4966 //  - arithmetic and logic operations
4967 //    * int: Add, Sub, Mul, Div, Mod
4968 //    * int: lShift, arShift, urShift, rot
4969 //    * float: Add, Sub, Mul, Div
4970 //    * and, or, xor ...
4971 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
4972 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
4973 //  - conv (low level type cast requiring bit changes (sign extend etc)
4974 //  - compares, range &amp; zero checks.
4975 //  - branches
4976 //  - complex operations, intrinsics, min, max, replicate
4977 //  - lock
4978 //  - Calls
4979 //
4980 // If there are similar instructions with different types they are sorted:
4981 // int before float
4982 // small before big
4983 // signed before unsigned
4984 // e.g., loadS before loadUS before loadI before loadF.
4985 
4986 
4987 //----------Load/Store Instructions--------------------------------------------
4988 
4989 //----------Load Instructions--------------------------------------------------
4990 
4991 // Converts byte to int.
4992 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
4993 // reuses the 'amount' operand, but adlc expects that operand specification
4994 // and operands in match rule are equivalent.
4995 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
4996   effect(DEF dst, USE src);
4997   format %{ "EXTSB   $dst, $src \t// byte-&gt;int" %}
4998   size(4);
4999   ins_encode %{
5000     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
5001     __ extsb($dst$$Register, $src$$Register);
5002   %}
5003   ins_pipe(pipe_class_default);
5004 %}
5005 
5006 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
5007   // match-rule, false predicate
5008   match(Set dst (LoadB mem));
5009   predicate(false);
5010 
5011   format %{ "LBZ     $dst, $mem" %}
5012   size(4);
5013   ins_encode( enc_lbz(dst, mem) );
5014   ins_pipe(pipe_class_memory);
5015 %}
5016 
5017 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
5018   // match-rule, false predicate
5019   match(Set dst (LoadB mem));
5020   predicate(false);
5021 
5022   format %{ "LBZ     $dst, $mem\n\t"
5023             "TWI     $dst\n\t"
5024             "ISYNC" %}
5025   size(12);
5026   ins_encode( enc_lbz_ac(dst, mem) );
5027   ins_pipe(pipe_class_memory);
5028 %}
5029 
5030 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
5031 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
5032   match(Set dst (LoadB mem));
5033   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5034   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
5035   expand %{
5036     iRegIdst tmp;
5037     loadUB_indirect(tmp, mem);
5038     convB2I_reg_2(dst, tmp);
5039   %}
5040 %}
5041 
5042 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
5043   match(Set dst (LoadB mem));
5044   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
5045   expand %{
5046     iRegIdst tmp;
5047     loadUB_indirect_ac(tmp, mem);
5048     convB2I_reg_2(dst, tmp);
5049   %}
5050 %}
5051 
5052 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
5053   // match-rule, false predicate
5054   match(Set dst (LoadB mem));
5055   predicate(false);
5056 
5057   format %{ "LBZ     $dst, $mem" %}
5058   size(4);
5059   ins_encode( enc_lbz(dst, mem) );
5060   ins_pipe(pipe_class_memory);
5061 %}
5062 
5063 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
5064   // match-rule, false predicate
5065   match(Set dst (LoadB mem));
5066   predicate(false);
5067 
5068   format %{ "LBZ     $dst, $mem\n\t"
5069             "TWI     $dst\n\t"
5070             "ISYNC" %}
5071   size(12);
5072   ins_encode( enc_lbz_ac(dst, mem) );
5073   ins_pipe(pipe_class_memory);
5074 %}
5075 
5076 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
5077 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
5078   match(Set dst (LoadB mem));
5079   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5080   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
5081 
5082   expand %{
5083     iRegIdst tmp;
5084     loadUB_indOffset16(tmp, mem);
5085     convB2I_reg_2(dst, tmp);
5086   %}
5087 %}
5088 
5089 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
5090   match(Set dst (LoadB mem));
5091   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
5092 
5093   expand %{
5094     iRegIdst tmp;
5095     loadUB_indOffset16_ac(tmp, mem);
5096     convB2I_reg_2(dst, tmp);
5097   %}
5098 %}
5099 
5100 // Load Unsigned Byte (8bit UNsigned) into an int reg.
5101 instruct loadUB(iRegIdst dst, memory mem) %{
5102   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5103   match(Set dst (LoadUB mem));
5104   ins_cost(MEMORY_REF_COST);
5105 
5106   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to int" %}
5107   size(4);
5108   ins_encode( enc_lbz(dst, mem) );
5109   ins_pipe(pipe_class_memory);
5110 %}
5111 
5112 // Load  Unsigned Byte (8bit UNsigned) acquire.
5113 instruct loadUB_ac(iRegIdst dst, memory mem) %{
5114   match(Set dst (LoadUB mem));
5115   ins_cost(3*MEMORY_REF_COST);
5116 
5117   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t"
5118             "TWI     $dst\n\t"
5119             "ISYNC" %}
5120   size(12);
5121   ins_encode( enc_lbz_ac(dst, mem) );
5122   ins_pipe(pipe_class_memory);
5123 %}
5124 
5125 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
5126 instruct loadUB2L(iRegLdst dst, memory mem) %{
5127   match(Set dst (ConvI2L (LoadUB mem)));
5128   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
5129   ins_cost(MEMORY_REF_COST);
5130 
5131   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to long" %}
5132   size(4);
5133   ins_encode( enc_lbz(dst, mem) );
5134   ins_pipe(pipe_class_memory);
5135 %}
5136 
5137 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
5138   match(Set dst (ConvI2L (LoadUB mem)));
5139   ins_cost(3*MEMORY_REF_COST);
5140 
5141   format %{ "LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t"
5142             "TWI     $dst\n\t"
5143             "ISYNC" %}
5144   size(12);
5145   ins_encode( enc_lbz_ac(dst, mem) );
5146   ins_pipe(pipe_class_memory);
5147 %}
5148 
5149 // Load Short (16bit signed)
5150 instruct loadS(iRegIdst dst, memory mem) %{
5151   match(Set dst (LoadS mem));
5152   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5153   ins_cost(MEMORY_REF_COST);
5154 
5155   format %{ "LHA     $dst, $mem" %}
5156   size(4);
5157   ins_encode %{
5158     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
5159     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5160     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
5161   %}
5162   ins_pipe(pipe_class_memory);
5163 %}
5164 
5165 // Load Short (16bit signed) acquire.
5166 instruct loadS_ac(iRegIdst dst, memory mem) %{
5167   match(Set dst (LoadS mem));
5168   ins_cost(3*MEMORY_REF_COST);
5169 
5170   format %{ "LHA     $dst, $mem\t acquire\n\t"
5171             "TWI     $dst\n\t"
5172             "ISYNC" %}
5173   size(12);
5174   ins_encode %{
5175     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5176     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5177     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
5178     __ twi_0($dst$$Register);
5179     __ isync();
5180   %}
5181   ins_pipe(pipe_class_memory);
5182 %}
5183 
5184 // Load Char (16bit unsigned)
5185 instruct loadUS(iRegIdst dst, memory mem) %{
5186   match(Set dst (LoadUS mem));
5187   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5188   ins_cost(MEMORY_REF_COST);
5189 
5190   format %{ "LHZ     $dst, $mem" %}
5191   size(4);
5192   ins_encode( enc_lhz(dst, mem) );
5193   ins_pipe(pipe_class_memory);
5194 %}
5195 
5196 // Load Char (16bit unsigned) acquire.
5197 instruct loadUS_ac(iRegIdst dst, memory mem) %{
5198   match(Set dst (LoadUS mem));
5199   ins_cost(3*MEMORY_REF_COST);
5200 
5201   format %{ "LHZ     $dst, $mem \t// acquire\n\t"
5202             "TWI     $dst\n\t"
5203             "ISYNC" %}
5204   size(12);
5205   ins_encode( enc_lhz_ac(dst, mem) );
5206   ins_pipe(pipe_class_memory);
5207 %}
5208 
5209 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
5210 instruct loadUS2L(iRegLdst dst, memory mem) %{
5211   match(Set dst (ConvI2L (LoadUS mem)));
5212   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
5213   ins_cost(MEMORY_REF_COST);
5214 
5215   format %{ "LHZ     $dst, $mem \t// short, zero-extend to long" %}
5216   size(4);
5217   ins_encode( enc_lhz(dst, mem) );
5218   ins_pipe(pipe_class_memory);
5219 %}
5220 
5221 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
5222 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
5223   match(Set dst (ConvI2L (LoadUS mem)));
5224   ins_cost(3*MEMORY_REF_COST);
5225 
5226   format %{ "LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t"
5227             "TWI     $dst\n\t"
5228             "ISYNC" %}
5229   size(12);
5230   ins_encode( enc_lhz_ac(dst, mem) );
5231   ins_pipe(pipe_class_memory);
5232 %}
5233 
5234 // Load Integer.
5235 instruct loadI(iRegIdst dst, memory mem) %{
5236   match(Set dst (LoadI mem));
5237   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5238   ins_cost(MEMORY_REF_COST);
5239 
5240   format %{ "LWZ     $dst, $mem" %}
5241   size(4);
5242   ins_encode( enc_lwz(dst, mem) );
5243   ins_pipe(pipe_class_memory);
5244 %}
5245 
5246 // Load Integer acquire.
5247 instruct loadI_ac(iRegIdst dst, memory mem) %{
5248   match(Set dst (LoadI mem));
5249   ins_cost(3*MEMORY_REF_COST);
5250 
5251   format %{ "LWZ     $dst, $mem \t// load acquire\n\t"
5252             "TWI     $dst\n\t"
5253             "ISYNC" %}
5254   size(12);
5255   ins_encode( enc_lwz_ac(dst, mem) );
5256   ins_pipe(pipe_class_memory);
5257 %}
5258 
5259 // Match loading integer and casting it to unsigned int in
5260 // long register.
5261 // LoadI + ConvI2L + AndL 0xffffffff.
5262 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
5263   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
5264   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5265   ins_cost(MEMORY_REF_COST);
5266 
5267   format %{ "LWZ     $dst, $mem \t// zero-extend to long" %}
5268   size(4);
5269   ins_encode( enc_lwz(dst, mem) );
5270   ins_pipe(pipe_class_memory);
5271 %}
5272 
5273 // Match loading integer and casting it to long.
5274 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
5275   match(Set dst (ConvI2L (LoadI mem)));
5276   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5277   ins_cost(MEMORY_REF_COST);
5278 
5279   format %{ "LWA     $dst, $mem \t// loadI2L" %}
5280   size(4);
5281   ins_encode %{
5282     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
5283     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5284     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
5285   %}
5286   ins_pipe(pipe_class_memory);
5287 %}
5288 
5289 // Match loading integer and casting it to long - acquire.
5290 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
5291   match(Set dst (ConvI2L (LoadI mem)));
5292   ins_cost(3*MEMORY_REF_COST);
5293 
5294   format %{ "LWA     $dst, $mem \t// loadI2L acquire"
5295             "TWI     $dst\n\t"
5296             "ISYNC" %}
5297   size(12);
5298   ins_encode %{
5299     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
5300     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5301     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
5302     __ twi_0($dst$$Register);
5303     __ isync();
5304   %}
5305   ins_pipe(pipe_class_memory);
5306 %}
5307 
5308 // Load Long - aligned
5309 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
5310   match(Set dst (LoadL mem));
5311   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5312   ins_cost(MEMORY_REF_COST);
5313 
5314   format %{ "LD      $dst, $mem \t// long" %}
5315   size(4);
5316   ins_encode( enc_ld(dst, mem) );
5317   ins_pipe(pipe_class_memory);
5318 %}
5319 
5320 // Load Long - aligned acquire.
5321 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
5322   match(Set dst (LoadL mem));
5323   ins_cost(3*MEMORY_REF_COST);
5324 
5325   format %{ "LD      $dst, $mem \t// long acquire\n\t"
5326             "TWI     $dst\n\t"
5327             "ISYNC" %}
5328   size(12);
5329   ins_encode( enc_ld_ac(dst, mem) );
5330   ins_pipe(pipe_class_memory);
5331 %}
5332 
5333 // Load Long - UNaligned
5334 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
5335   match(Set dst (LoadL_unaligned mem));
5336   // predicate(...) // Unaligned_ac is not needed (and wouldn't make sense).
5337   ins_cost(MEMORY_REF_COST);
5338 
5339   format %{ "LD      $dst, $mem \t// unaligned long" %}
5340   size(4);
5341   ins_encode( enc_ld(dst, mem) );
5342   ins_pipe(pipe_class_memory);
5343 %}
5344 
5345 // Load nodes for superwords
5346 
5347 // Load Aligned Packed Byte
5348 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
5349   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
5350   match(Set dst (LoadVector mem));
5351   ins_cost(MEMORY_REF_COST);
5352 
5353   format %{ "LD      $dst, $mem \t// load 8-byte Vector" %}
5354   size(4);
5355   ins_encode( enc_ld(dst, mem) );
5356   ins_pipe(pipe_class_memory);
5357 %}
5358 
5359 // Load Range, range = array length (=jint)
5360 instruct loadRange(iRegIdst dst, memory mem) %{
5361   match(Set dst (LoadRange mem));
5362   ins_cost(MEMORY_REF_COST);
5363 
5364   format %{ "LWZ     $dst, $mem \t// range" %}
5365   size(4);
5366   ins_encode( enc_lwz(dst, mem) );
5367   ins_pipe(pipe_class_memory);
5368 %}
5369 
5370 // Load Compressed Pointer
5371 instruct loadN(iRegNdst dst, memory mem) %{
5372   match(Set dst (LoadN mem));
5373   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5374   ins_cost(MEMORY_REF_COST);
5375 
5376   format %{ "LWZ     $dst, $mem \t// load compressed ptr" %}
5377   size(4);
5378   ins_encode( enc_lwz(dst, mem) );
5379   ins_pipe(pipe_class_memory);
5380 %}
5381 
5382 // Load Compressed Pointer acquire.
5383 instruct loadN_ac(iRegNdst dst, memory mem) %{
5384   match(Set dst (LoadN mem));
5385   ins_cost(3*MEMORY_REF_COST);
5386 
5387   format %{ "LWZ     $dst, $mem \t// load acquire compressed ptr\n\t"
5388             "TWI     $dst\n\t"
5389             "ISYNC" %}
5390   size(12);
5391   ins_encode( enc_lwz_ac(dst, mem) );
5392   ins_pipe(pipe_class_memory);
5393 %}
5394 
5395 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
5396 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
5397   match(Set dst (DecodeN (LoadN mem)));
5398   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; Universe::narrow_oop_shift() == 0);
5399   ins_cost(MEMORY_REF_COST);
5400 
5401   format %{ "LWZ     $dst, $mem \t// DecodeN (unscaled)" %}
5402   size(4);
5403   ins_encode( enc_lwz(dst, mem) );
5404   ins_pipe(pipe_class_memory);
5405 %}
5406 
5407 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
5408   match(Set dst (DecodeNKlass (LoadNKlass mem)));
5409   predicate(Universe::narrow_klass_base() == NULL &amp;&amp; Universe::narrow_klass_shift() == 0 &amp;&amp;
5410             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5411   ins_cost(MEMORY_REF_COST);
5412 
5413   format %{ "LWZ     $dst, $mem \t// DecodeN (unscaled)" %}
5414   size(4);
5415   ins_encode( enc_lwz(dst, mem) );
5416   ins_pipe(pipe_class_memory);
5417 %}
5418 
5419 // Load Pointer
5420 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
5421   match(Set dst (LoadP mem));
5422   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5423   ins_cost(MEMORY_REF_COST);
5424 
5425   format %{ "LD      $dst, $mem \t// ptr" %}
5426   size(4);
5427   ins_encode( enc_ld(dst, mem) );
5428   ins_pipe(pipe_class_memory);
5429 %}
5430 
5431 // Load Pointer acquire.
5432 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
5433   match(Set dst (LoadP mem));
5434   ins_cost(3*MEMORY_REF_COST);
5435 
5436   format %{ "LD      $dst, $mem \t// ptr acquire\n\t"
5437             "TWI     $dst\n\t"
5438             "ISYNC" %}
5439   size(12);
5440   ins_encode( enc_ld_ac(dst, mem) );
5441   ins_pipe(pipe_class_memory);
5442 %}
5443 
5444 // LoadP + CastP2L
5445 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
5446   match(Set dst (CastP2X (LoadP mem)));
5447   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
5448   ins_cost(MEMORY_REF_COST);
5449 
5450   format %{ "LD      $dst, $mem \t// ptr + p2x" %}
5451   size(4);
5452   ins_encode( enc_ld(dst, mem) );
5453   ins_pipe(pipe_class_memory);
5454 %}
5455 
5456 // Load compressed klass pointer.
5457 instruct loadNKlass(iRegNdst dst, memory mem) %{
5458   match(Set dst (LoadNKlass mem));
5459   ins_cost(MEMORY_REF_COST);
5460 
5461   format %{ "LWZ     $dst, $mem \t// compressed klass ptr" %}
5462   size(4);
5463   ins_encode( enc_lwz(dst, mem) );
5464   ins_pipe(pipe_class_memory);
5465 %}
5466 
5467 // Load Klass Pointer
5468 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
5469   match(Set dst (LoadKlass mem));
5470   ins_cost(MEMORY_REF_COST);
5471 
5472   format %{ "LD      $dst, $mem \t// klass ptr" %}
5473   size(4);
5474   ins_encode( enc_ld(dst, mem) );
5475   ins_pipe(pipe_class_memory);
5476 %}
5477 
5478 // Load Float
5479 instruct loadF(regF dst, memory mem) %{
5480   match(Set dst (LoadF mem));
5481   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5482   ins_cost(MEMORY_REF_COST);
5483 
5484   format %{ "LFS     $dst, $mem" %}
5485   size(4);
5486   ins_encode %{
5487     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
5488     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5489     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
5490   %}
5491   ins_pipe(pipe_class_memory);
5492 %}
5493 
5494 // Load Float acquire.
5495 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
5496   match(Set dst (LoadF mem));
5497   effect(TEMP cr0);
5498   ins_cost(3*MEMORY_REF_COST);
5499 
5500   format %{ "LFS     $dst, $mem \t// acquire\n\t"
5501             "FCMPU   cr0, $dst, $dst\n\t"
5502             "BNE     cr0, next\n"
5503             "next:\n\t"
5504             "ISYNC" %}
5505   size(16);
5506   ins_encode %{
5507     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5508     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5509     Label next;
5510     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
5511     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
5512     __ bne(CCR0, next);
5513     __ bind(next);
5514     __ isync();
5515   %}
5516   ins_pipe(pipe_class_memory);
5517 %}
5518 
5519 // Load Double - aligned
5520 instruct loadD(regD dst, memory mem) %{
5521   match(Set dst (LoadD mem));
5522   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
5523   ins_cost(MEMORY_REF_COST);
5524 
5525   format %{ "LFD     $dst, $mem" %}
5526   size(4);
5527   ins_encode( enc_lfd(dst, mem) );
5528   ins_pipe(pipe_class_memory);
5529 %}
5530 
5531 // Load Double - aligned acquire.
5532 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
5533   match(Set dst (LoadD mem));
5534   effect(TEMP cr0);
5535   ins_cost(3*MEMORY_REF_COST);
5536 
5537   format %{ "LFD     $dst, $mem \t// acquire\n\t"
5538             "FCMPU   cr0, $dst, $dst\n\t"
5539             "BNE     cr0, next\n"
5540             "next:\n\t"
5541             "ISYNC" %}
5542   size(16);
5543   ins_encode %{
5544     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5545     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
5546     Label next;
5547     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
5548     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
5549     __ bne(CCR0, next);
5550     __ bind(next);
5551     __ isync();
5552   %}
5553   ins_pipe(pipe_class_memory);
5554 %}
5555 
5556 // Load Double - UNaligned
5557 instruct loadD_unaligned(regD dst, memory mem) %{
5558   match(Set dst (LoadD_unaligned mem));
5559   // predicate(...) // Unaligned_ac is not needed (and wouldn't make sense).
5560   ins_cost(MEMORY_REF_COST);
5561 
5562   format %{ "LFD     $dst, $mem" %}
5563   size(4);
5564   ins_encode( enc_lfd(dst, mem) );
5565   ins_pipe(pipe_class_memory);
5566 %}
5567 
5568 //----------Constants--------------------------------------------------------
5569 
5570 // Load MachConstantTableBase: add hi offset to global toc.
5571 // TODO: Handle hidden register r29 in bundler!
5572 instruct loadToc_hi(iRegLdst dst) %{
5573   effect(DEF dst);
5574   ins_cost(DEFAULT_COST);
5575 
5576   format %{ "ADDIS   $dst, R29, DISP.hi \t// load TOC hi" %}
5577   size(4);
5578   ins_encode %{
5579     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5580     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
5581   %}
5582   ins_pipe(pipe_class_default);
5583 %}
5584 
5585 // Load MachConstantTableBase: add lo offset to global toc.
5586 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
5587   effect(DEF dst, USE src);
5588   ins_cost(DEFAULT_COST);
5589 
5590   format %{ "ADDI    $dst, $src, DISP.lo \t// load TOC lo" %}
5591   size(4);
5592   ins_encode %{
5593     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5594     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
5595   %}
5596   ins_pipe(pipe_class_default);
5597 %}
5598 
5599 // Load 16-bit integer constant 0xssss????
5600 instruct loadConI16(iRegIdst dst, immI16 src) %{
5601   match(Set dst src);
5602 
5603   format %{ "LI      $dst, $src" %}
5604   size(4);
5605   ins_encode %{
5606     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5607     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
5608   %}
5609   ins_pipe(pipe_class_default);
5610 %}
5611 
5612 // Load integer constant 0x????0000
5613 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
5614   match(Set dst src);
5615   ins_cost(DEFAULT_COST);
5616 
5617   format %{ "LIS     $dst, $src.hi" %}
5618   size(4);
5619   ins_encode %{
5620     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5621     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
5622     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
5623   %}
5624   ins_pipe(pipe_class_default);
5625 %}
5626 
5627 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
5628 // and sign extended), this adds the low 16 bits.
5629 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
5630   // no match-rule, false predicate
5631   effect(DEF dst, USE src1, USE src2);
5632   predicate(false);
5633 
5634   format %{ "ORI     $dst, $src1.hi, $src2.lo" %}
5635   size(4);
5636   ins_encode %{
5637     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5638     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
5639   %}
5640   ins_pipe(pipe_class_default);
5641 %}
5642 
5643 instruct loadConI_Ex(iRegIdst dst, immI src) %{
5644   match(Set dst src);
5645   ins_cost(DEFAULT_COST*2);
5646 
5647   expand %{
5648     // Would like to use $src$$constant.
5649     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
5650     // srcHi can be 0000 if srcLo sign-extends to a negative number.
5651     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
5652     iRegIdst tmpI;
5653     loadConIhi16(tmpI, srcHi);
5654     loadConI32_lo16(dst, tmpI, srcLo);
5655   %}
5656 %}
5657 
5658 // No constant pool entries required.
5659 instruct loadConL16(iRegLdst dst, immL16 src) %{
5660   match(Set dst src);
5661 
5662   format %{ "LI      $dst, $src \t// long" %}
5663   size(4);
5664   ins_encode %{
5665     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5666     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
5667   %}
5668   ins_pipe(pipe_class_default);
5669 %}
5670 
5671 // Load long constant 0xssssssss????0000
5672 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
5673   match(Set dst src);
5674   ins_cost(DEFAULT_COST);
5675 
5676   format %{ "LIS     $dst, $src.hi \t// long" %}
5677   size(4);
5678   ins_encode %{
5679     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5680     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
5681   %}
5682   ins_pipe(pipe_class_default);
5683 %}
5684 
5685 // To load a 32 bit constant: merge lower 16 bits into already loaded
5686 // high 16 bits.
5687 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
5688   // no match-rule, false predicate
5689   effect(DEF dst, USE src1, USE src2);
5690   predicate(false);
5691 
5692   format %{ "ORI     $dst, $src1, $src2.lo" %}
5693   size(4);
5694   ins_encode %{
5695     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5696     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
5697   %}
5698   ins_pipe(pipe_class_default);
5699 %}
5700 
5701 // Load 32-bit long constant
5702 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
5703   match(Set dst src);
5704   ins_cost(DEFAULT_COST*2);
5705 
5706   expand %{
5707     // Would like to use $src$$constant.
5708     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
5709     // srcHi can be 0000 if srcLo sign-extends to a negative number.
5710     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
5711     iRegLdst tmpL;
5712     loadConL32hi16(tmpL, srcHi);
5713     loadConL32_lo16(dst, tmpL, srcLo);
5714   %}
5715 %}
5716 
5717 // Load long constant 0x????000000000000.
5718 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
5719   match(Set dst src);
5720   ins_cost(DEFAULT_COST);
5721 
5722   expand %{
5723     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
5724     immI shift32 %{ 32 %}
5725     iRegLdst tmpL;
5726     loadConL32hi16(tmpL, srcHi);
5727     lshiftL_regL_immI(dst, tmpL, shift32);
5728   %}
5729 %}
5730 
5731 // Expand node for constant pool load: small offset.
5732 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
5733   effect(DEF dst, USE src, USE toc);
5734   ins_cost(MEMORY_REF_COST);
5735 
5736   ins_num_consts(1);
5737   // Needed so that CallDynamicJavaDirect can compute the address of this
5738   // instruction for relocation.
5739   ins_field_cbuf_insts_offset(int);
5740 
5741   format %{ "LD      $dst, offset, $toc \t// load long $src from TOC" %}
5742   size(4);
5743   ins_encode( enc_load_long_constL(dst, src, toc) );
5744   ins_pipe(pipe_class_memory);
5745 %}
5746 
5747 // Expand node for constant pool load: large offset.
5748 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
5749   effect(DEF dst, USE src, USE toc);
5750   predicate(false);
5751 
5752   ins_num_consts(1);
5753   ins_field_const_toc_offset(int);
5754   // Needed so that CallDynamicJavaDirect can compute the address of this
5755   // instruction for relocation.
5756   ins_field_cbuf_insts_offset(int);
5757 
5758   format %{ "ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)" %}
5759   size(4);
5760   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
5761   ins_pipe(pipe_class_default);
5762 %}
5763 
5764 // Expand node for constant pool load: large offset.
5765 // No constant pool entries required.
5766 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
5767   effect(DEF dst, USE src, USE base);
5768   predicate(false);
5769 
5770   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
5771 
5772   format %{ "LD      $dst, offset, $base \t// load long $src from TOC (lo)" %}
5773   size(4);
5774   ins_encode %{
5775     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
5776     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
5777     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
5778   %}
5779   ins_pipe(pipe_class_memory);
5780 %}
5781 
5782 // Load long constant from constant table. Expand in case of
5783 // offset &gt; 16 bit is needed.
5784 // Adlc adds toc node MachConstantTableBase.
5785 instruct loadConL_Ex(iRegLdst dst, immL src) %{
5786   match(Set dst src);
5787   ins_cost(MEMORY_REF_COST);
5788 
5789   format %{ "LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded" %}
5790   // We can not inline the enc_class for the expand as that does not support constanttablebase.
5791   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
5792 %}
5793 
5794 // Load NULL as compressed oop.
5795 instruct loadConN0(iRegNdst dst, immN_0 src) %{
5796   match(Set dst src);
5797   ins_cost(DEFAULT_COST);
5798 
5799   format %{ "LI      $dst, $src \t// compressed ptr" %}
5800   size(4);
5801   ins_encode %{
5802     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5803     __ li($dst$$Register, 0);
5804   %}
5805   ins_pipe(pipe_class_default);
5806 %}
5807 
5808 // Load hi part of compressed oop constant.
5809 instruct loadConN_hi(iRegNdst dst, immN src) %{
5810   effect(DEF dst, USE src);
5811   ins_cost(DEFAULT_COST);
5812 
5813   format %{ "LIS     $dst, $src \t// narrow oop hi" %}
5814   size(4);
5815   ins_encode %{
5816     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5817     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
5818   %}
5819   ins_pipe(pipe_class_default);
5820 %}
5821 
5822 // Add lo part of compressed oop constant to already loaded hi part.
5823 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
5824   effect(DEF dst, USE src1, USE src2);
5825   ins_cost(DEFAULT_COST);
5826 
5827   format %{ "ORI     $dst, $src1, $src2 \t// narrow oop lo" %}
5828   size(4);
5829   ins_encode %{
5830     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
5831     assert(__ oop_recorder() != NULL, "this assembler needs an OopRecorder");
5832     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
5833     RelocationHolder rspec = oop_Relocation::spec(oop_index);
5834     __ relocate(rspec, 1);
5835     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
5836   %}
5837   ins_pipe(pipe_class_default);
5838 %}
5839 
5840 // Needed to postalloc expand loadConN: ConN is loaded as ConI
5841 // leaving the upper 32 bits with sign-extension bits.
5842 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
5843 // TODO: Eventually call this maskN_regN_FFFFFFFF.
5844 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
5845   effect(DEF dst, USE src);
5846   predicate(false);
5847 
5848   format %{ "MASK    $dst, $src, 0xFFFFFFFF" %} // mask
5849   size(4);
5850   ins_encode %{
5851     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
5852     __ clrldi($dst$$Register, $src$$Register, 0x20);
5853   %}
5854   ins_pipe(pipe_class_default);
5855 %}
5856 
5857 // Optimize DecodeN for disjoint base.
5858 // Load base of compressed oops into a register
5859 instruct loadBase(iRegLdst dst) %{
5860   effect(DEF dst);
5861 
5862   format %{ "LoadConst $dst, heapbase" %}
5863   ins_encode %{
5864     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
5865     __ load_const_optimized($dst$$Register, Universe::narrow_oop_base(), R0);
5866   %}
5867   ins_pipe(pipe_class_default);
5868 %}
5869 
5870 // Loading ConN must be postalloc expanded so that edges between
5871 // the nodes are safe. They may not interfere with a safepoint.
5872 // GL TODO: This needs three instructions: better put this into the constant pool.
5873 instruct loadConN_Ex(iRegNdst dst, immN src) %{
5874   match(Set dst src);
5875   ins_cost(DEFAULT_COST*2);
5876 
5877   format %{ "LoadN   $dst, $src \t// postalloc expanded" %} // mask
5878   postalloc_expand %{
5879     MachNode *m1 = new loadConN_hiNode();
5880     MachNode *m2 = new loadConN_loNode();
5881     MachNode *m3 = new clearMs32bNode();
5882     m1-&gt;add_req(NULL);
5883     m2-&gt;add_req(NULL, m1);
5884     m3-&gt;add_req(NULL, m2);
5885     m1-&gt;_opnds[0] = op_dst;
5886     m1-&gt;_opnds[1] = op_src;
5887     m2-&gt;_opnds[0] = op_dst;
5888     m2-&gt;_opnds[1] = op_dst;
5889     m2-&gt;_opnds[2] = op_src;
5890     m3-&gt;_opnds[0] = op_dst;
5891     m3-&gt;_opnds[1] = op_dst;
5892     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5893     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5894     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5895     nodes-&gt;push(m1);
5896     nodes-&gt;push(m2);
5897     nodes-&gt;push(m3);
5898   %}
5899 %}
5900 
5901 // We have seen a safepoint between the hi and lo parts, and this node was handled
5902 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
5903 // not a narrow oop.
5904 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
5905   match(Set dst src);
5906   effect(DEF dst, USE src);
5907   ins_cost(DEFAULT_COST);
5908 
5909   format %{ "LIS     $dst, $src \t// narrow klass hi" %}
5910   size(4);
5911   ins_encode %{
5912     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
5913     intptr_t Csrc = Klass::encode_klass((Klass *)$src$$constant);
5914     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
5915   %}
5916   ins_pipe(pipe_class_default);
5917 %}
5918 
5919 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
5920 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
5921   match(Set dst src1);
5922   effect(TEMP src2);
5923   ins_cost(DEFAULT_COST);
5924 
5925   format %{ "MASK    $dst, $src2, 0xFFFFFFFF" %} // mask
5926   size(4);
5927   ins_encode %{
5928     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
5929     __ clrldi($dst$$Register, $src2$$Register, 0x20);
5930   %}
5931   ins_pipe(pipe_class_default);
5932 %}
5933 
5934 // This needs a match rule so that build_oop_map knows this is
5935 // not a narrow oop.
5936 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
5937   match(Set dst src1);
5938   effect(TEMP src2);
5939   ins_cost(DEFAULT_COST);
5940 
5941   format %{ "ORI     $dst, $src1, $src2 \t// narrow klass lo" %}
5942   size(4);
5943   ins_encode %{
5944     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
5945     intptr_t Csrc = Klass::encode_klass((Klass *)$src1$$constant);
5946     assert(__ oop_recorder() != NULL, "this assembler needs an OopRecorder");
5947     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
5948     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5949 
5950     __ relocate(rspec, 1);
5951     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
5952   %}
5953   ins_pipe(pipe_class_default);
5954 %}
5955 
5956 // Loading ConNKlass must be postalloc expanded so that edges between
5957 // the nodes are safe. They may not interfere with a safepoint.
5958 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
5959   match(Set dst src);
5960   ins_cost(DEFAULT_COST*2);
5961 
5962   format %{ "LoadN   $dst, $src \t// postalloc expanded" %} // mask
5963   postalloc_expand %{
5964     // Load high bits into register. Sign extended.
5965     MachNode *m1 = new loadConNKlass_hiNode();
5966     m1-&gt;add_req(NULL);
5967     m1-&gt;_opnds[0] = op_dst;
5968     m1-&gt;_opnds[1] = op_src;
5969     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5970     nodes-&gt;push(m1);
5971 
5972     MachNode *m2 = m1;
5973     if (!Assembler::is_uimm((jlong)Klass::encode_klass((Klass *)op_src-&gt;constant()), 31)) {
5974       // Value might be 1-extended. Mask out these bits.
5975       m2 = new loadConNKlass_maskNode();
5976       m2-&gt;add_req(NULL, m1);
5977       m2-&gt;_opnds[0] = op_dst;
5978       m2-&gt;_opnds[1] = op_src;
5979       m2-&gt;_opnds[2] = op_dst;
5980       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5981       nodes-&gt;push(m2);
5982     }
5983 
5984     MachNode *m3 = new loadConNKlass_loNode();
5985     m3-&gt;add_req(NULL, m2);
5986     m3-&gt;_opnds[0] = op_dst;
5987     m3-&gt;_opnds[1] = op_src;
5988     m3-&gt;_opnds[2] = op_dst;
5989     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
5990     nodes-&gt;push(m3);
5991   %}
5992 %}
5993 
5994 // 0x1 is used in object initialization (initial object header).
5995 // No constant pool entries required.
5996 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
5997   match(Set dst src);
5998 
5999   format %{ "LI      $dst, $src \t// ptr" %}
6000   size(4);
6001   ins_encode %{
6002     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
6003     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
6004   %}
6005   ins_pipe(pipe_class_default);
6006 %}
6007 
6008 // Expand node for constant pool load: small offset.
6009 // The match rule is needed to generate the correct bottom_type(),
6010 // however this node should never match. The use of predicate is not
6011 // possible since ADLC forbids predicates for chain rules. The higher
6012 // costs do not prevent matching in this case. For that reason the
6013 // operand immP_NM with predicate(false) is used.
6014 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
6015   match(Set dst src);
6016   effect(TEMP toc);
6017 
6018   ins_num_consts(1);
6019 
6020   format %{ "LD      $dst, offset, $toc \t// load ptr $src from TOC" %}
6021   size(4);
6022   ins_encode( enc_load_long_constP(dst, src, toc) );
6023   ins_pipe(pipe_class_memory);
6024 %}
6025 
6026 // Expand node for constant pool load: large offset.
6027 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
6028   effect(DEF dst, USE src, USE toc);
6029   predicate(false);
6030 
6031   ins_num_consts(1);
6032   ins_field_const_toc_offset(int);
6033 
6034   format %{ "ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)" %}
6035   size(4);
6036   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
6037   ins_pipe(pipe_class_default);
6038 %}
6039 
6040 // Expand node for constant pool load: large offset.
6041 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
6042   match(Set dst src);
6043   effect(TEMP base);
6044 
6045   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
6046 
6047   format %{ "LD      $dst, offset, $base \t// load ptr $src from TOC (lo)" %}
6048   size(4);
6049   ins_encode %{
6050     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
6051     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
6052     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
6053   %}
6054   ins_pipe(pipe_class_memory);
6055 %}
6056 
6057 // Load pointer constant from constant table. Expand in case an
6058 // offset &gt; 16 bit is needed.
6059 // Adlc adds toc node MachConstantTableBase.
6060 instruct loadConP_Ex(iRegPdst dst, immP src) %{
6061   match(Set dst src);
6062   ins_cost(MEMORY_REF_COST);
6063 
6064   // This rule does not use "expand" because then
6065   // the result type is not known to be an Oop.  An ADLC
6066   // enhancement will be needed to make that work - not worth it!
6067 
6068   // If this instruction rematerializes, it prolongs the live range
6069   // of the toc node, causing illegal graphs.
6070   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
6071   ins_cannot_rematerialize(true);
6072 
6073   format %{ "LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded" %}
6074   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
6075 %}
6076 
6077 // Expand node for constant pool load: small offset.
6078 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
6079   effect(DEF dst, USE src, USE toc);
6080   ins_cost(MEMORY_REF_COST);
6081 
6082   ins_num_consts(1);
6083 
6084   format %{ "LFS     $dst, offset, $toc \t// load float $src from TOC" %}
6085   size(4);
6086   ins_encode %{
6087     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
6088     address float_address = __ float_constant($src$$constant);
6089     if (float_address == NULL) {
6090       ciEnv::current()-&gt;record_out_of_memory_failure();
6091       return;
6092     }
6093     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
6094   %}
6095   ins_pipe(pipe_class_memory);
6096 %}
6097 
6098 // Expand node for constant pool load: large offset.
6099 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
6100   effect(DEF dst, USE src, USE toc);
6101   ins_cost(MEMORY_REF_COST);
6102 
6103   ins_num_consts(1);
6104 
6105   format %{ "ADDIS   $toc, $toc, offset_hi\n\t"
6106             "LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t"
6107             "ADDIS   $toc, $toc, -offset_hi"%}
6108   size(12);
6109   ins_encode %{
6110     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6111     FloatRegister Rdst    = $dst$$FloatRegister;
6112     Register Rtoc         = $toc$$Register;
6113     address float_address = __ float_constant($src$$constant);
6114     if (float_address == NULL) {
6115       ciEnv::current()-&gt;record_out_of_memory_failure();
6116       return;
6117     }
6118     int offset            = __ offset_to_method_toc(float_address);
6119     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
6120     int lo = offset - hi * (1&lt;&lt;16);
6121 
6122     __ addis(Rtoc, Rtoc, hi);
6123     __ lfs(Rdst, lo, Rtoc);
6124     __ addis(Rtoc, Rtoc, -hi);
6125   %}
6126   ins_pipe(pipe_class_memory);
6127 %}
6128 
6129 // Adlc adds toc node MachConstantTableBase.
6130 instruct loadConF_Ex(regF dst, immF src) %{
6131   match(Set dst src);
6132   ins_cost(MEMORY_REF_COST);
6133 
6134   // See loadConP.
6135   ins_cannot_rematerialize(true);
6136 
6137   format %{ "LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded" %}
6138   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
6139 %}
6140 
6141 // Expand node for constant pool load: small offset.
6142 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
6143   effect(DEF dst, USE src, USE toc);
6144   ins_cost(MEMORY_REF_COST);
6145 
6146   ins_num_consts(1);
6147 
6148   format %{ "LFD     $dst, offset, $toc \t// load double $src from TOC" %}
6149   size(4);
6150   ins_encode %{
6151     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
6152     address float_address = __ double_constant($src$$constant);
6153     if (float_address == NULL) {
6154       ciEnv::current()-&gt;record_out_of_memory_failure();
6155       return;
6156     }
6157     int offset =  __ offset_to_method_toc(float_address);
6158     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
6159   %}
6160   ins_pipe(pipe_class_memory);
6161 %}
6162 
6163 // Expand node for constant pool load: large offset.
6164 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
6165   effect(DEF dst, USE src, USE toc);
6166   ins_cost(MEMORY_REF_COST);
6167 
6168   ins_num_consts(1);
6169 
6170   format %{ "ADDIS   $toc, $toc, offset_hi\n\t"
6171             "LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t"
6172             "ADDIS   $toc, $toc, -offset_hi" %}
6173   size(12);
6174   ins_encode %{
6175     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6176     FloatRegister Rdst    = $dst$$FloatRegister;
6177     Register      Rtoc    = $toc$$Register;
6178     address float_address = __ double_constant($src$$constant);
6179     if (float_address == NULL) {
6180       ciEnv::current()-&gt;record_out_of_memory_failure();
6181       return;
6182     }
6183     int offset = __ offset_to_method_toc(float_address);
6184     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
6185     int lo = offset - hi * (1&lt;&lt;16);
6186 
6187     __ addis(Rtoc, Rtoc, hi);
6188     __ lfd(Rdst, lo, Rtoc);
6189     __ addis(Rtoc, Rtoc, -hi);
6190   %}
6191   ins_pipe(pipe_class_memory);
6192 %}
6193 
6194 // Adlc adds toc node MachConstantTableBase.
6195 instruct loadConD_Ex(regD dst, immD src) %{
6196   match(Set dst src);
6197   ins_cost(MEMORY_REF_COST);
6198 
6199   // See loadConP.
6200   ins_cannot_rematerialize(true);
6201 
6202   format %{ "ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded" %}
6203   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
6204 %}
6205 
6206 // Prefetch instructions.
6207 // Must be safe to execute with invalid address (cannot fault).
6208 
6209 // Special prefetch versions which use the dcbz instruction.
6210 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
6211   match(PrefetchAllocation (AddP mem src));
6212   predicate(AllocatePrefetchStyle == 3);
6213   ins_cost(MEMORY_REF_COST);
6214 
6215   format %{ "PREFETCH $mem, 2, $src \t// Prefetch write-many with zero" %}
6216   size(4);
6217   ins_encode %{
6218     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6219     __ dcbz($src$$Register, $mem$$base$$Register);
6220   %}
6221   ins_pipe(pipe_class_memory);
6222 %}
6223 
6224 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
6225   match(PrefetchAllocation mem);
6226   predicate(AllocatePrefetchStyle == 3);
6227   ins_cost(MEMORY_REF_COST);
6228 
6229   format %{ "PREFETCH $mem, 2 \t// Prefetch write-many with zero" %}
6230   size(4);
6231   ins_encode %{
6232     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6233     __ dcbz($mem$$base$$Register);
6234   %}
6235   ins_pipe(pipe_class_memory);
6236 %}
6237 
6238 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
6239   match(PrefetchAllocation (AddP mem src));
6240   predicate(AllocatePrefetchStyle != 3);
6241   ins_cost(MEMORY_REF_COST);
6242 
6243   format %{ "PREFETCH $mem, 2, $src \t// Prefetch write-many" %}
6244   size(4);
6245   ins_encode %{
6246     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6247     __ dcbtst($src$$Register, $mem$$base$$Register);
6248   %}
6249   ins_pipe(pipe_class_memory);
6250 %}
6251 
6252 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
6253   match(PrefetchAllocation mem);
6254   predicate(AllocatePrefetchStyle != 3);
6255   ins_cost(MEMORY_REF_COST);
6256 
6257   format %{ "PREFETCH $mem, 2 \t// Prefetch write-many" %}
6258   size(4);
6259   ins_encode %{
6260     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
6261     __ dcbtst($mem$$base$$Register);
6262   %}
6263   ins_pipe(pipe_class_memory);
6264 %}
6265 
6266 //----------Store Instructions-------------------------------------------------
6267 
6268 // Store Byte
6269 instruct storeB(memory mem, iRegIsrc src) %{
6270   match(Set mem (StoreB mem src));
6271   ins_cost(MEMORY_REF_COST);
6272 
6273   format %{ "STB     $src, $mem \t// byte" %}
6274   size(4);
6275   ins_encode %{
6276     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
6277     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6278     __ stb($src$$Register, Idisp, $mem$$base$$Register);
6279   %}
6280   ins_pipe(pipe_class_memory);
6281 %}
6282 
6283 instruct storeB_0(memory mem, immI_0 zero) %{
6284   match(Set mem (StoreB mem zero));
6285   ins_cost(MEMORY_REF_COST);
6286 
6287   format %{ "STB     0, $mem \t// store 0 on a byte" %}
6288   size(4);
6289   ins_encode %{
6290     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
6291     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6292     __ stb(R30_zero, Idisp, $mem$$base$$Register);
6293   %}
6294   ins_pipe(pipe_class_memory);
6295 %}
6296 
6297 // Store Char/Short
6298 instruct storeC(memory mem, iRegIsrc src) %{
6299   match(Set mem (StoreC mem src));
6300   ins_cost(MEMORY_REF_COST);
6301 
6302   format %{ "STH     $src, $mem \t// short" %}
6303   size(4);
6304   ins_encode %{
6305     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
6306     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6307     __ sth($src$$Register, Idisp, $mem$$base$$Register);
6308   %}
6309   ins_pipe(pipe_class_memory);
6310 %}
6311 
6312 instruct storeC_0(memory mem, immI_0 zero) %{
6313   match(Set mem (StoreC mem zero));
6314   ins_cost(MEMORY_REF_COST);
6315 
6316   format %{ "STH     0, $mem \t// store 0 on a short" %}
6317   size(4);
6318   ins_encode %{
6319     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
6320     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6321     __ sth(R30_zero, Idisp, $mem$$base$$Register);
6322   %}
6323   ins_pipe(pipe_class_memory);
6324 %}
6325 
6326 // Store Integer
6327 instruct storeI(memory mem, iRegIsrc src) %{
6328   match(Set mem (StoreI mem src));
6329   ins_cost(MEMORY_REF_COST);
6330 
6331   format %{ "STW     $src, $mem" %}
6332   size(4);
6333   ins_encode( enc_stw(src, mem) );
6334   ins_pipe(pipe_class_memory);
6335 %}
6336 
6337 instruct storeI_0(memory mem, immI_0 zero) %{
6338   match(Set mem (StoreI mem zero));
6339   ins_cost(MEMORY_REF_COST);
6340 
6341   format %{ "STW     0, $mem \t// store 0 on a word" %}
6342   size(4);
6343   ins_encode %{
6344     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6345     __ stw(R30_zero, Idisp, $mem$$base$$Register);
6346   %}
6347   ins_pipe(pipe_class_memory);
6348 %}
6349 
6350 // ConvL2I + StoreI.
6351 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
6352   match(Set mem (StoreI mem (ConvL2I src)));
6353   ins_cost(MEMORY_REF_COST);
6354 
6355   format %{ "STW     l2i($src), $mem" %}
6356   size(4);
6357   ins_encode( enc_stw(src, mem) );
6358   ins_pipe(pipe_class_memory);
6359 %}
6360 
6361 // Store Long
6362 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
6363   match(Set mem (StoreL mem src));
6364   ins_cost(MEMORY_REF_COST);
6365 
6366   format %{ "STD     $src, $mem \t// long" %}
6367   size(4);
6368   ins_encode( enc_std(src, mem) );
6369   ins_pipe(pipe_class_memory);
6370 %}
6371 
6372 instruct storeL_0(memoryAlg4 mem, immL_0 zero) %{
6373   match(Set mem (StoreL mem zero));
6374   ins_cost(MEMORY_REF_COST);
6375 
6376   format %{ "STD     0, $mem \t// store 0 on a long" %}
6377   size(4);
6378   ins_encode %{
6379     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6380     // Operand 'ds' requires 4-alignment.
6381     assert((Idisp &amp; 0x3) == 0, "unaligned offset");
6382     __ std(R30_zero, Idisp, $mem$$base$$Register);
6383   %}
6384   ins_pipe(pipe_class_memory);
6385 %}
6386 
6387 // Store super word nodes.
6388 
6389 // Store Aligned Packed Byte long register to memory
6390 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
6391   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
6392   match(Set mem (StoreVector mem src));
6393   ins_cost(MEMORY_REF_COST);
6394 
6395   format %{ "STD     $mem, $src \t// packed8B" %}
6396   size(4);
6397   ins_encode( enc_std(src, mem) );
6398   ins_pipe(pipe_class_memory);
6399 %}
6400 
6401 // Store Compressed Oop
6402 instruct storeN(memory dst, iRegN_P2N src) %{
6403   match(Set dst (StoreN dst src));
6404   ins_cost(MEMORY_REF_COST);
6405 
6406   format %{ "STW     $src, $dst \t// compressed oop" %}
6407   size(4);
6408   ins_encode( enc_stw(src, dst) );
6409   ins_pipe(pipe_class_memory);
6410 %}
6411 
6412 // Store Compressed KLass
6413 instruct storeNKlass(memory dst, iRegN_P2N src) %{
6414   match(Set dst (StoreNKlass dst src));
6415   ins_cost(MEMORY_REF_COST);
6416 
6417   format %{ "STW     $src, $dst \t// compressed klass" %}
6418   size(4);
6419   ins_encode( enc_stw(src, dst) );
6420   ins_pipe(pipe_class_memory);
6421 %}
6422 
6423 // Store Pointer
6424 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
6425   match(Set dst (StoreP dst src));
6426   ins_cost(MEMORY_REF_COST);
6427 
6428   format %{ "STD     $src, $dst \t// ptr" %}
6429   size(4);
6430   ins_encode( enc_std(src, dst) );
6431   ins_pipe(pipe_class_memory);
6432 %}
6433 
6434 // Store Float
6435 instruct storeF(memory mem, regF src) %{
6436   match(Set mem (StoreF mem src));
6437   ins_cost(MEMORY_REF_COST);
6438 
6439   format %{ "STFS    $src, $mem" %}
6440   size(4);
6441   ins_encode( enc_stfs(src, mem) );
6442   ins_pipe(pipe_class_memory);
6443 %}
6444 
6445 // Store Double
6446 instruct storeD(memory mem, regD src) %{
6447   match(Set mem (StoreD mem src));
6448   ins_cost(MEMORY_REF_COST);
6449 
6450   format %{ "STFD    $src, $mem" %}
6451   size(4);
6452   ins_encode( enc_stfd(src, mem) );
6453   ins_pipe(pipe_class_memory);
6454 %}
6455 
6456 //----------Store Instructions With Zeros--------------------------------------
6457 
6458 // Card-mark for CMS garbage collection.
6459 // This cardmark does an optimization so that it must not always
6460 // do a releasing store. For this, it gets the address of
6461 // CMSCollectorCardTableModRefBSExt::_requires_release as input.
6462 // (Using releaseFieldAddr in the match rule is a hack.)
6463 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
6464   match(Set mem (StoreCM mem releaseFieldAddr));
6465   effect(TEMP crx);
6466   predicate(false);
6467   ins_cost(MEMORY_REF_COST);
6468 
6469   // See loadConP.
6470   ins_cannot_rematerialize(true);
6471 
6472   format %{ "STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]" %}
6473   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
6474   ins_pipe(pipe_class_memory);
6475 %}
6476 
6477 // Card-mark for CMS garbage collection.
6478 // This cardmark does an optimization so that it must not always
6479 // do a releasing store. For this, it needs the constant address of
6480 // CMSCollectorCardTableModRefBSExt::_requires_release.
6481 // This constant address is split off here by expand so we can use
6482 // adlc / matcher functionality to load it from the constant section.
6483 instruct storeCM_CMS_ExEx(memory mem, immI_0 zero) %{
6484   match(Set mem (StoreCM mem zero));
6485   predicate(UseConcMarkSweepGC);
6486 
6487   expand %{
6488     immL baseImm %{ 0 /* TODO: PPC port (jlong)CMSCollectorCardTableModRefBSExt::requires_release_address() */ %}
6489     iRegLdst releaseFieldAddress;
6490     flagsReg crx;
6491     loadConL_Ex(releaseFieldAddress, baseImm);
6492     storeCM_CMS(mem, releaseFieldAddress, crx);
6493   %}
6494 %}
6495 
6496 instruct storeCM_G1(memory mem, immI_0 zero) %{
6497   match(Set mem (StoreCM mem zero));
6498   predicate(UseG1GC);
6499   ins_cost(MEMORY_REF_COST);
6500 
6501   ins_cannot_rematerialize(true);
6502 
6503   format %{ "STB     #0, $mem \t// CMS card-mark byte store (G1)" %}
6504   size(8);
6505   ins_encode %{
6506     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6507     __ li(R0, 0);
6508     //__ release(); // G1: oops are allowed to get visible after dirty marking
6509     guarantee($mem$$base$$Register != R1_SP, "use frame_slots_bias");
6510     __ stb(R0, $mem$$disp, $mem$$base$$Register);
6511   %}
6512   ins_pipe(pipe_class_memory);
6513 %}
6514 
6515 // Convert oop pointer into compressed form.
6516 
6517 // Nodes for postalloc expand.
6518 
6519 // Shift node for expand.
6520 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
6521   // The match rule is needed to make it a 'MachTypeNode'!
6522   match(Set dst (EncodeP src));
6523   predicate(false);
6524 
6525   format %{ "SRDI    $dst, $src, 3 \t// encode" %}
6526   size(4);
6527   ins_encode %{
6528     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6529     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);
6530   %}
6531   ins_pipe(pipe_class_default);
6532 %}
6533 
6534 // Add node for expand.
6535 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
6536   // The match rule is needed to make it a 'MachTypeNode'!
6537   match(Set dst (EncodeP src));
6538   predicate(false);
6539 
6540   format %{ "SUB     $dst, $src, oop_base \t// encode" %}
6541   ins_encode %{
6542     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6543     __ sub_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
6544   %}
6545   ins_pipe(pipe_class_default);
6546 %}
6547 
6548 // Conditional sub base.
6549 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
6550   // The match rule is needed to make it a 'MachTypeNode'!
6551   match(Set dst (EncodeP (Binary crx src1)));
6552   predicate(false);
6553 
6554   format %{ "BEQ     $crx, done\n\t"
6555             "SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n"
6556             "done:" %}
6557   ins_encode %{
6558     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6559     Label done;
6560     __ beq($crx$$CondRegister, done);
6561     __ sub_const_optimized($dst$$Register, $src1$$Register, Universe::narrow_oop_base(), R0);
6562     __ bind(done);
6563   %}
6564   ins_pipe(pipe_class_default);
6565 %}
6566 
6567 // Power 7 can use isel instruction
6568 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
6569   // The match rule is needed to make it a 'MachTypeNode'!
6570   match(Set dst (EncodeP (Binary crx src1)));
6571   predicate(false);
6572 
6573   format %{ "CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0" %}
6574   size(4);
6575   ins_encode %{
6576     // This is a Power7 instruction for which no machine description exists.
6577     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6578     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
6579   %}
6580   ins_pipe(pipe_class_default);
6581 %}
6582 
6583 // Disjoint narrow oop base.
6584 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
6585   match(Set dst (EncodeP src));
6586   predicate(Universe::narrow_oop_base_disjoint());
6587 
6588   format %{ "EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base" %}
6589   size(4);
6590   ins_encode %{
6591     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6592     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_oop_shift(), 32);
6593   %}
6594   ins_pipe(pipe_class_default);
6595 %}
6596 
6597 // shift != 0, base != 0
6598 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
6599   match(Set dst (EncodeP src));
6600   effect(TEMP crx);
6601   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6602             Universe::narrow_oop_shift() != 0 &amp;&amp;
6603             Universe::narrow_oop_base_overlaps());
6604 
6605   format %{ "EncodeP $dst, $crx, $src \t// postalloc expanded" %}
6606   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
6607 %}
6608 
6609 // shift != 0, base != 0
6610 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
6611   match(Set dst (EncodeP src));
6612   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
6613             Universe::narrow_oop_shift() != 0 &amp;&amp;
6614             Universe::narrow_oop_base_overlaps());
6615 
6616   format %{ "EncodeP $dst, $src\t// $src != Null, postalloc expanded" %}
6617   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
6618 %}
6619 
6620 // shift != 0, base == 0
6621 // TODO: This is the same as encodeP_shift. Merge!
6622 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
6623   match(Set dst (EncodeP src));
6624   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;
6625             Universe::narrow_oop_base() ==0);
6626 
6627   format %{ "SRDI    $dst, $src, #3 \t// encodeP, $src != NULL" %}
6628   size(4);
6629   ins_encode %{
6630     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6631     __ srdi($dst$$Register, $src$$Register, Universe::narrow_oop_shift() &amp; 0x3f);
6632   %}
6633   ins_pipe(pipe_class_default);
6634 %}
6635 
6636 // Compressed OOPs with narrow_oop_shift == 0.
6637 // shift == 0, base == 0
6638 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
6639   match(Set dst (EncodeP src));
6640   predicate(Universe::narrow_oop_shift() == 0);
6641 
6642   format %{ "MR      $dst, $src \t// Ptr-&gt;Narrow" %}
6643   // variable size, 0 or 4.
6644   ins_encode %{
6645     // TODO: PPC port $archOpcode(ppc64Opcode_or);
6646     __ mr_if_needed($dst$$Register, $src$$Register);
6647   %}
6648   ins_pipe(pipe_class_default);
6649 %}
6650 
6651 // Decode nodes.
6652 
6653 // Shift node for expand.
6654 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
6655   // The match rule is needed to make it a 'MachTypeNode'!
6656   match(Set dst (DecodeN src));
6657   predicate(false);
6658 
6659   format %{ "SLDI    $dst, $src, #3 \t// DecodeN" %}
6660   size(4);
6661   ins_encode %{
6662     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
6663     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());
6664   %}
6665   ins_pipe(pipe_class_default);
6666 %}
6667 
6668 // Add node for expand.
6669 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
6670   // The match rule is needed to make it a 'MachTypeNode'!
6671   match(Set dst (DecodeN src));
6672   predicate(false);
6673 
6674   format %{ "ADD     $dst, $src, heapbase \t// DecodeN, add oop base" %}
6675   ins_encode %{
6676     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6677     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
6678   %}
6679   ins_pipe(pipe_class_default);
6680 %}
6681 
6682 // conditianal add base for expand
6683 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
6684   // The match rule is needed to make it a 'MachTypeNode'!
6685   // NOTICE that the rule is nonsense - we just have to make sure that:
6686   //  - _matrule-&gt;_rChild-&gt;_opType == "DecodeN" (see InstructForm::captures_bottom_type() in formssel.cpp)
6687   //  - we have to match 'crx' to avoid an "illegal USE of non-input: flagsReg crx" error in ADLC.
6688   match(Set dst (DecodeN (Binary crx src)));
6689   predicate(false);
6690 
6691   format %{ "BEQ     $crx, done\n\t"
6692             "ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n"
6693             "done:" %}
6694   ins_encode %{
6695     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6696     Label done;
6697     __ beq($crx$$CondRegister, done);
6698     __ add_const_optimized($dst$$Register, $src$$Register, Universe::narrow_oop_base(), R0);
6699     __ bind(done);
6700   %}
6701   ins_pipe(pipe_class_default);
6702 %}
6703 
6704 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
6705   // The match rule is needed to make it a 'MachTypeNode'!
6706   // NOTICE that the rule is nonsense - we just have to make sure that:
6707   //  - _matrule-&gt;_rChild-&gt;_opType == "DecodeN" (see InstructForm::captures_bottom_type() in formssel.cpp)
6708   //  - we have to match 'crx' to avoid an "illegal USE of non-input: flagsReg crx" error in ADLC.
6709   match(Set dst (DecodeN (Binary crx src1)));
6710   predicate(false);
6711 
6712   format %{ "CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0" %}
6713   size(4);
6714   ins_encode %{
6715     // This is a Power7 instruction for which no machine description exists.
6716     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
6717     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
6718   %}
6719   ins_pipe(pipe_class_default);
6720 %}
6721 
6722 //  shift != 0, base != 0
6723 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
6724   match(Set dst (DecodeN src));
6725   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6726              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
6727             Universe::narrow_oop_shift() != 0 &amp;&amp;
6728             Universe::narrow_oop_base() != 0);
6729   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
6730   effect(TEMP crx);
6731 
6732   format %{ "DecodeN $dst, $src \t// Kills $crx, postalloc expanded" %}
6733   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
6734 %}
6735 
6736 // shift != 0, base == 0
6737 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
6738   match(Set dst (DecodeN src));
6739   predicate(Universe::narrow_oop_shift() != 0 &amp;&amp;
6740             Universe::narrow_oop_base() == 0);
6741 
6742   format %{ "SLDI    $dst, $src, #3 \t// DecodeN (zerobased)" %}
6743   size(4);
6744   ins_encode %{
6745     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
6746     __ sldi($dst$$Register, $src$$Register, Universe::narrow_oop_shift());
6747   %}
6748   ins_pipe(pipe_class_default);
6749 %}
6750 
6751 // Optimize DecodeN for disjoint base.
6752 // Shift narrow oop and or it into register that already contains the heap base.
6753 // Base == dst must hold, and is assured by construction in postaloc_expand.
6754 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
6755   match(Set dst (DecodeN src));
6756   effect(TEMP base);
6757   predicate(false);
6758 
6759   format %{ "RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)" %}
6760   size(4);
6761   ins_encode %{
6762     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
6763     __ rldimi($dst$$Register, $src$$Register, Universe::narrow_oop_shift(), 32-Universe::narrow_oop_shift());
6764   %}
6765   ins_pipe(pipe_class_default);
6766 %}
6767 
6768 // Optimize DecodeN for disjoint base.
6769 // This node requires only one cycle on the critical path.
6770 // We must postalloc_expand as we can not express use_def effects where
6771 // the used register is L and the def'ed register P.
6772 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
6773   match(Set dst (DecodeN src));
6774   effect(TEMP_DEF dst);
6775   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
6776              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
6777             Universe::narrow_oop_base_disjoint());
6778   ins_cost(DEFAULT_COST);
6779 
6780   format %{ "MOV     $dst, heapbase \t\n"
6781             "RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base" %}
6782   postalloc_expand %{
6783     loadBaseNode *n1 = new loadBaseNode();
6784     n1-&gt;add_req(NULL);
6785     n1-&gt;_opnds[0] = op_dst;
6786 
6787     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
6788     n2-&gt;add_req(n_region, n_src, n1);
6789     n2-&gt;_opnds[0] = op_dst;
6790     n2-&gt;_opnds[1] = op_src;
6791     n2-&gt;_opnds[2] = op_dst;
6792     n2-&gt;_bottom_type = _bottom_type;
6793 
6794     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6795     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6796 
6797     nodes-&gt;push(n1);
6798     nodes-&gt;push(n2);
6799   %}
6800 %}
6801 
6802 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
6803   match(Set dst (DecodeN src));
6804   effect(TEMP_DEF dst, TEMP crx);
6805   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6806              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
6807             Universe::narrow_oop_base_disjoint() &amp;&amp; VM_Version::has_isel());
6808   ins_cost(3 * DEFAULT_COST);
6809 
6810   format %{ "DecodeN  $dst, $src \t// decode with disjoint base using isel" %}
6811   postalloc_expand %{
6812     loadBaseNode *n1 = new loadBaseNode();
6813     n1-&gt;add_req(NULL);
6814     n1-&gt;_opnds[0] = op_dst;
6815 
6816     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
6817     n_compare-&gt;add_req(n_region, n_src);
6818     n_compare-&gt;_opnds[0] = op_crx;
6819     n_compare-&gt;_opnds[1] = op_src;
6820     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
6821 
6822     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
6823     n2-&gt;add_req(n_region, n_src, n1);
6824     n2-&gt;_opnds[0] = op_dst;
6825     n2-&gt;_opnds[1] = op_src;
6826     n2-&gt;_opnds[2] = op_dst;
6827     n2-&gt;_bottom_type = _bottom_type;
6828 
6829     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
6830     n_cond_set-&gt;add_req(n_region, n_compare, n2);
6831     n_cond_set-&gt;_opnds[0] = op_dst;
6832     n_cond_set-&gt;_opnds[1] = op_crx;
6833     n_cond_set-&gt;_opnds[2] = op_dst;
6834     n_cond_set-&gt;_bottom_type = _bottom_type;
6835 
6836     assert(ra_-&gt;is_oop(this) == true, "A decodeN node must produce an oop!");
6837     ra_-&gt;set_oop(n_cond_set, true);
6838 
6839     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6840     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
6841     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6842     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6843 
6844     nodes-&gt;push(n1);
6845     nodes-&gt;push(n_compare);
6846     nodes-&gt;push(n2);
6847     nodes-&gt;push(n_cond_set);
6848   %}
6849 %}
6850 
6851 // src != 0, shift != 0, base != 0
6852 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
6853   match(Set dst (DecodeN src));
6854   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
6855              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
6856             Universe::narrow_oop_shift() != 0 &amp;&amp;
6857             Universe::narrow_oop_base() != 0);
6858   ins_cost(2 * DEFAULT_COST);
6859 
6860   format %{ "DecodeN $dst, $src \t// $src != NULL, postalloc expanded" %}
6861   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
6862 %}
6863 
6864 // Compressed OOPs with narrow_oop_shift == 0.
6865 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
6866   match(Set dst (DecodeN src));
6867   predicate(Universe::narrow_oop_shift() == 0);
6868   ins_cost(DEFAULT_COST);
6869 
6870   format %{ "MR      $dst, $src \t// DecodeN (unscaled)" %}
6871   // variable size, 0 or 4.
6872   ins_encode %{
6873     // TODO: PPC port $archOpcode(ppc64Opcode_or);
6874     __ mr_if_needed($dst$$Register, $src$$Register);
6875   %}
6876   ins_pipe(pipe_class_default);
6877 %}
6878 
6879 // Convert compressed oop into int for vectors alignment masking.
6880 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
6881   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6882   predicate(Universe::narrow_oop_shift() == 0);
6883   ins_cost(DEFAULT_COST);
6884 
6885   format %{ "MR      $dst, $src \t// (int)DecodeN (unscaled)" %}
6886   // variable size, 0 or 4.
6887   ins_encode %{
6888     // TODO: PPC port $archOpcode(ppc64Opcode_or);
6889     __ mr_if_needed($dst$$Register, $src$$Register);
6890   %}
6891   ins_pipe(pipe_class_default);
6892 %}
6893 
6894 // Convert klass pointer into compressed form.
6895 
6896 // Nodes for postalloc expand.
6897 
6898 // Shift node for expand.
6899 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
6900   // The match rule is needed to make it a 'MachTypeNode'!
6901   match(Set dst (EncodePKlass src));
6902   predicate(false);
6903 
6904   format %{ "SRDI    $dst, $src, 3 \t// encode" %}
6905   size(4);
6906   ins_encode %{
6907     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6908     __ srdi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());
6909   %}
6910   ins_pipe(pipe_class_default);
6911 %}
6912 
6913 // Add node for expand.
6914 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
6915   // The match rule is needed to make it a 'MachTypeNode'!
6916   match(Set dst (EncodePKlass (Binary base src)));
6917   predicate(false);
6918 
6919   format %{ "SUB     $dst, $base, $src \t// encode" %}
6920   size(4);
6921   ins_encode %{
6922     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
6923     __ subf($dst$$Register, $base$$Register, $src$$Register);
6924   %}
6925   ins_pipe(pipe_class_default);
6926 %}
6927 
6928 // Disjoint narrow oop base.
6929 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
6930   match(Set dst (EncodePKlass src));
6931   predicate(false /* TODO: PPC port Universe::narrow_klass_base_disjoint()*/);
6932 
6933   format %{ "EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base" %}
6934   size(4);
6935   ins_encode %{
6936     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
6937     __ rldicl($dst$$Register, $src$$Register, 64-Universe::narrow_klass_shift(), 32);
6938   %}
6939   ins_pipe(pipe_class_default);
6940 %}
6941 
6942 // shift != 0, base != 0
6943 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
6944   match(Set dst (EncodePKlass (Binary base src)));
6945   predicate(false);
6946 
6947   format %{ "EncodePKlass $dst, $src\t// $src != Null, postalloc expanded" %}
6948   postalloc_expand %{
6949     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
6950     n1-&gt;add_req(n_region, n_base, n_src);
6951     n1-&gt;_opnds[0] = op_dst;
6952     n1-&gt;_opnds[1] = op_base;
6953     n1-&gt;_opnds[2] = op_src;
6954     n1-&gt;_bottom_type = _bottom_type;
6955 
6956     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
6957     n2-&gt;add_req(n_region, n1);
6958     n2-&gt;_opnds[0] = op_dst;
6959     n2-&gt;_opnds[1] = op_dst;
6960     n2-&gt;_bottom_type = _bottom_type;
6961     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6962     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
6963 
6964     nodes-&gt;push(n1);
6965     nodes-&gt;push(n2);
6966   %}
6967 %}
6968 
6969 // shift != 0, base != 0
6970 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
6971   match(Set dst (EncodePKlass src));
6972   //predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;
6973   //          true /* TODO: PPC port Universe::narrow_klass_base_overlaps()*/);
6974 
6975   //format %{ "EncodePKlass $dst, $src\t// $src != Null, postalloc expanded" %}
6976   ins_cost(DEFAULT_COST*2);  // Don't count constant.
6977   expand %{
6978     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_klass_base() %}
6979     iRegLdst base;
6980     loadConL_Ex(base, baseImm);
6981     encodePKlass_not_null_Ex(dst, base, src);
6982   %}
6983 %}
6984 
6985 // Decode nodes.
6986 
6987 // Shift node for expand.
6988 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
6989   // The match rule is needed to make it a 'MachTypeNode'!
6990   match(Set dst (DecodeNKlass src));
6991   predicate(false);
6992 
6993   format %{ "SLDI    $dst, $src, #3 \t// DecodeNKlass" %}
6994   size(4);
6995   ins_encode %{
6996     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
6997     __ sldi($dst$$Register, $src$$Register, Universe::narrow_klass_shift());
6998   %}
6999   ins_pipe(pipe_class_default);
7000 %}
7001 
7002 // Add node for expand.
7003 
7004 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
7005   // The match rule is needed to make it a 'MachTypeNode'!
7006   match(Set dst (DecodeNKlass (Binary base src)));
7007   predicate(false);
7008 
7009   format %{ "ADD     $dst, $base, $src \t// DecodeNKlass, add klass base" %}
7010   size(4);
7011   ins_encode %{
7012     // TODO: PPC port $archOpcode(ppc64Opcode_add);
7013     __ add($dst$$Register, $base$$Register, $src$$Register);
7014   %}
7015   ins_pipe(pipe_class_default);
7016 %}
7017 
7018 // src != 0, shift != 0, base != 0
7019 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
7020   match(Set dst (DecodeNKlass (Binary base src)));
7021   //effect(kill src); // We need a register for the immediate result after shifting.
7022   predicate(false);
7023 
7024   format %{ "DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded" %}
7025   postalloc_expand %{
7026     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
7027     n1-&gt;add_req(n_region, n_base, n_src);
7028     n1-&gt;_opnds[0] = op_dst;
7029     n1-&gt;_opnds[1] = op_base;
7030     n1-&gt;_opnds[2] = op_src;
7031     n1-&gt;_bottom_type = _bottom_type;
7032 
7033     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
7034     n2-&gt;add_req(n_region, n1);
7035     n2-&gt;_opnds[0] = op_dst;
7036     n2-&gt;_opnds[1] = op_dst;
7037     n2-&gt;_bottom_type = _bottom_type;
7038 
7039     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
7040     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
7041 
7042     nodes-&gt;push(n1);
7043     nodes-&gt;push(n2);
7044   %}
7045 %}
7046 
7047 // src != 0, shift != 0, base != 0
7048 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
7049   match(Set dst (DecodeNKlass src));
7050   // predicate(Universe::narrow_klass_shift() != 0 &amp;&amp;
7051   //           Universe::narrow_klass_base() != 0);
7052 
7053   //format %{ "DecodeNKlass $dst, $src \t// $src != NULL, expanded" %}
7054 
7055   ins_cost(DEFAULT_COST*2);  // Don't count constant.
7056   expand %{
7057     // We add first, then we shift. Like this, we can get along with one register less.
7058     // But we have to load the base pre-shifted.
7059     immL baseImm %{ (jlong)((intptr_t)Universe::narrow_klass_base() &gt;&gt; Universe::narrow_klass_shift()) %}
7060     iRegLdst base;
7061     loadConL_Ex(base, baseImm);
7062     decodeNKlass_notNull_addBase_Ex(dst, base, src);
7063   %}
7064 %}
7065 
7066 //----------MemBar Instructions-----------------------------------------------
7067 // Memory barrier flavors
7068 
7069 instruct membar_acquire() %{
7070   match(LoadFence);
7071   ins_cost(4*MEMORY_REF_COST);
7072 
7073   format %{ "MEMBAR-acquire" %}
7074   size(4);
7075   ins_encode %{
7076     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
7077     __ acquire();
7078   %}
7079   ins_pipe(pipe_class_default);
7080 %}
7081 
7082 instruct unnecessary_membar_acquire() %{
7083   match(MemBarAcquire);
7084   ins_cost(0);
7085 
7086   format %{ " -- \t// redundant MEMBAR-acquire - empty" %}
7087   size(0);
7088   ins_encode( /*empty*/ );
7089   ins_pipe(pipe_class_default);
7090 %}
7091 
7092 instruct membar_acquire_lock() %{
7093   match(MemBarAcquireLock);
7094   ins_cost(0);
7095 
7096   format %{ " -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)" %}
7097   size(0);
7098   ins_encode( /*empty*/ );
7099   ins_pipe(pipe_class_default);
7100 %}
7101 
7102 instruct membar_release() %{
7103   match(MemBarRelease);
7104   match(StoreFence);
7105   ins_cost(4*MEMORY_REF_COST);
7106 
7107   format %{ "MEMBAR-release" %}
7108   size(4);
7109   ins_encode %{
7110     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
7111     __ release();
7112   %}
7113   ins_pipe(pipe_class_default);
7114 %}
7115 
7116 instruct membar_storestore() %{
7117   match(MemBarStoreStore);
7118   ins_cost(4*MEMORY_REF_COST);
7119 
7120   format %{ "MEMBAR-store-store" %}
7121   size(4);
7122   ins_encode %{
7123     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
7124     __ membar(Assembler::StoreStore);
7125   %}
7126   ins_pipe(pipe_class_default);
7127 %}
7128 
7129 instruct membar_release_lock() %{
7130   match(MemBarReleaseLock);
7131   ins_cost(0);
7132 
7133   format %{ " -- \t// redundant MEMBAR-release - empty (release in FastUnlock)" %}
7134   size(0);
7135   ins_encode( /*empty*/ );
7136   ins_pipe(pipe_class_default);
7137 %}
7138 
7139 instruct membar_volatile() %{
7140   match(MemBarVolatile);
7141   ins_cost(4*MEMORY_REF_COST);
7142 
7143   format %{ "MEMBAR-volatile" %}
7144   size(4);
7145   ins_encode %{
7146     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
7147     __ fence();
7148   %}
7149   ins_pipe(pipe_class_default);
7150 %}
7151 
7152 // This optimization is wrong on PPC. The following pattern is not supported:
7153 //  MemBarVolatile
7154 //   ^        ^
7155 //   |        |
7156 //  CtrlProj MemProj
7157 //   ^        ^
7158 //   |        |
7159 //   |       Load
7160 //   |
7161 //  MemBarVolatile
7162 //
7163 //  The first MemBarVolatile could get optimized out! According to
7164 //  Vladimir, this pattern can not occur on Oracle platforms.
7165 //  However, it does occur on PPC64 (because of membars in
7166 //  inline_unsafe_load_store).
7167 //
7168 // Add this node again if we found a good solution for inline_unsafe_load_store().
7169 // Don't forget to look at the implementation of post_store_load_barrier again,
7170 // we did other fixes in that method.
7171 //instruct unnecessary_membar_volatile() %{
7172 //  match(MemBarVolatile);
7173 //  predicate(Matcher::post_store_load_barrier(n));
7174 //  ins_cost(0);
7175 //
7176 //  format %{ " -- \t// redundant MEMBAR-volatile - empty" %}
7177 //  size(0);
7178 //  ins_encode( /*empty*/ );
7179 //  ins_pipe(pipe_class_default);
7180 //%}
7181 
7182 instruct membar_CPUOrder() %{
7183   match(MemBarCPUOrder);
7184   ins_cost(0);
7185 
7186   format %{ " -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent." %}
7187   size(0);
7188   ins_encode( /*empty*/ );
7189   ins_pipe(pipe_class_default);
7190 %}
7191 
7192 //----------Conditional Move---------------------------------------------------
7193 
7194 // Cmove using isel.
7195 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
7196   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
7197   predicate(VM_Version::has_isel());
7198   ins_cost(DEFAULT_COST);
7199 
7200   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7201   size(4);
7202   ins_encode %{
7203     // This is a Power7 instruction for which no machine description
7204     // exists. Anyways, the scheduler should be off on Power7.
7205     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7206     int cc        = $cmp$$cmpcode;
7207     __ isel($dst$$Register, $crx$$CondRegister,
7208             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7209   %}
7210   ins_pipe(pipe_class_default);
7211 %}
7212 
7213 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
7214   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
7215   predicate(!VM_Version::has_isel());
7216   ins_cost(DEFAULT_COST+BRANCH_COST);
7217 
7218   ins_variable_size_depending_on_alignment(true);
7219 
7220   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7221   // Worst case is branch + move + stop, no stop without scheduler
7222   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7223   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7224   ins_pipe(pipe_class_default);
7225 %}
7226 
7227 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
7228   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
7229   ins_cost(DEFAULT_COST+BRANCH_COST);
7230 
7231   ins_variable_size_depending_on_alignment(true);
7232 
7233   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7234   // Worst case is branch + move + stop, no stop without scheduler
7235   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7236   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7237   ins_pipe(pipe_class_default);
7238 %}
7239 
7240 // Cmove using isel.
7241 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
7242   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
7243   predicate(VM_Version::has_isel());
7244   ins_cost(DEFAULT_COST);
7245 
7246   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7247   size(4);
7248   ins_encode %{
7249     // This is a Power7 instruction for which no machine description
7250     // exists. Anyways, the scheduler should be off on Power7.
7251     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7252     int cc        = $cmp$$cmpcode;
7253     __ isel($dst$$Register, $crx$$CondRegister,
7254             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7255   %}
7256   ins_pipe(pipe_class_default);
7257 %}
7258 
7259 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
7260   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
7261   predicate(!VM_Version::has_isel());
7262   ins_cost(DEFAULT_COST+BRANCH_COST);
7263 
7264   ins_variable_size_depending_on_alignment(true);
7265 
7266   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7267   // Worst case is branch + move + stop, no stop without scheduler.
7268   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7269   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7270   ins_pipe(pipe_class_default);
7271 %}
7272 
7273 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
7274   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
7275   ins_cost(DEFAULT_COST+BRANCH_COST);
7276 
7277   ins_variable_size_depending_on_alignment(true);
7278 
7279   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7280   // Worst case is branch + move + stop, no stop without scheduler.
7281   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7282   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7283   ins_pipe(pipe_class_default);
7284 %}
7285 
7286 // Cmove using isel.
7287 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
7288   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
7289   predicate(VM_Version::has_isel());
7290   ins_cost(DEFAULT_COST);
7291 
7292   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7293   size(4);
7294   ins_encode %{
7295     // This is a Power7 instruction for which no machine description
7296     // exists. Anyways, the scheduler should be off on Power7.
7297     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7298     int cc        = $cmp$$cmpcode;
7299     __ isel($dst$$Register, $crx$$CondRegister,
7300             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7301   %}
7302   ins_pipe(pipe_class_default);
7303 %}
7304 
7305 // Conditional move for RegN. Only cmov(reg, reg).
7306 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
7307   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
7308   predicate(!VM_Version::has_isel());
7309   ins_cost(DEFAULT_COST+BRANCH_COST);
7310 
7311   ins_variable_size_depending_on_alignment(true);
7312 
7313   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7314   // Worst case is branch + move + stop, no stop without scheduler.
7315   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7316   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7317   ins_pipe(pipe_class_default);
7318 %}
7319 
7320 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
7321   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
7322   ins_cost(DEFAULT_COST+BRANCH_COST);
7323 
7324   ins_variable_size_depending_on_alignment(true);
7325 
7326   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7327   // Worst case is branch + move + stop, no stop without scheduler.
7328   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7329   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7330   ins_pipe(pipe_class_default);
7331 %}
7332 
7333 // Cmove using isel.
7334 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
7335   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
7336   predicate(VM_Version::has_isel());
7337   ins_cost(DEFAULT_COST);
7338 
7339   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7340   size(4);
7341   ins_encode %{
7342     // This is a Power7 instruction for which no machine description
7343     // exists. Anyways, the scheduler should be off on Power7.
7344     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7345     int cc        = $cmp$$cmpcode;
7346     __ isel($dst$$Register, $crx$$CondRegister,
7347             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
7348   %}
7349   ins_pipe(pipe_class_default);
7350 %}
7351 
7352 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
7353   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
7354   predicate(!VM_Version::has_isel());
7355   ins_cost(DEFAULT_COST+BRANCH_COST);
7356 
7357   ins_variable_size_depending_on_alignment(true);
7358 
7359   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7360   // Worst case is branch + move + stop, no stop without scheduler.
7361   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7362   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
7363   ins_pipe(pipe_class_default);
7364 %}
7365 
7366 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
7367   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
7368   ins_cost(DEFAULT_COST+BRANCH_COST);
7369 
7370   ins_variable_size_depending_on_alignment(true);
7371 
7372   format %{ "CMOVE   $cmp, $crx, $dst, $src\n\t" %}
7373   // Worst case is branch + move + stop, no stop without scheduler.
7374   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
7375   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
7376   ins_pipe(pipe_class_default);
7377 %}
7378 
7379 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
7380   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
7381   ins_cost(DEFAULT_COST+BRANCH_COST);
7382 
7383   ins_variable_size_depending_on_alignment(true);
7384 
7385   format %{ "CMOVEF  $cmp, $crx, $dst, $src\n\t" %}
7386   // Worst case is branch + move + stop, no stop without scheduler.
7387   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
7388   ins_encode %{
7389     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
7390     Label done;
7391     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
7392     // Branch if not (cmp crx).
7393     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
7394     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
7395     // TODO PPC port __ endgroup_if_needed(_size == 12);
7396     __ bind(done);
7397   %}
7398   ins_pipe(pipe_class_default);
7399 %}
7400 
7401 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
7402   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
7403   ins_cost(DEFAULT_COST+BRANCH_COST);
7404 
7405   ins_variable_size_depending_on_alignment(true);
7406 
7407   format %{ "CMOVEF  $cmp, $crx, $dst, $src\n\t" %}
7408   // Worst case is branch + move + stop, no stop without scheduler.
7409   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
7410   ins_encode %{
7411     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
7412     Label done;
7413     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, "check encoding");
7414     // Branch if not (cmp crx).
7415     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
7416     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
7417     // TODO PPC port __ endgroup_if_needed(_size == 12);
7418     __ bind(done);
7419   %}
7420   ins_pipe(pipe_class_default);
7421 %}
7422 
7423 //----------Conditional_store--------------------------------------------------
7424 // Conditional-store of the updated heap-top.
7425 // Used during allocation of the shared heap.
7426 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
7427 
7428 // As compareAndSwapL, but return flag register instead of boolean value in
7429 // int register.
7430 // Used by sun/misc/AtomicLongCSImpl.java.
7431 // Mem_ptr must be a memory operand, else this node does not get
7432 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
7433 // can be rematerialized which leads to errors.
7434 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
7435   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
7436   effect(TEMP cr0);
7437   format %{ "CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool" %}
7438   ins_encode %{
7439     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7440     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
7441                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
7442                 noreg, NULL, true);
7443   %}
7444   ins_pipe(pipe_class_default);
7445 %}
7446 
7447 // As compareAndSwapP, but return flag register instead of boolean value in
7448 // int register.
7449 // This instruction is matched if UseTLAB is off.
7450 // Mem_ptr must be a memory operand, else this node does not get
7451 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
7452 // can be rematerialized which leads to errors.
7453 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
7454   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
7455   ins_cost(2*MEMORY_REF_COST);
7456 
7457   format %{ "STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool" %}
7458   ins_encode %{
7459     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
7460     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
7461   %}
7462   ins_pipe(pipe_class_memory);
7463 %}
7464 
7465 // Implement LoadPLocked. Must be ordered against changes of the memory location
7466 // by storePConditional.
7467 // Don't know whether this is ever used.
7468 instruct loadPLocked(iRegPdst dst, memory mem) %{
7469   match(Set dst (LoadPLocked mem));
7470   ins_cost(2*MEMORY_REF_COST);
7471 
7472   format %{ "LDARX   $dst, $mem \t// loadPLocked\n\t" %}
7473   size(4);
7474   ins_encode %{
7475     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
7476     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
7477   %}
7478   ins_pipe(pipe_class_memory);
7479 %}
7480 
7481 //----------Compare-And-Swap---------------------------------------------------
7482 
7483 // CompareAndSwap{P,I,L} have more than one output, therefore "CmpI
7484 // (CompareAndSwap ...)" or "If (CmpI (CompareAndSwap ..))"  cannot be
7485 // matched.
7486 
7487 // Strong versions:
7488 
7489 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7490   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
7491   predicate(VM_Version::has_lqarx());
7492   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7493   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7494   ins_encode %{
7495     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7496     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7497     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7498                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7499                 $res$$Register, true);
7500     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7501       __ isync();
7502     } else {
7503       __ sync();
7504     }
7505   %}
7506   ins_pipe(pipe_class_default);
7507 %}
7508 
7509 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7510   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
7511   predicate(!VM_Version::has_lqarx());
7512   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7513   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7514   ins_encode %{
7515     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7516     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7517     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7518                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7519                 $res$$Register, true);
7520     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7521       __ isync();
7522     } else {
7523       __ sync();
7524     }
7525   %}
7526   ins_pipe(pipe_class_default);
7527 %}
7528 
7529 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7530   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
7531   predicate(VM_Version::has_lqarx());
7532   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7533   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7534   ins_encode %{
7535     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7536     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7537     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7538                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7539                 $res$$Register, true);
7540     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7541       __ isync();
7542     } else {
7543       __ sync();
7544     }
7545   %}
7546   ins_pipe(pipe_class_default);
7547 %}
7548 
7549 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7550   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
7551   predicate(!VM_Version::has_lqarx());
7552   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7553   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7554   ins_encode %{
7555     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7556     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7557     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7558                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7559                 $res$$Register, true);
7560     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7561       __ isync();
7562     } else {
7563       __ sync();
7564     }
7565   %}
7566   ins_pipe(pipe_class_default);
7567 %}
7568 
7569 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7570   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
7571   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7572   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7573   ins_encode %{
7574     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7575     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7576     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7577                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7578                 $res$$Register, true);
7579     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7580       __ isync();
7581     } else {
7582       __ sync();
7583     }
7584   %}
7585   ins_pipe(pipe_class_default);
7586 %}
7587 
7588 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
7589   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
7590   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7591   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7592   ins_encode %{
7593     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7594     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7595     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7596                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7597                 $res$$Register, true);
7598     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7599       __ isync();
7600     } else {
7601       __ sync();
7602     }
7603   %}
7604   ins_pipe(pipe_class_default);
7605 %}
7606 
7607 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
7608   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
7609   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7610   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool" %}
7611   ins_encode %{
7612     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7613     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7614     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7615                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7616                 $res$$Register, NULL, true);
7617     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7618       __ isync();
7619     } else {
7620       __ sync();
7621     }
7622   %}
7623   ins_pipe(pipe_class_default);
7624 %}
7625 
7626 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
7627   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
7628   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7629   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr" %}
7630   ins_encode %{
7631     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7632     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7633     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7634                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7635                 $res$$Register, NULL, true);
7636     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7637       __ isync();
7638     } else {
7639       __ sync();
7640     }
7641   %}
7642   ins_pipe(pipe_class_default);
7643 %}
7644 
7645 // Weak versions:
7646 
7647 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7648   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7649   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7650   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7651   format %{ "weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7652   ins_encode %{
7653     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7654     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7655     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7656                 MacroAssembler::MemBarNone,
7657                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7658   %}
7659   ins_pipe(pipe_class_default);
7660 %}
7661 
7662 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7663   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7664   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7665   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7666   format %{ "weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool" %}
7667   ins_encode %{
7668     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7669     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7670     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7671                 MacroAssembler::MemBarNone,
7672                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7673   %}
7674   ins_pipe(pipe_class_default);
7675 %}
7676 
7677 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7678   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7679   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7680   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7681   format %{ "weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool" %}
7682   ins_encode %{
7683     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7684     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7685     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7686                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7687                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7688   %}
7689   ins_pipe(pipe_class_default);
7690 %}
7691 
7692 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7693   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
7694   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7695   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7696   format %{ "weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool" %}
7697   ins_encode %{
7698     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7699     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7700     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7701                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7702                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7703   %}
7704   ins_pipe(pipe_class_default);
7705 %}
7706 
7707 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7708   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7709   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7710   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7711   format %{ "weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7712   ins_encode %{
7713     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7714     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7715     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7716                 MacroAssembler::MemBarNone,
7717                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7718   %}
7719   ins_pipe(pipe_class_default);
7720 %}
7721 
7722 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7723   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7724   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7725   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7726   format %{ "weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool" %}
7727   ins_encode %{
7728     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7729     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7730     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7731                 MacroAssembler::MemBarNone,
7732                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7733   %}
7734   ins_pipe(pipe_class_default);
7735 %}
7736 
7737 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7738   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7739   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7740   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7741   format %{ "weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool" %}
7742   ins_encode %{
7743     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7744     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7745     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7746                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7747                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7748   %}
7749   ins_pipe(pipe_class_default);
7750 %}
7751 
7752 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
7753   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
7754   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7755   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
7756   format %{ "weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool" %}
7757   ins_encode %{
7758     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7759     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7760     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
7761                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7762                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7763   %}
7764   ins_pipe(pipe_class_default);
7765 %}
7766 
7767 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7768   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
7769   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7770   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7771   format %{ "weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7772   ins_encode %{
7773     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7774     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7775     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7776                 MacroAssembler::MemBarNone,
7777                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7778   %}
7779   ins_pipe(pipe_class_default);
7780 %}
7781 
7782 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7783   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
7784   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7785   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7786   format %{ "weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool" %}
7787   ins_encode %{
7788     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7789     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7790     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7791     // value is never passed to caller.
7792     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7793                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7794                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7795   %}
7796   ins_pipe(pipe_class_default);
7797 %}
7798 
7799 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
7800   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
7801   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7802   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7803   format %{ "weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool" %}
7804   ins_encode %{
7805     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7806     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7807     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7808                 MacroAssembler::MemBarNone,
7809                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7810   %}
7811   ins_pipe(pipe_class_default);
7812 %}
7813 
7814 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
7815   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
7816   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7817   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7818   format %{ "weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool" %}
7819   ins_encode %{
7820     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7821     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7822     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7823     // value is never passed to caller.
7824     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7825                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7826                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
7827   %}
7828   ins_pipe(pipe_class_default);
7829 %}
7830 
7831 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
7832   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
7833   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7834   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7835   format %{ "weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool" %}
7836   ins_encode %{
7837     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7838     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7839     // value is never passed to caller.
7840     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7841                 MacroAssembler::MemBarNone,
7842                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7843   %}
7844   ins_pipe(pipe_class_default);
7845 %}
7846 
7847 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
7848   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
7849   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7850   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7851   format %{ "weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool" %}
7852   ins_encode %{
7853     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7854     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7855     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7856     // value is never passed to caller.
7857     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7858                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7859                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7860   %}
7861   ins_pipe(pipe_class_default);
7862 %}
7863 
7864 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
7865   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
7866   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
7867   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7868   format %{ "weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr" %}
7869   ins_encode %{
7870     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7871     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7872     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7873                 MacroAssembler::MemBarNone,
7874                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7875   %}
7876   ins_pipe(pipe_class_default);
7877 %}
7878 
7879 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
7880   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
7881   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
7882   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
7883   format %{ "weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr" %}
7884   ins_encode %{
7885     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7886     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7887     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
7888     // value is never passed to caller.
7889     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
7890                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
7891                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
7892   %}
7893   ins_pipe(pipe_class_default);
7894 %}
7895 
7896 // CompareAndExchange
7897 
7898 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7899   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7900   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7901   effect(TEMP_DEF res, TEMP cr0);
7902   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as int" %}
7903   ins_encode %{
7904     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7905     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7906     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7907                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7908                 noreg, true);
7909   %}
7910   ins_pipe(pipe_class_default);
7911 %}
7912 
7913 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7914   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7915   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7916   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7917   format %{ "CMPXCHGB $res, $mem_ptr, $src1, $src2; as int" %}
7918   ins_encode %{
7919     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7920     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7921     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7922                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7923                 noreg, true);
7924   %}
7925   ins_pipe(pipe_class_default);
7926 %}
7927 
7928 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7929   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7930   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
7931   effect(TEMP_DEF res, TEMP cr0);
7932   format %{ "CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int" %}
7933   ins_encode %{
7934     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7935     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7936     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7937                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7938                 noreg, true);
7939     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7940       __ isync();
7941     } else {
7942       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
7943       __ sync();
7944     }
7945   %}
7946   ins_pipe(pipe_class_default);
7947 %}
7948 
7949 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7950   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
7951   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
7952   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7953   format %{ "CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int" %}
7954   ins_encode %{
7955     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7956     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7957     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7958                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7959                 noreg, true);
7960     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
7961       __ isync();
7962     } else {
7963       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
7964       __ sync();
7965     }
7966   %}
7967   ins_pipe(pipe_class_default);
7968 %}
7969 
7970 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
7971   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
7972   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
7973   effect(TEMP_DEF res, TEMP cr0);
7974   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as int" %}
7975   ins_encode %{
7976     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7977     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7978     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
7979                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7980                 noreg, true);
7981   %}
7982   ins_pipe(pipe_class_default);
7983 %}
7984 
7985 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
7986   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
7987   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
7988   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
7989   format %{ "CMPXCHGH $res, $mem_ptr, $src1, $src2; as int" %}
7990   ins_encode %{
7991     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
7992     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
7993     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
7994                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
7995                 noreg, true);
7996   %}
7997   ins_pipe(pipe_class_default);
7998 %}
7999 
8000 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
8001   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
8002   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
8003   effect(TEMP_DEF res, TEMP cr0);
8004   format %{ "CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int" %}
8005   ins_encode %{
8006     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8007     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8008     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
8009                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8010                 noreg, true);
8011     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8012       __ isync();
8013     } else {
8014       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8015       __ sync();
8016     }
8017   %}
8018   ins_pipe(pipe_class_default);
8019 %}
8020 
8021 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
8022   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
8023   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
8024   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
8025   format %{ "CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int" %}
8026   ins_encode %{
8027     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8028     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8029     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
8030                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8031                 noreg, true);
8032     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8033       __ isync();
8034     } else {
8035       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8036       __ sync();
8037     }
8038   %}
8039   ins_pipe(pipe_class_default);
8040 %}
8041 
8042 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
8043   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
8044   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8045   effect(TEMP_DEF res, TEMP cr0);
8046   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as int" %}
8047   ins_encode %{
8048     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8049     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8050     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8051                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8052                 noreg, true);
8053   %}
8054   ins_pipe(pipe_class_default);
8055 %}
8056 
8057 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
8058   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
8059   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8060   effect(TEMP_DEF res, TEMP cr0);
8061   format %{ "CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int" %}
8062   ins_encode %{
8063     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8064     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8065     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8066                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8067                 noreg, true);
8068     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8069       __ isync();
8070     } else {
8071       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8072       __ sync();
8073     }
8074   %}
8075   ins_pipe(pipe_class_default);
8076 %}
8077 
8078 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
8079   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
8080   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8081   effect(TEMP_DEF res, TEMP cr0);
8082   format %{ "CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop" %}
8083   ins_encode %{
8084     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8085     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8086     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8087                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8088                 noreg, true);
8089   %}
8090   ins_pipe(pipe_class_default);
8091 %}
8092 
8093 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
8094   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
8095   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8096   effect(TEMP_DEF res, TEMP cr0);
8097   format %{ "CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop" %}
8098   ins_encode %{
8099     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8100     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8101     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8102                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8103                 noreg, true);
8104     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8105       __ isync();
8106     } else {
8107       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8108       __ sync();
8109     }
8110   %}
8111   ins_pipe(pipe_class_default);
8112 %}
8113 
8114 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
8115   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
8116   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8117   effect(TEMP_DEF res, TEMP cr0);
8118   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as long" %}
8119   ins_encode %{
8120     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8121     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8122     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8123                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8124                 noreg, NULL, true);
8125   %}
8126   ins_pipe(pipe_class_default);
8127 %}
8128 
8129 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
8130   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
8131   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8132   effect(TEMP_DEF res, TEMP cr0);
8133   format %{ "CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long" %}
8134   ins_encode %{
8135     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8136     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8137     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8138                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8139                 noreg, NULL, true);
8140     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8141       __ isync();
8142     } else {
8143       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8144       __ sync();
8145     }
8146   %}
8147   ins_pipe(pipe_class_default);
8148 %}
8149 
8150 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
8151   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
8152   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
8153   effect(TEMP_DEF res, TEMP cr0);
8154   format %{ "CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr" %}
8155   ins_encode %{
8156     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8157     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8158     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8159                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8160                 noreg, NULL, true);
8161   %}
8162   ins_pipe(pipe_class_default);
8163 %}
8164 
8165 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
8166   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
8167   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
8168   effect(TEMP_DEF res, TEMP cr0);
8169   format %{ "CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr" %}
8170   ins_encode %{
8171     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
8172     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to 'true'/'false'.
8173     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
8174                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
8175                 noreg, NULL, true);
8176     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8177       __ isync();
8178     } else {
8179       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.
8180       __ sync();
8181     }
8182   %}
8183   ins_pipe(pipe_class_default);
8184 %}
8185 
8186 // Special RMW
8187 
8188 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8189   match(Set res (GetAndAddB mem_ptr src));
8190   predicate(VM_Version::has_lqarx());
8191   effect(TEMP_DEF res, TEMP cr0);
8192   format %{ "GetAndAddB $res, $mem_ptr, $src" %}
8193   ins_encode %{
8194     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
8195                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8196     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8197       __ isync();
8198     } else {
8199       __ sync();
8200     }
8201   %}
8202   ins_pipe(pipe_class_default);
8203 %}
8204 
8205 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8206   match(Set res (GetAndAddB mem_ptr src));
8207   predicate(!VM_Version::has_lqarx());
8208   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8209   format %{ "GetAndAddB $res, $mem_ptr, $src" %}
8210   ins_encode %{
8211     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
8212                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8213     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8214       __ isync();
8215     } else {
8216       __ sync();
8217     }
8218   %}
8219   ins_pipe(pipe_class_default);
8220 %}
8221 
8222 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8223   match(Set res (GetAndAddS mem_ptr src));
8224   predicate(VM_Version::has_lqarx());
8225   effect(TEMP_DEF res, TEMP cr0);
8226   format %{ "GetAndAddS $res, $mem_ptr, $src" %}
8227   ins_encode %{
8228     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
8229                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8230     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8231       __ isync();
8232     } else {
8233       __ sync();
8234     }
8235   %}
8236   ins_pipe(pipe_class_default);
8237 %}
8238 
8239 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8240   match(Set res (GetAndAddS mem_ptr src));
8241   predicate(!VM_Version::has_lqarx());
8242   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8243   format %{ "GetAndAddS $res, $mem_ptr, $src" %}
8244   ins_encode %{
8245     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
8246                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8247     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8248       __ isync();
8249     } else {
8250       __ sync();
8251     }
8252   %}
8253   ins_pipe(pipe_class_default);
8254 %}
8255 
8256 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8257   match(Set res (GetAndAddI mem_ptr src));
8258   effect(TEMP_DEF res, TEMP cr0);
8259   format %{ "GetAndAddI $res, $mem_ptr, $src" %}
8260   ins_encode %{
8261     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
8262                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
8263     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8264       __ isync();
8265     } else {
8266       __ sync();
8267     }
8268   %}
8269   ins_pipe(pipe_class_default);
8270 %}
8271 
8272 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
8273   match(Set res (GetAndAddL mem_ptr src));
8274   effect(TEMP_DEF res, TEMP cr0);
8275   format %{ "GetAndAddL $res, $mem_ptr, $src" %}
8276   ins_encode %{
8277     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
8278                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
8279     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8280       __ isync();
8281     } else {
8282       __ sync();
8283     }
8284   %}
8285   ins_pipe(pipe_class_default);
8286 %}
8287 
8288 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8289   match(Set res (GetAndSetB mem_ptr src));
8290   predicate(VM_Version::has_lqarx());
8291   effect(TEMP_DEF res, TEMP cr0);
8292   format %{ "GetAndSetB $res, $mem_ptr, $src" %}
8293   ins_encode %{
8294     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
8295                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8296     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8297       __ isync();
8298     } else {
8299       __ sync();
8300     }
8301   %}
8302   ins_pipe(pipe_class_default);
8303 %}
8304 
8305 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8306   match(Set res (GetAndSetB mem_ptr src));
8307   predicate(!VM_Version::has_lqarx());
8308   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8309   format %{ "GetAndSetB $res, $mem_ptr, $src" %}
8310   ins_encode %{
8311     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
8312                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8313     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8314       __ isync();
8315     } else {
8316       __ sync();
8317     }
8318   %}
8319   ins_pipe(pipe_class_default);
8320 %}
8321 
8322 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8323   match(Set res (GetAndSetS mem_ptr src));
8324   predicate(VM_Version::has_lqarx());
8325   effect(TEMP_DEF res, TEMP cr0);
8326   format %{ "GetAndSetS $res, $mem_ptr, $src" %}
8327   ins_encode %{
8328     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
8329                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
8330     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8331       __ isync();
8332     } else {
8333       __ sync();
8334     }
8335   %}
8336   ins_pipe(pipe_class_default);
8337 %}
8338 
8339 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
8340   match(Set res (GetAndSetS mem_ptr src));
8341   predicate(!VM_Version::has_lqarx());
8342   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
8343   format %{ "GetAndSetS $res, $mem_ptr, $src" %}
8344   ins_encode %{
8345     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
8346                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
8347     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8348       __ isync();
8349     } else {
8350       __ sync();
8351     }
8352   %}
8353   ins_pipe(pipe_class_default);
8354 %}
8355 
8356 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
8357   match(Set res (GetAndSetI mem_ptr src));
8358   effect(TEMP_DEF res, TEMP cr0);
8359   format %{ "GetAndSetI $res, $mem_ptr, $src" %}
8360   ins_encode %{
8361     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
8362                   MacroAssembler::cmpxchgx_hint_atomic_update());
8363     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8364       __ isync();
8365     } else {
8366       __ sync();
8367     }
8368   %}
8369   ins_pipe(pipe_class_default);
8370 %}
8371 
8372 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
8373   match(Set res (GetAndSetL mem_ptr src));
8374   effect(TEMP_DEF res, TEMP cr0);
8375   format %{ "GetAndSetL $res, $mem_ptr, $src" %}
8376   ins_encode %{
8377     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
8378                   MacroAssembler::cmpxchgx_hint_atomic_update());
8379     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8380       __ isync();
8381     } else {
8382       __ sync();
8383     }
8384   %}
8385   ins_pipe(pipe_class_default);
8386 %}
8387 
8388 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
8389   match(Set res (GetAndSetP mem_ptr src));
8390   effect(TEMP_DEF res, TEMP cr0);
8391   format %{ "GetAndSetP $res, $mem_ptr, $src" %}
8392   ins_encode %{
8393     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
8394                   MacroAssembler::cmpxchgx_hint_atomic_update());
8395     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8396       __ isync();
8397     } else {
8398       __ sync();
8399     }
8400   %}
8401   ins_pipe(pipe_class_default);
8402 %}
8403 
8404 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
8405   match(Set res (GetAndSetN mem_ptr src));
8406   effect(TEMP_DEF res, TEMP cr0);
8407   format %{ "GetAndSetN $res, $mem_ptr, $src" %}
8408   ins_encode %{
8409     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
8410                   MacroAssembler::cmpxchgx_hint_atomic_update());
8411     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
8412       __ isync();
8413     } else {
8414       __ sync();
8415     }
8416   %}
8417   ins_pipe(pipe_class_default);
8418 %}
8419 
8420 //----------Arithmetic Instructions--------------------------------------------
8421 // Addition Instructions
8422 
8423 // Register Addition
8424 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
8425   match(Set dst (AddI src1 src2));
8426   format %{ "ADD     $dst, $src1, $src2" %}
8427   size(4);
8428   ins_encode %{
8429     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8430     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8431   %}
8432   ins_pipe(pipe_class_default);
8433 %}
8434 
8435 // Expand does not work with above instruct. (??)
8436 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8437   // no match-rule
8438   effect(DEF dst, USE src1, USE src2);
8439   format %{ "ADD     $dst, $src1, $src2" %}
8440   size(4);
8441   ins_encode %{
8442     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8443     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8444   %}
8445   ins_pipe(pipe_class_default);
8446 %}
8447 
8448 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
8449   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
8450   ins_cost(DEFAULT_COST*3);
8451 
8452   expand %{
8453     // FIXME: we should do this in the ideal world.
8454     iRegIdst tmp1;
8455     iRegIdst tmp2;
8456     addI_reg_reg(tmp1, src1, src2);
8457     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
8458     addI_reg_reg(dst, tmp1, tmp2);
8459   %}
8460 %}
8461 
8462 // Immediate Addition
8463 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
8464   match(Set dst (AddI src1 src2));
8465   format %{ "ADDI    $dst, $src1, $src2" %}
8466   size(4);
8467   ins_encode %{
8468     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
8469     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
8470   %}
8471   ins_pipe(pipe_class_default);
8472 %}
8473 
8474 // Immediate Addition with 16-bit shifted operand
8475 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
8476   match(Set dst (AddI src1 src2));
8477   format %{ "ADDIS   $dst, $src1, $src2" %}
8478   size(4);
8479   ins_encode %{
8480     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
8481     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
8482   %}
8483   ins_pipe(pipe_class_default);
8484 %}
8485 
8486 // Long Addition
8487 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8488   match(Set dst (AddL src1 src2));
8489   format %{ "ADD     $dst, $src1, $src2 \t// long" %}
8490   size(4);
8491   ins_encode %{
8492     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8493     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8494   %}
8495   ins_pipe(pipe_class_default);
8496 %}
8497 
8498 // Expand does not work with above instruct. (??)
8499 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8500   // no match-rule
8501   effect(DEF dst, USE src1, USE src2);
8502   format %{ "ADD     $dst, $src1, $src2 \t// long" %}
8503   size(4);
8504   ins_encode %{
8505     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8506     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8507   %}
8508   ins_pipe(pipe_class_default);
8509 %}
8510 
8511 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
8512   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
8513   ins_cost(DEFAULT_COST*3);
8514 
8515   expand %{
8516     // FIXME: we should do this in the ideal world.
8517     iRegLdst tmp1;
8518     iRegLdst tmp2;
8519     addL_reg_reg(tmp1, src1, src2);
8520     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
8521     addL_reg_reg(dst, tmp1, tmp2);
8522   %}
8523 %}
8524 
8525 // AddL + ConvL2I.
8526 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
8527   match(Set dst (ConvL2I (AddL src1 src2)));
8528 
8529   format %{ "ADD     $dst, $src1, $src2 \t// long + l2i" %}
8530   size(4);
8531   ins_encode %{
8532     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8533     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8534   %}
8535   ins_pipe(pipe_class_default);
8536 %}
8537 
8538 // No constant pool entries required.
8539 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
8540   match(Set dst (AddL src1 src2));
8541 
8542   format %{ "ADDI    $dst, $src1, $src2" %}
8543   size(4);
8544   ins_encode %{
8545     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
8546     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
8547   %}
8548   ins_pipe(pipe_class_default);
8549 %}
8550 
8551 // Long Immediate Addition with 16-bit shifted operand.
8552 // No constant pool entries required.
8553 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
8554   match(Set dst (AddL src1 src2));
8555 
8556   format %{ "ADDIS   $dst, $src1, $src2" %}
8557   size(4);
8558   ins_encode %{
8559     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
8560     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
8561   %}
8562   ins_pipe(pipe_class_default);
8563 %}
8564 
8565 // Pointer Register Addition
8566 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
8567   match(Set dst (AddP src1 src2));
8568   format %{ "ADD     $dst, $src1, $src2" %}
8569   size(4);
8570   ins_encode %{
8571     // TODO: PPC port $archOpcode(ppc64Opcode_add);
8572     __ add($dst$$Register, $src1$$Register, $src2$$Register);
8573   %}
8574   ins_pipe(pipe_class_default);
8575 %}
8576 
8577 // Pointer Immediate Addition
8578 // No constant pool entries required.
8579 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
8580   match(Set dst (AddP src1 src2));
8581 
8582   format %{ "ADDI    $dst, $src1, $src2" %}
8583   size(4);
8584   ins_encode %{
8585     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
8586     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
8587   %}
8588   ins_pipe(pipe_class_default);
8589 %}
8590 
8591 // Pointer Immediate Addition with 16-bit shifted operand.
8592 // No constant pool entries required.
8593 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
8594   match(Set dst (AddP src1 src2));
8595 
8596   format %{ "ADDIS   $dst, $src1, $src2" %}
8597   size(4);
8598   ins_encode %{
8599     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
8600     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
8601   %}
8602   ins_pipe(pipe_class_default);
8603 %}
8604 
8605 //---------------------
8606 // Subtraction Instructions
8607 
8608 // Register Subtraction
8609 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8610   match(Set dst (SubI src1 src2));
8611   format %{ "SUBF    $dst, $src2, $src1" %}
8612   size(4);
8613   ins_encode %{
8614     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
8615     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
8616   %}
8617   ins_pipe(pipe_class_default);
8618 %}
8619 
8620 // Immediate Subtraction
8621 // Immediate Subtraction: The compiler converts "x-c0" into "x+ -c0" (see SubLNode::Ideal),
8622 // Don't try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
8623 
8624 // SubI from constant (using subfic).
8625 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
8626   match(Set dst (SubI src1 src2));
8627   format %{ "SUBI    $dst, $src1, $src2" %}
8628 
8629   size(4);
8630   ins_encode %{
8631     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
8632     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
8633   %}
8634   ins_pipe(pipe_class_default);
8635 %}
8636 
8637 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
8638 // positive integers and 0xF...F for negative ones.
8639 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
8640   // no match-rule, false predicate
8641   effect(DEF dst, USE src);
8642   predicate(false);
8643 
8644   format %{ "SRAWI   $dst, $src, #31" %}
8645   size(4);
8646   ins_encode %{
8647     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
8648     __ srawi($dst$$Register, $src$$Register, 0x1f);
8649   %}
8650   ins_pipe(pipe_class_default);
8651 %}
8652 
8653 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
8654   match(Set dst (AbsI src));
8655   ins_cost(DEFAULT_COST*3);
8656 
8657   expand %{
8658     iRegIdst tmp1;
8659     iRegIdst tmp2;
8660     signmask32I_regI(tmp1, src);
8661     xorI_reg_reg(tmp2, tmp1, src);
8662     subI_reg_reg(dst, tmp2, tmp1);
8663   %}
8664 %}
8665 
8666 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
8667   match(Set dst (SubI zero src2));
8668   format %{ "NEG     $dst, $src2" %}
8669   size(4);
8670   ins_encode %{
8671     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8672     __ neg($dst$$Register, $src2$$Register);
8673   %}
8674   ins_pipe(pipe_class_default);
8675 %}
8676 
8677 // Long subtraction
8678 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8679   match(Set dst (SubL src1 src2));
8680   format %{ "SUBF    $dst, $src2, $src1 \t// long" %}
8681   size(4);
8682   ins_encode %{
8683     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
8684     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
8685   %}
8686   ins_pipe(pipe_class_default);
8687 %}
8688 
8689 // SubL + convL2I.
8690 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
8691   match(Set dst (ConvL2I (SubL src1 src2)));
8692 
8693   format %{ "SUBF    $dst, $src2, $src1 \t// long + l2i" %}
8694   size(4);
8695   ins_encode %{
8696     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
8697     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
8698   %}
8699   ins_pipe(pipe_class_default);
8700 %}
8701 
8702 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
8703 // positive longs and 0xF...F for negative ones.
8704 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
8705   // no match-rule, false predicate
8706   effect(DEF dst, USE src);
8707   predicate(false);
8708 
8709   format %{ "SRADI   $dst, $src, #63" %}
8710   size(4);
8711   ins_encode %{
8712     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
8713     __ sradi($dst$$Register, $src$$Register, 0x3f);
8714   %}
8715   ins_pipe(pipe_class_default);
8716 %}
8717 
8718 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
8719 // positive longs and 0xF...F for negative ones.
8720 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
8721   // no match-rule, false predicate
8722   effect(DEF dst, USE src);
8723   predicate(false);
8724 
8725   format %{ "SRADI   $dst, $src, #63" %}
8726   size(4);
8727   ins_encode %{
8728     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
8729     __ sradi($dst$$Register, $src$$Register, 0x3f);
8730   %}
8731   ins_pipe(pipe_class_default);
8732 %}
8733 
8734 // Long negation
8735 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
8736   match(Set dst (SubL zero src2));
8737   format %{ "NEG     $dst, $src2 \t// long" %}
8738   size(4);
8739   ins_encode %{
8740     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8741     __ neg($dst$$Register, $src2$$Register);
8742   %}
8743   ins_pipe(pipe_class_default);
8744 %}
8745 
8746 // NegL + ConvL2I.
8747 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
8748   match(Set dst (ConvL2I (SubL zero src2)));
8749 
8750   format %{ "NEG     $dst, $src2 \t// long + l2i" %}
8751   size(4);
8752   ins_encode %{
8753     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8754     __ neg($dst$$Register, $src2$$Register);
8755   %}
8756   ins_pipe(pipe_class_default);
8757 %}
8758 
8759 // Multiplication Instructions
8760 // Integer Multiplication
8761 
8762 // Register Multiplication
8763 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8764   match(Set dst (MulI src1 src2));
8765   ins_cost(DEFAULT_COST);
8766 
8767   format %{ "MULLW   $dst, $src1, $src2" %}
8768   size(4);
8769   ins_encode %{
8770     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
8771     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
8772   %}
8773   ins_pipe(pipe_class_default);
8774 %}
8775 
8776 // Immediate Multiplication
8777 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
8778   match(Set dst (MulI src1 src2));
8779   ins_cost(DEFAULT_COST);
8780 
8781   format %{ "MULLI   $dst, $src1, $src2" %}
8782   size(4);
8783   ins_encode %{
8784     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
8785     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
8786   %}
8787   ins_pipe(pipe_class_default);
8788 %}
8789 
8790 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8791   match(Set dst (MulL src1 src2));
8792   ins_cost(DEFAULT_COST);
8793 
8794   format %{ "MULLD   $dst $src1, $src2 \t// long" %}
8795   size(4);
8796   ins_encode %{
8797     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
8798     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
8799   %}
8800   ins_pipe(pipe_class_default);
8801 %}
8802 
8803 // Multiply high for optimized long division by constant.
8804 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8805   match(Set dst (MulHiL src1 src2));
8806   ins_cost(DEFAULT_COST);
8807 
8808   format %{ "MULHD   $dst $src1, $src2 \t// long" %}
8809   size(4);
8810   ins_encode %{
8811     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
8812     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
8813   %}
8814   ins_pipe(pipe_class_default);
8815 %}
8816 
8817 // Immediate Multiplication
8818 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
8819   match(Set dst (MulL src1 src2));
8820   ins_cost(DEFAULT_COST);
8821 
8822   format %{ "MULLI   $dst, $src1, $src2" %}
8823   size(4);
8824   ins_encode %{
8825     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
8826     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
8827   %}
8828   ins_pipe(pipe_class_default);
8829 %}
8830 
8831 // Integer Division with Immediate -1: Negate.
8832 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
8833   match(Set dst (DivI src1 src2));
8834   ins_cost(DEFAULT_COST);
8835 
8836   format %{ "NEG     $dst, $src1 \t// /-1" %}
8837   size(4);
8838   ins_encode %{
8839     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8840     __ neg($dst$$Register, $src1$$Register);
8841   %}
8842   ins_pipe(pipe_class_default);
8843 %}
8844 
8845 // Integer Division with constant, but not -1.
8846 // We should be able to improve this by checking the type of src2.
8847 // It might well be that src2 is known to be positive.
8848 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8849   match(Set dst (DivI src1 src2));
8850   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
8851   ins_cost(2*DEFAULT_COST);
8852 
8853   format %{ "DIVW    $dst, $src1, $src2 \t// /not-1" %}
8854   size(4);
8855   ins_encode %{
8856     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
8857     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
8858   %}
8859   ins_pipe(pipe_class_default);
8860 %}
8861 
8862 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
8863   effect(USE_DEF dst, USE src1, USE crx);
8864   predicate(false);
8865 
8866   ins_variable_size_depending_on_alignment(true);
8867 
8868   format %{ "CMOVE   $dst, neg($src1), $crx" %}
8869   // Worst case is branch + move + stop, no stop without scheduler.
8870   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
8871   ins_encode %{
8872     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
8873     Label done;
8874     __ bne($crx$$CondRegister, done);
8875     __ neg($dst$$Register, $src1$$Register);
8876     // TODO PPC port __ endgroup_if_needed(_size == 12);
8877     __ bind(done);
8878   %}
8879   ins_pipe(pipe_class_default);
8880 %}
8881 
8882 // Integer Division with Registers not containing constants.
8883 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8884   match(Set dst (DivI src1 src2));
8885   ins_cost(10*DEFAULT_COST);
8886 
8887   expand %{
8888     immI16 imm %{ (int)-1 %}
8889     flagsReg tmp1;
8890     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
8891     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
8892     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
8893   %}
8894 %}
8895 
8896 // Long Division with Immediate -1: Negate.
8897 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
8898   match(Set dst (DivL src1 src2));
8899   ins_cost(DEFAULT_COST);
8900 
8901   format %{ "NEG     $dst, $src1 \t// /-1, long" %}
8902   size(4);
8903   ins_encode %{
8904     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
8905     __ neg($dst$$Register, $src1$$Register);
8906   %}
8907   ins_pipe(pipe_class_default);
8908 %}
8909 
8910 // Long Division with constant, but not -1.
8911 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8912   match(Set dst (DivL src1 src2));
8913   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
8914   ins_cost(2*DEFAULT_COST);
8915 
8916   format %{ "DIVD    $dst, $src1, $src2 \t// /not-1, long" %}
8917   size(4);
8918   ins_encode %{
8919     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
8920     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
8921   %}
8922   ins_pipe(pipe_class_default);
8923 %}
8924 
8925 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
8926   effect(USE_DEF dst, USE src1, USE crx);
8927   predicate(false);
8928 
8929   ins_variable_size_depending_on_alignment(true);
8930 
8931   format %{ "CMOVE   $dst, neg($src1), $crx" %}
8932   // Worst case is branch + move + stop, no stop without scheduler.
8933   size(false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
8934   ins_encode %{
8935     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
8936     Label done;
8937     __ bne($crx$$CondRegister, done);
8938     __ neg($dst$$Register, $src1$$Register);
8939     // TODO PPC port __ endgroup_if_needed(_size == 12);
8940     __ bind(done);
8941   %}
8942   ins_pipe(pipe_class_default);
8943 %}
8944 
8945 // Long Division with Registers not containing constants.
8946 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8947   match(Set dst (DivL src1 src2));
8948   ins_cost(10*DEFAULT_COST);
8949 
8950   expand %{
8951     immL16 imm %{ (int)-1 %}
8952     flagsReg tmp1;
8953     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
8954     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
8955     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
8956   %}
8957 %}
8958 
8959 // Integer Remainder with registers.
8960 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
8961   match(Set dst (ModI src1 src2));
8962   ins_cost(10*DEFAULT_COST);
8963 
8964   expand %{
8965     immI16 imm %{ (int)-1 %}
8966     flagsReg tmp1;
8967     iRegIdst tmp2;
8968     iRegIdst tmp3;
8969     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
8970     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
8971     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
8972     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
8973     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
8974   %}
8975 %}
8976 
8977 // Long Remainder with registers
8978 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
8979   match(Set dst (ModL src1 src2));
8980   ins_cost(10*DEFAULT_COST);
8981 
8982   expand %{
8983     immL16 imm %{ (int)-1 %}
8984     flagsReg tmp1;
8985     iRegLdst tmp2;
8986     iRegLdst tmp3;
8987     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
8988     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
8989     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
8990     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
8991     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
8992   %}
8993 %}
8994 
8995 // Integer Shift Instructions
8996 
8997 // Register Shift Left
8998 
8999 // Clear all but the lowest #mask bits.
9000 // Used to normalize shift amounts in registers.
9001 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
9002   // no match-rule, false predicate
9003   effect(DEF dst, USE src, USE mask);
9004   predicate(false);
9005 
9006   format %{ "MASK    $dst, $src, $mask \t// clear $mask upper bits" %}
9007   size(4);
9008   ins_encode %{
9009     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9010     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
9011   %}
9012   ins_pipe(pipe_class_default);
9013 %}
9014 
9015 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9016   // no match-rule, false predicate
9017   effect(DEF dst, USE src1, USE src2);
9018   predicate(false);
9019 
9020   format %{ "SLW     $dst, $src1, $src2" %}
9021   size(4);
9022   ins_encode %{
9023     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
9024     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
9025   %}
9026   ins_pipe(pipe_class_default);
9027 %}
9028 
9029 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9030   match(Set dst (LShiftI src1 src2));
9031   ins_cost(DEFAULT_COST*2);
9032   expand %{
9033     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
9034     iRegIdst tmpI;
9035     maskI_reg_imm(tmpI, src2, mask);
9036     lShiftI_reg_reg(dst, src1, tmpI);
9037   %}
9038 %}
9039 
9040 // Register Shift Left Immediate
9041 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
9042   match(Set dst (LShiftI src1 src2));
9043 
9044   format %{ "SLWI    $dst, $src1, ($src2 &amp; 0x1f)" %}
9045   size(4);
9046   ins_encode %{
9047     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9048     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
9049   %}
9050   ins_pipe(pipe_class_default);
9051 %}
9052 
9053 // AndI with negpow2-constant + LShiftI
9054 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
9055   match(Set dst (LShiftI (AndI src1 src2) src3));
9056   predicate(UseRotateAndMaskInstructionsPPC64);
9057 
9058   format %{ "RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)" %}
9059   size(4);
9060   ins_encode %{
9061     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
9062     long src2      = $src2$$constant;
9063     long src3      = $src3$$constant;
9064     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
9065     if (maskbits &gt;= 32) {
9066       __ li($dst$$Register, 0); // addi
9067     } else {
9068       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
9069     }
9070   %}
9071   ins_pipe(pipe_class_default);
9072 %}
9073 
9074 // RShiftI + AndI with negpow2-constant + LShiftI
9075 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
9076   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
9077   predicate(UseRotateAndMaskInstructionsPPC64);
9078 
9079   format %{ "RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)" %}
9080   size(4);
9081   ins_encode %{
9082     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
9083     long src2      = $src2$$constant;
9084     long src3      = $src3$$constant;
9085     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
9086     if (maskbits &gt;= 32) {
9087       __ li($dst$$Register, 0); // addi
9088     } else {
9089       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
9090     }
9091   %}
9092   ins_pipe(pipe_class_default);
9093 %}
9094 
9095 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9096   // no match-rule, false predicate
9097   effect(DEF dst, USE src1, USE src2);
9098   predicate(false);
9099 
9100   format %{ "SLD     $dst, $src1, $src2" %}
9101   size(4);
9102   ins_encode %{
9103     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
9104     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
9105   %}
9106   ins_pipe(pipe_class_default);
9107 %}
9108 
9109 // Register Shift Left
9110 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9111   match(Set dst (LShiftL src1 src2));
9112   ins_cost(DEFAULT_COST*2);
9113   expand %{
9114     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
9115     iRegIdst tmpI;
9116     maskI_reg_imm(tmpI, src2, mask);
9117     lShiftL_regL_regI(dst, src1, tmpI);
9118   %}
9119 %}
9120 
9121 // Register Shift Left Immediate
9122 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
9123   match(Set dst (LShiftL src1 src2));
9124   format %{ "SLDI    $dst, $src1, ($src2 &amp; 0x3f)" %}
9125   size(4);
9126   ins_encode %{
9127     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9128     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9129   %}
9130   ins_pipe(pipe_class_default);
9131 %}
9132 
9133 // If we shift more than 32 bits, we need not convert I2L.
9134 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
9135   match(Set dst (LShiftL (ConvI2L src1) src2));
9136   ins_cost(DEFAULT_COST);
9137 
9138   size(4);
9139   format %{ "SLDI    $dst, i2l($src1), $src2" %}
9140   ins_encode %{
9141     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9142     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9143   %}
9144   ins_pipe(pipe_class_default);
9145 %}
9146 
9147 // Shift a postivie int to the left.
9148 // Clrlsldi clears the upper 32 bits and shifts.
9149 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
9150   match(Set dst (LShiftL (ConvI2L src1) src2));
9151   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
9152 
9153   format %{ "SLDI    $dst, i2l(positive_int($src1)), $src2" %}
9154   size(4);
9155   ins_encode %{
9156     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
9157     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
9158   %}
9159   ins_pipe(pipe_class_default);
9160 %}
9161 
9162 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9163   // no match-rule, false predicate
9164   effect(DEF dst, USE src1, USE src2);
9165   predicate(false);
9166 
9167   format %{ "SRAW    $dst, $src1, $src2" %}
9168   size(4);
9169   ins_encode %{
9170     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
9171     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
9172   %}
9173   ins_pipe(pipe_class_default);
9174 %}
9175 
9176 // Register Arithmetic Shift Right
9177 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9178   match(Set dst (RShiftI src1 src2));
9179   ins_cost(DEFAULT_COST*2);
9180   expand %{
9181     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
9182     iRegIdst tmpI;
9183     maskI_reg_imm(tmpI, src2, mask);
9184     arShiftI_reg_reg(dst, src1, tmpI);
9185   %}
9186 %}
9187 
9188 // Register Arithmetic Shift Right Immediate
9189 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
9190   match(Set dst (RShiftI src1 src2));
9191 
9192   format %{ "SRAWI   $dst, $src1, ($src2 &amp; 0x1f)" %}
9193   size(4);
9194   ins_encode %{
9195     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
9196     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
9197   %}
9198   ins_pipe(pipe_class_default);
9199 %}
9200 
9201 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9202   // no match-rule, false predicate
9203   effect(DEF dst, USE src1, USE src2);
9204   predicate(false);
9205 
9206   format %{ "SRAD    $dst, $src1, $src2" %}
9207   size(4);
9208   ins_encode %{
9209     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
9210     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
9211   %}
9212   ins_pipe(pipe_class_default);
9213 %}
9214 
9215 // Register Shift Right Arithmetic Long
9216 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9217   match(Set dst (RShiftL src1 src2));
9218   ins_cost(DEFAULT_COST*2);
9219 
9220   expand %{
9221     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
9222     iRegIdst tmpI;
9223     maskI_reg_imm(tmpI, src2, mask);
9224     arShiftL_regL_regI(dst, src1, tmpI);
9225   %}
9226 %}
9227 
9228 // Register Shift Right Immediate
9229 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
9230   match(Set dst (RShiftL src1 src2));
9231 
9232   format %{ "SRADI   $dst, $src1, ($src2 &amp; 0x3f)" %}
9233   size(4);
9234   ins_encode %{
9235     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
9236     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9237   %}
9238   ins_pipe(pipe_class_default);
9239 %}
9240 
9241 // RShiftL + ConvL2I
9242 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
9243   match(Set dst (ConvL2I (RShiftL src1 src2)));
9244 
9245   format %{ "SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i" %}
9246   size(4);
9247   ins_encode %{
9248     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
9249     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9250   %}
9251   ins_pipe(pipe_class_default);
9252 %}
9253 
9254 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9255   // no match-rule, false predicate
9256   effect(DEF dst, USE src1, USE src2);
9257   predicate(false);
9258 
9259   format %{ "SRW     $dst, $src1, $src2" %}
9260   size(4);
9261   ins_encode %{
9262     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
9263     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
9264   %}
9265   ins_pipe(pipe_class_default);
9266 %}
9267 
9268 // Register Shift Right
9269 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9270   match(Set dst (URShiftI src1 src2));
9271   ins_cost(DEFAULT_COST*2);
9272 
9273   expand %{
9274     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
9275     iRegIdst tmpI;
9276     maskI_reg_imm(tmpI, src2, mask);
9277     urShiftI_reg_reg(dst, src1, tmpI);
9278   %}
9279 %}
9280 
9281 // Register Shift Right Immediate
9282 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
9283   match(Set dst (URShiftI src1 src2));
9284 
9285   format %{ "SRWI    $dst, $src1, ($src2 &amp; 0x1f)" %}
9286   size(4);
9287   ins_encode %{
9288     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9289     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
9290   %}
9291   ins_pipe(pipe_class_default);
9292 %}
9293 
9294 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9295   // no match-rule, false predicate
9296   effect(DEF dst, USE src1, USE src2);
9297   predicate(false);
9298 
9299   format %{ "SRD     $dst, $src1, $src2" %}
9300   size(4);
9301   ins_encode %{
9302     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
9303     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
9304   %}
9305   ins_pipe(pipe_class_default);
9306 %}
9307 
9308 // Register Shift Right
9309 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
9310   match(Set dst (URShiftL src1 src2));
9311   ins_cost(DEFAULT_COST*2);
9312 
9313   expand %{
9314     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
9315     iRegIdst tmpI;
9316     maskI_reg_imm(tmpI, src2, mask);
9317     urShiftL_regL_regI(dst, src1, tmpI);
9318   %}
9319 %}
9320 
9321 // Register Shift Right Immediate
9322 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
9323   match(Set dst (URShiftL src1 src2));
9324 
9325   format %{ "SRDI    $dst, $src1, ($src2 &amp; 0x3f)" %}
9326   size(4);
9327   ins_encode %{
9328     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9329     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9330   %}
9331   ins_pipe(pipe_class_default);
9332 %}
9333 
9334 // URShiftL + ConvL2I.
9335 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
9336   match(Set dst (ConvL2I (URShiftL src1 src2)));
9337 
9338   format %{ "SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i" %}
9339   size(4);
9340   ins_encode %{
9341     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9342     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9343   %}
9344   ins_pipe(pipe_class_default);
9345 %}
9346 
9347 // Register Shift Right Immediate with a CastP2X
9348 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
9349   match(Set dst (URShiftL (CastP2X src1) src2));
9350 
9351   format %{ "SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift" %}
9352   size(4);
9353   ins_encode %{
9354     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9355     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
9356   %}
9357   ins_pipe(pipe_class_default);
9358 %}
9359 
9360 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
9361   match(Set dst (ConvL2I (ConvI2L src)));
9362 
9363   format %{ "EXTSW   $dst, $src \t// int-&gt;int" %}
9364   size(4);
9365   ins_encode %{
9366     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
9367     __ extsw($dst$$Register, $src$$Register);
9368   %}
9369   ins_pipe(pipe_class_default);
9370 %}
9371 
9372 //----------Rotate Instructions------------------------------------------------
9373 
9374 // Rotate Left by 8-bit immediate
9375 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
9376   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
9377   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
9378 
9379   format %{ "ROTLWI  $dst, $src, $lshift" %}
9380   size(4);
9381   ins_encode %{
9382     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9383     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
9384   %}
9385   ins_pipe(pipe_class_default);
9386 %}
9387 
9388 // Rotate Right by 8-bit immediate
9389 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
9390   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
9391   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
9392 
9393   format %{ "ROTRWI  $dst, $rshift" %}
9394   size(4);
9395   ins_encode %{
9396     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9397     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
9398   %}
9399   ins_pipe(pipe_class_default);
9400 %}
9401 
9402 //----------Floating Point Arithmetic Instructions-----------------------------
9403 
9404 // Add float single precision
9405 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
9406   match(Set dst (AddF src1 src2));
9407 
9408   format %{ "FADDS   $dst, $src1, $src2" %}
9409   size(4);
9410   ins_encode %{
9411     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
9412     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9413   %}
9414   ins_pipe(pipe_class_default);
9415 %}
9416 
9417 // Add float double precision
9418 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
9419   match(Set dst (AddD src1 src2));
9420 
9421   format %{ "FADD    $dst, $src1, $src2" %}
9422   size(4);
9423   ins_encode %{
9424     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
9425     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9426   %}
9427   ins_pipe(pipe_class_default);
9428 %}
9429 
9430 // Sub float single precision
9431 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
9432   match(Set dst (SubF src1 src2));
9433 
9434   format %{ "FSUBS   $dst, $src1, $src2" %}
9435   size(4);
9436   ins_encode %{
9437     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
9438     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9439   %}
9440   ins_pipe(pipe_class_default);
9441 %}
9442 
9443 // Sub float double precision
9444 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
9445   match(Set dst (SubD src1 src2));
9446   format %{ "FSUB    $dst, $src1, $src2" %}
9447   size(4);
9448   ins_encode %{
9449     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
9450     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9451   %}
9452   ins_pipe(pipe_class_default);
9453 %}
9454 
9455 // Mul float single precision
9456 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
9457   match(Set dst (MulF src1 src2));
9458   format %{ "FMULS   $dst, $src1, $src2" %}
9459   size(4);
9460   ins_encode %{
9461     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
9462     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9463   %}
9464   ins_pipe(pipe_class_default);
9465 %}
9466 
9467 // Mul float double precision
9468 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
9469   match(Set dst (MulD src1 src2));
9470   format %{ "FMUL    $dst, $src1, $src2" %}
9471   size(4);
9472   ins_encode %{
9473     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
9474     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9475   %}
9476   ins_pipe(pipe_class_default);
9477 %}
9478 
9479 // Div float single precision
9480 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
9481   match(Set dst (DivF src1 src2));
9482   format %{ "FDIVS   $dst, $src1, $src2" %}
9483   size(4);
9484   ins_encode %{
9485     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
9486     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9487   %}
9488   ins_pipe(pipe_class_default);
9489 %}
9490 
9491 // Div float double precision
9492 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
9493   match(Set dst (DivD src1 src2));
9494   format %{ "FDIV    $dst, $src1, $src2" %}
9495   size(4);
9496   ins_encode %{
9497     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
9498     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
9499   %}
9500   ins_pipe(pipe_class_default);
9501 %}
9502 
9503 // Absolute float single precision
9504 instruct absF_reg(regF dst, regF src) %{
9505   match(Set dst (AbsF src));
9506   format %{ "FABS    $dst, $src \t// float" %}
9507   size(4);
9508   ins_encode %{
9509     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
9510     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
9511   %}
9512   ins_pipe(pipe_class_default);
9513 %}
9514 
9515 // Absolute float double precision
9516 instruct absD_reg(regD dst, regD src) %{
9517   match(Set dst (AbsD src));
9518   format %{ "FABS    $dst, $src \t// double" %}
9519   size(4);
9520   ins_encode %{
9521     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
9522     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
9523   %}
9524   ins_pipe(pipe_class_default);
9525 %}
9526 
9527 instruct negF_reg(regF dst, regF src) %{
9528   match(Set dst (NegF src));
9529   format %{ "FNEG    $dst, $src \t// float" %}
9530   size(4);
9531   ins_encode %{
9532     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
9533     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
9534   %}
9535   ins_pipe(pipe_class_default);
9536 %}
9537 
9538 instruct negD_reg(regD dst, regD src) %{
9539   match(Set dst (NegD src));
9540   format %{ "FNEG    $dst, $src \t// double" %}
9541   size(4);
9542   ins_encode %{
9543     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
9544     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
9545   %}
9546   ins_pipe(pipe_class_default);
9547 %}
9548 
9549 // AbsF + NegF.
9550 instruct negF_absF_reg(regF dst, regF src) %{
9551   match(Set dst (NegF (AbsF src)));
9552   format %{ "FNABS   $dst, $src \t// float" %}
9553   size(4);
9554   ins_encode %{
9555     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
9556     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
9557   %}
9558   ins_pipe(pipe_class_default);
9559 %}
9560 
9561 // AbsD + NegD.
9562 instruct negD_absD_reg(regD dst, regD src) %{
9563   match(Set dst (NegD (AbsD src)));
9564   format %{ "FNABS   $dst, $src \t// double" %}
9565   size(4);
9566   ins_encode %{
9567     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
9568     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
9569   %}
9570   ins_pipe(pipe_class_default);
9571 %}
9572 
9573 // VM_Version::has_fsqrt() decides if this node will be used.
9574 // Sqrt float double precision
9575 instruct sqrtD_reg(regD dst, regD src) %{
9576   match(Set dst (SqrtD src));
9577   format %{ "FSQRT   $dst, $src" %}
9578   size(4);
9579   ins_encode %{
9580     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
9581     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
9582   %}
9583   ins_pipe(pipe_class_default);
9584 %}
9585 
9586 // Single-precision sqrt.
9587 instruct sqrtF_reg(regF dst, regF src) %{
9588   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
9589   predicate(VM_Version::has_fsqrts());
9590   ins_cost(DEFAULT_COST);
9591 
9592   format %{ "FSQRTS  $dst, $src" %}
9593   size(4);
9594   ins_encode %{
9595     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
9596     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
9597   %}
9598   ins_pipe(pipe_class_default);
9599 %}
9600 
9601 instruct roundDouble_nop(regD dst) %{
9602   match(Set dst (RoundDouble dst));
9603   ins_cost(0);
9604 
9605   format %{ " -- \t// RoundDouble not needed - empty" %}
9606   size(0);
9607   // PPC results are already "rounded" (i.e., normal-format IEEE).
9608   ins_encode( /*empty*/ );
9609   ins_pipe(pipe_class_default);
9610 %}
9611 
9612 instruct roundFloat_nop(regF dst) %{
9613   match(Set dst (RoundFloat dst));
9614   ins_cost(0);
9615 
9616   format %{ " -- \t// RoundFloat not needed - empty" %}
9617   size(0);
9618   // PPC results are already "rounded" (i.e., normal-format IEEE).
9619   ins_encode( /*empty*/ );
9620   ins_pipe(pipe_class_default);
9621 %}
9622 
9623 //----------Logical Instructions-----------------------------------------------
9624 
9625 // And Instructions
9626 
9627 // Register And
9628 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9629   match(Set dst (AndI src1 src2));
9630   format %{ "AND     $dst, $src1, $src2" %}
9631   size(4);
9632   ins_encode %{
9633     // TODO: PPC port $archOpcode(ppc64Opcode_and);
9634     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
9635   %}
9636   ins_pipe(pipe_class_default);
9637 %}
9638 
9639 // Immediate And
9640 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
9641   match(Set dst (AndI src1 src2));
9642   effect(KILL cr0);
9643 
9644   format %{ "ANDI    $dst, $src1, $src2" %}
9645   size(4);
9646   ins_encode %{
9647     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
9648     // FIXME: avoid andi_ ?
9649     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
9650   %}
9651   ins_pipe(pipe_class_default);
9652 %}
9653 
9654 // Immediate And where the immediate is a negative power of 2.
9655 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
9656   match(Set dst (AndI src1 src2));
9657   format %{ "ANDWI   $dst, $src1, $src2" %}
9658   size(4);
9659   ins_encode %{
9660     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9661     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
9662   %}
9663   ins_pipe(pipe_class_default);
9664 %}
9665 
9666 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
9667   match(Set dst (AndI src1 src2));
9668   format %{ "ANDWI   $dst, $src1, $src2" %}
9669   size(4);
9670   ins_encode %{
9671     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9672     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
9673   %}
9674   ins_pipe(pipe_class_default);
9675 %}
9676 
9677 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
9678   match(Set dst (AndI src1 src2));
9679   predicate(UseRotateAndMaskInstructionsPPC64);
9680   format %{ "ANDWI   $dst, $src1, $src2" %}
9681   size(4);
9682   ins_encode %{
9683     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
9684     __ rlwinm($dst$$Register, $src1$$Register, 0,
9685               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
9686   %}
9687   ins_pipe(pipe_class_default);
9688 %}
9689 
9690 // Register And Long
9691 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9692   match(Set dst (AndL src1 src2));
9693   ins_cost(DEFAULT_COST);
9694 
9695   format %{ "AND     $dst, $src1, $src2 \t// long" %}
9696   size(4);
9697   ins_encode %{
9698     // TODO: PPC port $archOpcode(ppc64Opcode_and);
9699     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
9700   %}
9701   ins_pipe(pipe_class_default);
9702 %}
9703 
9704 // Immediate And long
9705 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
9706   match(Set dst (AndL src1 src2));
9707   effect(KILL cr0);
9708 
9709   format %{ "ANDI    $dst, $src1, $src2 \t// long" %}
9710   size(4);
9711   ins_encode %{
9712     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
9713     // FIXME: avoid andi_ ?
9714     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
9715   %}
9716   ins_pipe(pipe_class_default);
9717 %}
9718 
9719 // Immediate And Long where the immediate is a negative power of 2.
9720 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
9721   match(Set dst (AndL src1 src2));
9722   format %{ "ANDDI   $dst, $src1, $src2" %}
9723   size(4);
9724   ins_encode %{
9725     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
9726     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
9727   %}
9728   ins_pipe(pipe_class_default);
9729 %}
9730 
9731 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
9732   match(Set dst (AndL src1 src2));
9733   format %{ "ANDDI   $dst, $src1, $src2" %}
9734   size(4);
9735   ins_encode %{
9736     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9737     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
9738   %}
9739   ins_pipe(pipe_class_default);
9740 %}
9741 
9742 // AndL + ConvL2I.
9743 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
9744   match(Set dst (ConvL2I (AndL src1 src2)));
9745   ins_cost(DEFAULT_COST);
9746 
9747   format %{ "ANDDI   $dst, $src1, $src2 \t// long + l2i" %}
9748   size(4);
9749   ins_encode %{
9750     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
9751     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
9752   %}
9753   ins_pipe(pipe_class_default);
9754 %}
9755 
9756 // Or Instructions
9757 
9758 // Register Or
9759 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9760   match(Set dst (OrI src1 src2));
9761   format %{ "OR      $dst, $src1, $src2" %}
9762   size(4);
9763   ins_encode %{
9764     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9765     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9766   %}
9767   ins_pipe(pipe_class_default);
9768 %}
9769 
9770 // Expand does not work with above instruct. (??)
9771 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9772   // no match-rule
9773   effect(DEF dst, USE src1, USE src2);
9774   format %{ "OR      $dst, $src1, $src2" %}
9775   size(4);
9776   ins_encode %{
9777     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9778     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9779   %}
9780   ins_pipe(pipe_class_default);
9781 %}
9782 
9783 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
9784   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
9785   ins_cost(DEFAULT_COST*3);
9786 
9787   expand %{
9788     // FIXME: we should do this in the ideal world.
9789     iRegIdst tmp1;
9790     iRegIdst tmp2;
9791     orI_reg_reg(tmp1, src1, src2);
9792     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
9793     orI_reg_reg(dst, tmp1, tmp2);
9794   %}
9795 %}
9796 
9797 // Immediate Or
9798 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
9799   match(Set dst (OrI src1 src2));
9800   format %{ "ORI     $dst, $src1, $src2" %}
9801   size(4);
9802   ins_encode %{
9803     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
9804     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
9805   %}
9806   ins_pipe(pipe_class_default);
9807 %}
9808 
9809 // Register Or Long
9810 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9811   match(Set dst (OrL src1 src2));
9812   ins_cost(DEFAULT_COST);
9813 
9814   size(4);
9815   format %{ "OR      $dst, $src1, $src2 \t// long" %}
9816   ins_encode %{
9817     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9818     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9819   %}
9820   ins_pipe(pipe_class_default);
9821 %}
9822 
9823 // OrL + ConvL2I.
9824 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
9825   match(Set dst (ConvL2I (OrL src1 src2)));
9826   ins_cost(DEFAULT_COST);
9827 
9828   format %{ "OR      $dst, $src1, $src2 \t// long + l2i" %}
9829   size(4);
9830   ins_encode %{
9831     // TODO: PPC port $archOpcode(ppc64Opcode_or);
9832     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
9833   %}
9834   ins_pipe(pipe_class_default);
9835 %}
9836 
9837 // Immediate Or long
9838 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
9839   match(Set dst (OrL src1 con));
9840   ins_cost(DEFAULT_COST);
9841 
9842   format %{ "ORI     $dst, $src1, $con \t// long" %}
9843   size(4);
9844   ins_encode %{
9845     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
9846     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
9847   %}
9848   ins_pipe(pipe_class_default);
9849 %}
9850 
9851 // Xor Instructions
9852 
9853 // Register Xor
9854 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9855   match(Set dst (XorI src1 src2));
9856   format %{ "XOR     $dst, $src1, $src2" %}
9857   size(4);
9858   ins_encode %{
9859     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9860     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
9861   %}
9862   ins_pipe(pipe_class_default);
9863 %}
9864 
9865 // Expand does not work with above instruct. (??)
9866 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
9867   // no match-rule
9868   effect(DEF dst, USE src1, USE src2);
9869   format %{ "XOR     $dst, $src1, $src2" %}
9870   size(4);
9871   ins_encode %{
9872     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9873     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
9874   %}
9875   ins_pipe(pipe_class_default);
9876 %}
9877 
9878 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
9879   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
9880   ins_cost(DEFAULT_COST*3);
9881 
9882   expand %{
9883     // FIXME: we should do this in the ideal world.
9884     iRegIdst tmp1;
9885     iRegIdst tmp2;
9886     xorI_reg_reg(tmp1, src1, src2);
9887     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
9888     xorI_reg_reg(dst, tmp1, tmp2);
9889   %}
9890 %}
9891 
9892 // Immediate Xor
9893 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
9894   match(Set dst (XorI src1 src2));
9895   format %{ "XORI    $dst, $src1, $src2" %}
9896   size(4);
9897   ins_encode %{
9898     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
9899     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
9900   %}
9901   ins_pipe(pipe_class_default);
9902 %}
9903 
9904 // Register Xor Long
9905 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9906   match(Set dst (XorL src1 src2));
9907   ins_cost(DEFAULT_COST);
9908 
9909   format %{ "XOR     $dst, $src1, $src2 \t// long" %}
9910   size(4);
9911   ins_encode %{
9912     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9913     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
9914   %}
9915   ins_pipe(pipe_class_default);
9916 %}
9917 
9918 // XorL + ConvL2I.
9919 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
9920   match(Set dst (ConvL2I (XorL src1 src2)));
9921   ins_cost(DEFAULT_COST);
9922 
9923   format %{ "XOR     $dst, $src1, $src2 \t// long + l2i" %}
9924   size(4);
9925   ins_encode %{
9926     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
9927     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
9928   %}
9929   ins_pipe(pipe_class_default);
9930 %}
9931 
9932 // Immediate Xor Long
9933 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
9934   match(Set dst (XorL src1 src2));
9935   ins_cost(DEFAULT_COST);
9936 
9937   format %{ "XORI    $dst, $src1, $src2 \t// long" %}
9938   size(4);
9939   ins_encode %{
9940     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
9941     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
9942   %}
9943   ins_pipe(pipe_class_default);
9944 %}
9945 
9946 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
9947   match(Set dst (XorI src1 src2));
9948   ins_cost(DEFAULT_COST);
9949 
9950   format %{ "NOT     $dst, $src1 ($src2)" %}
9951   size(4);
9952   ins_encode %{
9953     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
9954     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
9955   %}
9956   ins_pipe(pipe_class_default);
9957 %}
9958 
9959 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
9960   match(Set dst (XorL src1 src2));
9961   ins_cost(DEFAULT_COST);
9962 
9963   format %{ "NOT     $dst, $src1 ($src2) \t// long" %}
9964   size(4);
9965   ins_encode %{
9966     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
9967     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
9968   %}
9969   ins_pipe(pipe_class_default);
9970 %}
9971 
9972 // And-complement
9973 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
9974   match(Set dst (AndI (XorI src1 src2) src3));
9975   ins_cost(DEFAULT_COST);
9976 
9977   format %{ "ANDW    $dst, xori($src1, $src2), $src3" %}
9978   size(4);
9979   ins_encode( enc_andc(dst, src3, src1) );
9980   ins_pipe(pipe_class_default);
9981 %}
9982 
9983 // And-complement
9984 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
9985   // no match-rule, false predicate
9986   effect(DEF dst, USE src1, USE src2);
9987   predicate(false);
9988 
9989   format %{ "ANDC    $dst, $src1, $src2" %}
9990   size(4);
9991   ins_encode %{
9992     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
9993     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
9994   %}
9995   ins_pipe(pipe_class_default);
9996 %}
9997 
9998 //----------Moves between int/long and float/double----------------------------
9999 //
10000 // The following rules move values from int/long registers/stack-locations
10001 // to float/double registers/stack-locations and vice versa, without doing any
10002 // conversions. These rules are used to implement the bit-conversion methods
10003 // of java.lang.Float etc., e.g.
10004 //   int   floatToIntBits(float value)
10005 //   float intBitsToFloat(int bits)
10006 //
10007 // Notes on the implementation on ppc64:
10008 // We only provide rules which move between a register and a stack-location,
10009 // because we always have to go through memory when moving between a float
10010 // register and an integer register.
10011 
10012 //---------- Chain stack slots between similar types --------
10013 
10014 // These are needed so that the rules below can match.
10015 
10016 // Load integer from stack slot
10017 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10018   match(Set dst src);
10019   ins_cost(MEMORY_REF_COST);
10020 
10021   format %{ "LWZ     $dst, $src" %}
10022   size(4);
10023   ins_encode( enc_lwz(dst, src) );
10024   ins_pipe(pipe_class_memory);
10025 %}
10026 
10027 // Store integer to stack slot
10028 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10029   match(Set dst src);
10030   ins_cost(MEMORY_REF_COST);
10031 
10032   format %{ "STW     $src, $dst \t// stk" %}
10033   size(4);
10034   ins_encode( enc_stw(src, dst) ); // rs=rt
10035   ins_pipe(pipe_class_memory);
10036 %}
10037 
10038 // Load long from stack slot
10039 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10040   match(Set dst src);
10041   ins_cost(MEMORY_REF_COST);
10042 
10043   format %{ "LD      $dst, $src \t// long" %}
10044   size(4);
10045   ins_encode( enc_ld(dst, src) );
10046   ins_pipe(pipe_class_memory);
10047 %}
10048 
10049 // Store long to stack slot
10050 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10051   match(Set dst src);
10052   ins_cost(MEMORY_REF_COST);
10053 
10054   format %{ "STD     $src, $dst \t// long" %}
10055   size(4);
10056   ins_encode( enc_std(src, dst) ); // rs=rt
10057   ins_pipe(pipe_class_memory);
10058 %}
10059 
10060 //----------Moves between int and float
10061 
10062 // Move float value from float stack-location to integer register.
10063 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10064   match(Set dst (MoveF2I src));
10065   ins_cost(MEMORY_REF_COST);
10066 
10067   format %{ "LWZ     $dst, $src \t// MoveF2I" %}
10068   size(4);
10069   ins_encode( enc_lwz(dst, src) );
10070   ins_pipe(pipe_class_memory);
10071 %}
10072 
10073 // Move float value from float register to integer stack-location.
10074 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10075   match(Set dst (MoveF2I src));
10076   ins_cost(MEMORY_REF_COST);
10077 
10078   format %{ "STFS    $src, $dst \t// MoveF2I" %}
10079   size(4);
10080   ins_encode( enc_stfs(src, dst) );
10081   ins_pipe(pipe_class_memory);
10082 %}
10083 
10084 // Move integer value from integer stack-location to float register.
10085 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10086   match(Set dst (MoveI2F src));
10087   ins_cost(MEMORY_REF_COST);
10088 
10089   format %{ "LFS     $dst, $src \t// MoveI2F" %}
10090   size(4);
10091   ins_encode %{
10092     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10093     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10094     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10095   %}
10096   ins_pipe(pipe_class_memory);
10097 %}
10098 
10099 // Move integer value from integer register to float stack-location.
10100 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10101   match(Set dst (MoveI2F src));
10102   ins_cost(MEMORY_REF_COST);
10103 
10104   format %{ "STW     $src, $dst \t// MoveI2F" %}
10105   size(4);
10106   ins_encode( enc_stw(src, dst) );
10107   ins_pipe(pipe_class_memory);
10108 %}
10109 
10110 //----------Moves between long and float
10111 
10112 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10113   // no match-rule, false predicate
10114   effect(DEF dst, USE src);
10115   predicate(false);
10116 
10117   format %{ "storeD  $src, $dst \t// STACK" %}
10118   size(4);
10119   ins_encode( enc_stfd(src, dst) );
10120   ins_pipe(pipe_class_default);
10121 %}
10122 
10123 //----------Moves between long and double
10124 
10125 // Move double value from double stack-location to long register.
10126 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10127   match(Set dst (MoveD2L src));
10128   ins_cost(MEMORY_REF_COST);
10129   size(4);
10130   format %{ "LD      $dst, $src \t// MoveD2L" %}
10131   ins_encode( enc_ld(dst, src) );
10132   ins_pipe(pipe_class_memory);
10133 %}
10134 
10135 // Move double value from double register to long stack-location.
10136 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10137   match(Set dst (MoveD2L src));
10138   effect(DEF dst, USE src);
10139   ins_cost(MEMORY_REF_COST);
10140 
10141   format %{ "STFD    $src, $dst \t// MoveD2L" %}
10142   size(4);
10143   ins_encode( enc_stfd(src, dst) );
10144   ins_pipe(pipe_class_memory);
10145 %}
10146 
10147 // Move long value from long stack-location to double register.
10148 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10149   match(Set dst (MoveL2D src));
10150   ins_cost(MEMORY_REF_COST);
10151 
10152   format %{ "LFD     $dst, $src \t// MoveL2D" %}
10153   size(4);
10154   ins_encode( enc_lfd(dst, src) );
10155   ins_pipe(pipe_class_memory);
10156 %}
10157 
10158 // Move long value from long register to double stack-location.
10159 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10160   match(Set dst (MoveL2D src));
10161   ins_cost(MEMORY_REF_COST);
10162 
10163   format %{ "STD     $src, $dst \t// MoveL2D" %}
10164   size(4);
10165   ins_encode( enc_std(src, dst) );
10166   ins_pipe(pipe_class_memory);
10167 %}
10168 
10169 //----------Register Move Instructions-----------------------------------------
10170 
10171 // Replicate for Superword
10172 
10173 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10174   predicate(false);
10175   effect(DEF dst, USE src);
10176 
10177   format %{ "MR      $dst, $src \t// replicate " %}
10178   // variable size, 0 or 4.
10179   ins_encode %{
10180     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10181     __ mr_if_needed($dst$$Register, $src$$Register);
10182   %}
10183   ins_pipe(pipe_class_default);
10184 %}
10185 
10186 //----------Cast instructions (Java-level type cast)---------------------------
10187 
10188 // Cast Long to Pointer for unsafe natives.
10189 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10190   match(Set dst (CastX2P src));
10191 
10192   format %{ "MR      $dst, $src \t// Long-&gt;Ptr" %}
10193   // variable size, 0 or 4.
10194   ins_encode %{
10195     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10196     __ mr_if_needed($dst$$Register, $src$$Register);
10197   %}
10198  ins_pipe(pipe_class_default);
10199 %}
10200 
10201 // Cast Pointer to Long for unsafe natives.
10202 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10203   match(Set dst (CastP2X src));
10204 
10205   format %{ "MR      $dst, $src \t// Ptr-&gt;Long" %}
10206   // variable size, 0 or 4.
10207   ins_encode %{
10208     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10209     __ mr_if_needed($dst$$Register, $src$$Register);
10210   %}
10211   ins_pipe(pipe_class_default);
10212 %}
10213 
10214 instruct castPP(iRegPdst dst) %{
10215   match(Set dst (CastPP dst));
10216   format %{ " -- \t// castPP of $dst" %}
10217   size(0);
10218   ins_encode( /*empty*/ );
10219   ins_pipe(pipe_class_default);
10220 %}
10221 
10222 instruct castII(iRegIdst dst) %{
10223   match(Set dst (CastII dst));
10224   format %{ " -- \t// castII of $dst" %}
10225   size(0);
10226   ins_encode( /*empty*/ );
10227   ins_pipe(pipe_class_default);
10228 %}
10229 
10230 instruct checkCastPP(iRegPdst dst) %{
10231   match(Set dst (CheckCastPP dst));
10232   format %{ " -- \t// checkcastPP of $dst" %}
10233   size(0);
10234   ins_encode( /*empty*/ );
10235   ins_pipe(pipe_class_default);
10236 %}
10237 
10238 //----------Convert instructions-----------------------------------------------
10239 
10240 // Convert to boolean.
10241 
10242 // int_to_bool(src) : { 1   if src != 0
10243 //                    { 0   else
10244 //
10245 // strategy:
10246 // 1) Count leading zeros of 32 bit-value src,
10247 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10248 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10249 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10250 
10251 // convI2Bool
10252 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10253   match(Set dst (Conv2B src));
10254   predicate(UseCountLeadingZerosInstructionsPPC64);
10255   ins_cost(DEFAULT_COST);
10256 
10257   expand %{
10258     immI shiftAmount %{ 0x5 %}
10259     uimmI16 mask %{ 0x1 %}
10260     iRegIdst tmp1;
10261     iRegIdst tmp2;
10262     countLeadingZerosI(tmp1, src);
10263     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10264     xorI_reg_uimm16(dst, tmp2, mask);
10265   %}
10266 %}
10267 
10268 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10269   match(Set dst (Conv2B src));
10270   effect(TEMP crx);
10271   predicate(!UseCountLeadingZerosInstructionsPPC64);
10272   ins_cost(DEFAULT_COST);
10273 
10274   format %{ "CMPWI   $crx, $src, #0 \t// convI2B"
10275             "LI      $dst, #0\n\t"
10276             "BEQ     $crx, done\n\t"
10277             "LI      $dst, #1\n"
10278             "done:" %}
10279   size(16);
10280   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10281   ins_pipe(pipe_class_compare);
10282 %}
10283 
10284 // ConvI2B + XorI
10285 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10286   match(Set dst (XorI (Conv2B src) mask));
10287   predicate(UseCountLeadingZerosInstructionsPPC64);
10288   ins_cost(DEFAULT_COST);
10289 
10290   expand %{
10291     immI shiftAmount %{ 0x5 %}
10292     iRegIdst tmp1;
10293     countLeadingZerosI(tmp1, src);
10294     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10295   %}
10296 %}
10297 
10298 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10299   match(Set dst (XorI (Conv2B src) mask));
10300   effect(TEMP crx);
10301   predicate(!UseCountLeadingZerosInstructionsPPC64);
10302   ins_cost(DEFAULT_COST);
10303 
10304   format %{ "CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)"
10305             "LI      $dst, #1\n\t"
10306             "BEQ     $crx, done\n\t"
10307             "LI      $dst, #0\n"
10308             "done:" %}
10309   size(16);
10310   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10311   ins_pipe(pipe_class_compare);
10312 %}
10313 
10314 // AndI 0b0..010..0 + ConvI2B
10315 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10316   match(Set dst (Conv2B (AndI src mask)));
10317   predicate(UseRotateAndMaskInstructionsPPC64);
10318   ins_cost(DEFAULT_COST);
10319 
10320   format %{ "RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))" %}
10321   size(4);
10322   ins_encode %{
10323     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10324     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10325   %}
10326   ins_pipe(pipe_class_default);
10327 %}
10328 
10329 // Convert pointer to boolean.
10330 //
10331 // ptr_to_bool(src) : { 1   if src != 0
10332 //                    { 0   else
10333 //
10334 // strategy:
10335 // 1) Count leading zeros of 64 bit-value src,
10336 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
10337 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10338 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10339 
10340 // ConvP2B
10341 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
10342   match(Set dst (Conv2B src));
10343   predicate(UseCountLeadingZerosInstructionsPPC64);
10344   ins_cost(DEFAULT_COST);
10345 
10346   expand %{
10347     immI shiftAmount %{ 0x6 %}
10348     uimmI16 mask %{ 0x1 %}
10349     iRegIdst tmp1;
10350     iRegIdst tmp2;
10351     countLeadingZerosP(tmp1, src);
10352     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10353     xorI_reg_uimm16(dst, tmp2, mask);
10354   %}
10355 %}
10356 
10357 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
10358   match(Set dst (Conv2B src));
10359   effect(TEMP crx);
10360   predicate(!UseCountLeadingZerosInstructionsPPC64);
10361   ins_cost(DEFAULT_COST);
10362 
10363   format %{ "CMPDI   $crx, $src, #0 \t// convP2B"
10364             "LI      $dst, #0\n\t"
10365             "BEQ     $crx, done\n\t"
10366             "LI      $dst, #1\n"
10367             "done:" %}
10368   size(16);
10369   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
10370   ins_pipe(pipe_class_compare);
10371 %}
10372 
10373 // ConvP2B + XorI
10374 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
10375   match(Set dst (XorI (Conv2B src) mask));
10376   predicate(UseCountLeadingZerosInstructionsPPC64);
10377   ins_cost(DEFAULT_COST);
10378 
10379   expand %{
10380     immI shiftAmount %{ 0x6 %}
10381     iRegIdst tmp1;
10382     countLeadingZerosP(tmp1, src);
10383     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10384   %}
10385 %}
10386 
10387 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
10388   match(Set dst (XorI (Conv2B src) mask));
10389   effect(TEMP crx);
10390   predicate(!UseCountLeadingZerosInstructionsPPC64);
10391   ins_cost(DEFAULT_COST);
10392 
10393   format %{ "CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)"
10394             "LI      $dst, #1\n\t"
10395             "BEQ     $crx, done\n\t"
10396             "LI      $dst, #0\n"
10397             "done:" %}
10398   size(16);
10399   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
10400   ins_pipe(pipe_class_compare);
10401 %}
10402 
10403 // if src1 &lt; src2, return -1 else return 0
10404 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10405   match(Set dst (CmpLTMask src1 src2));
10406   ins_cost(DEFAULT_COST*4);
10407 
10408   expand %{
10409     iRegLdst src1s;
10410     iRegLdst src2s;
10411     iRegLdst diff;
10412     convI2L_reg(src1s, src1); // Ensure proper sign extension.
10413     convI2L_reg(src2s, src2); // Ensure proper sign extension.
10414     subL_reg_reg(diff, src1s, src2s);
10415     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
10416     signmask64I_regL(dst, diff);
10417   %}
10418 %}
10419 
10420 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
10421   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
10422   format %{ "SRAWI   $dst, $src1, $src2 \t// CmpLTMask" %}
10423   size(4);
10424   ins_encode %{
10425     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
10426     __ srawi($dst$$Register, $src1$$Register, 0x1f);
10427   %}
10428   ins_pipe(pipe_class_default);
10429 %}
10430 
10431 //----------Arithmetic Conversion Instructions---------------------------------
10432 
10433 // Convert to Byte  -- nop
10434 // Convert to Short -- nop
10435 
10436 // Convert to Int
10437 
10438 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
10439   match(Set dst (RShiftI (LShiftI src amount) amount));
10440   format %{ "EXTSB   $dst, $src \t// byte-&gt;int" %}
10441   size(4);
10442   ins_encode %{
10443     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
10444     __ extsb($dst$$Register, $src$$Register);
10445   %}
10446   ins_pipe(pipe_class_default);
10447 %}
10448 
10449 // LShiftI 16 + RShiftI 16 converts short to int.
10450 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
10451   match(Set dst (RShiftI (LShiftI src amount) amount));
10452   format %{ "EXTSH   $dst, $src \t// short-&gt;int" %}
10453   size(4);
10454   ins_encode %{
10455     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
10456     __ extsh($dst$$Register, $src$$Register);
10457   %}
10458   ins_pipe(pipe_class_default);
10459 %}
10460 
10461 // ConvL2I + ConvI2L: Sign extend int in long register.
10462 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
10463   match(Set dst (ConvI2L (ConvL2I src)));
10464 
10465   format %{ "EXTSW   $dst, $src \t// long-&gt;long" %}
10466   size(4);
10467   ins_encode %{
10468     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
10469     __ extsw($dst$$Register, $src$$Register);
10470   %}
10471   ins_pipe(pipe_class_default);
10472 %}
10473 
10474 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
10475   match(Set dst (ConvL2I src));
10476   format %{ "MR      $dst, $src \t// long-&gt;int" %}
10477   // variable size, 0 or 4
10478   ins_encode %{
10479     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10480     __ mr_if_needed($dst$$Register, $src$$Register);
10481   %}
10482   ins_pipe(pipe_class_default);
10483 %}
10484 
10485 instruct convD2IRaw_regD(regD dst, regD src) %{
10486   // no match-rule, false predicate
10487   effect(DEF dst, USE src);
10488   predicate(false);
10489 
10490   format %{ "FCTIWZ $dst, $src \t// convD2I, $src != NaN" %}
10491   size(4);
10492   ins_encode %{
10493     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
10494     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
10495   %}
10496   ins_pipe(pipe_class_default);
10497 %}
10498 
10499 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
10500   // no match-rule, false predicate
10501   effect(DEF dst, USE crx, USE src);
10502   predicate(false);
10503 
10504   ins_variable_size_depending_on_alignment(true);
10505 
10506   format %{ "cmovI   $crx, $dst, $src" %}
10507   // Worst case is branch + move + stop, no stop without scheduler.
10508   size(false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8);
10509   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
10510   ins_pipe(pipe_class_default);
10511 %}
10512 
10513 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
10514   // no match-rule, false predicate
10515   effect(DEF dst, USE crx, USE mem);
10516   predicate(false);
10517 
10518   format %{ "CmovI   $dst, $crx, $mem \t// postalloc expanded" %}
10519   postalloc_expand %{
10520     //
10521     // replaces
10522     //
10523     //   region  dst  crx  mem
10524     //    \       |    |   /
10525     //     dst=cmovI_bso_stackSlotL_conLvalue0
10526     //
10527     // with
10528     //
10529     //   region  dst
10530     //    \       /
10531     //     dst=loadConI16(0)
10532     //      |
10533     //      ^  region  dst  crx  mem
10534     //      |   \       |    |    /
10535     //      dst=cmovI_bso_stackSlotL
10536     //
10537 
10538     // Create new nodes.
10539     MachNode *m1 = new loadConI16Node();
10540     MachNode *m2 = new cmovI_bso_stackSlotLNode();
10541 
10542     // inputs for new nodes
10543     m1-&gt;add_req(n_region);
10544     m2-&gt;add_req(n_region, n_crx, n_mem);
10545 
10546     // precedences for new nodes
10547     m2-&gt;add_prec(m1);
10548 
10549     // operands for new nodes
10550     m1-&gt;_opnds[0] = op_dst;
10551     m1-&gt;_opnds[1] = new immI16Oper(0);
10552 
10553     m2-&gt;_opnds[0] = op_dst;
10554     m2-&gt;_opnds[1] = op_crx;
10555     m2-&gt;_opnds[2] = op_mem;
10556 
10557     // registers for new nodes
10558     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10559     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10560 
10561     // Insert new nodes.
10562     nodes-&gt;push(m1);
10563     nodes-&gt;push(m2);
10564   %}
10565 %}
10566 
10567 // Double to Int conversion, NaN is mapped to 0.
10568 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
10569   match(Set dst (ConvD2I src));
10570   ins_cost(DEFAULT_COST);
10571 
10572   expand %{
10573     regD tmpD;
10574     stackSlotL tmpS;
10575     flagsReg crx;
10576     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10577     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
10578     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
10579     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10580   %}
10581 %}
10582 
10583 instruct convF2IRaw_regF(regF dst, regF src) %{
10584   // no match-rule, false predicate
10585   effect(DEF dst, USE src);
10586   predicate(false);
10587 
10588   format %{ "FCTIWZ $dst, $src \t// convF2I, $src != NaN" %}
10589   size(4);
10590   ins_encode %{
10591     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
10592     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
10593   %}
10594   ins_pipe(pipe_class_default);
10595 %}
10596 
10597 // Float to Int conversion, NaN is mapped to 0.
10598 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
10599   match(Set dst (ConvF2I src));
10600   ins_cost(DEFAULT_COST);
10601 
10602   expand %{
10603     regF tmpF;
10604     stackSlotL tmpS;
10605     flagsReg crx;
10606     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10607     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
10608     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
10609     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10610   %}
10611 %}
10612 
10613 // Convert to Long
10614 
10615 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
10616   match(Set dst (ConvI2L src));
10617   format %{ "EXTSW   $dst, $src \t// int-&gt;long" %}
10618   size(4);
10619   ins_encode %{
10620     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
10621     __ extsw($dst$$Register, $src$$Register);
10622   %}
10623   ins_pipe(pipe_class_default);
10624 %}
10625 
10626 // Zero-extend: convert unsigned int to long (convUI2L).
10627 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
10628   match(Set dst (AndL (ConvI2L src) mask));
10629   ins_cost(DEFAULT_COST);
10630 
10631   format %{ "CLRLDI  $dst, $src, #32 \t// zero-extend int to long" %}
10632   size(4);
10633   ins_encode %{
10634     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10635     __ clrldi($dst$$Register, $src$$Register, 32);
10636   %}
10637   ins_pipe(pipe_class_default);
10638 %}
10639 
10640 // Zero-extend: convert unsigned int to long in long register.
10641 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
10642   match(Set dst (AndL src mask));
10643   ins_cost(DEFAULT_COST);
10644 
10645   format %{ "CLRLDI  $dst, $src, #32 \t// zero-extend int to long" %}
10646   size(4);
10647   ins_encode %{
10648     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10649     __ clrldi($dst$$Register, $src$$Register, 32);
10650   %}
10651   ins_pipe(pipe_class_default);
10652 %}
10653 
10654 instruct convF2LRaw_regF(regF dst, regF src) %{
10655   // no match-rule, false predicate
10656   effect(DEF dst, USE src);
10657   predicate(false);
10658 
10659   format %{ "FCTIDZ $dst, $src \t// convF2L, $src != NaN" %}
10660   size(4);
10661   ins_encode %{
10662     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
10663     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
10664   %}
10665   ins_pipe(pipe_class_default);
10666 %}
10667 
10668 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
10669   // no match-rule, false predicate
10670   effect(DEF dst, USE crx, USE src);
10671   predicate(false);
10672 
10673   ins_variable_size_depending_on_alignment(true);
10674 
10675   format %{ "cmovL   $crx, $dst, $src" %}
10676   // Worst case is branch + move + stop, no stop without scheduler.
10677   size(false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8);
10678   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
10679   ins_pipe(pipe_class_default);
10680 %}
10681 
10682 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
10683   // no match-rule, false predicate
10684   effect(DEF dst, USE crx, USE mem);
10685   predicate(false);
10686 
10687   format %{ "CmovL   $dst, $crx, $mem \t// postalloc expanded" %}
10688   postalloc_expand %{
10689     //
10690     // replaces
10691     //
10692     //   region  dst  crx  mem
10693     //    \       |    |   /
10694     //     dst=cmovL_bso_stackSlotL_conLvalue0
10695     //
10696     // with
10697     //
10698     //   region  dst
10699     //    \       /
10700     //     dst=loadConL16(0)
10701     //      |
10702     //      ^  region  dst  crx  mem
10703     //      |   \       |    |    /
10704     //      dst=cmovL_bso_stackSlotL
10705     //
10706 
10707     // Create new nodes.
10708     MachNode *m1 = new loadConL16Node();
10709     MachNode *m2 = new cmovL_bso_stackSlotLNode();
10710 
10711     // inputs for new nodes
10712     m1-&gt;add_req(n_region);
10713     m2-&gt;add_req(n_region, n_crx, n_mem);
10714     m2-&gt;add_prec(m1);
10715 
10716     // operands for new nodes
10717     m1-&gt;_opnds[0] = op_dst;
10718     m1-&gt;_opnds[1] = new immL16Oper(0);
10719     m2-&gt;_opnds[0] = op_dst;
10720     m2-&gt;_opnds[1] = op_crx;
10721     m2-&gt;_opnds[2] = op_mem;
10722 
10723     // registers for new nodes
10724     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10725     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
10726 
10727     // Insert new nodes.
10728     nodes-&gt;push(m1);
10729     nodes-&gt;push(m2);
10730   %}
10731 %}
10732 
10733 // Float to Long conversion, NaN is mapped to 0.
10734 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
10735   match(Set dst (ConvF2L src));
10736   ins_cost(DEFAULT_COST);
10737 
10738   expand %{
10739     regF tmpF;
10740     stackSlotL tmpS;
10741     flagsReg crx;
10742     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10743     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
10744     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
10745     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10746   %}
10747 %}
10748 
10749 instruct convD2LRaw_regD(regD dst, regD src) %{
10750   // no match-rule, false predicate
10751   effect(DEF dst, USE src);
10752   predicate(false);
10753 
10754   format %{ "FCTIDZ $dst, $src \t// convD2L $src != NaN" %}
10755   size(4);
10756   ins_encode %{
10757     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
10758     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
10759   %}
10760   ins_pipe(pipe_class_default);
10761 %}
10762 
10763 // Double to Long conversion, NaN is mapped to 0.
10764 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
10765   match(Set dst (ConvD2L src));
10766   ins_cost(DEFAULT_COST);
10767 
10768   expand %{
10769     regD tmpD;
10770     stackSlotL tmpS;
10771     flagsReg crx;
10772     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
10773     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
10774     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
10775     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
10776   %}
10777 %}
10778 
10779 // Convert to Float
10780 
10781 // Placed here as needed in expand.
10782 instruct convL2DRaw_regD(regD dst, regD src) %{
10783   // no match-rule, false predicate
10784   effect(DEF dst, USE src);
10785   predicate(false);
10786 
10787   format %{ "FCFID $dst, $src \t// convL2D" %}
10788   size(4);
10789   ins_encode %{
10790     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
10791     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
10792   %}
10793   ins_pipe(pipe_class_default);
10794 %}
10795 
10796 // Placed here as needed in expand.
10797 instruct convD2F_reg(regF dst, regD src) %{
10798   match(Set dst (ConvD2F src));
10799   format %{ "FRSP    $dst, $src \t// convD2F" %}
10800   size(4);
10801   ins_encode %{
10802     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
10803     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
10804   %}
10805   ins_pipe(pipe_class_default);
10806 %}
10807 
10808 // Integer to Float conversion.
10809 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
10810   match(Set dst (ConvI2F src));
10811   predicate(!VM_Version::has_fcfids());
10812   ins_cost(DEFAULT_COST);
10813 
10814   expand %{
10815     iRegLdst tmpL;
10816     stackSlotL tmpS;
10817     regD tmpD;
10818     regD tmpD2;
10819     convI2L_reg(tmpL, src);              // Sign-extension int to long.
10820     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
10821     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10822     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
10823     convD2F_reg(dst, tmpD2);             // Convert double to float.
10824   %}
10825 %}
10826 
10827 instruct convL2FRaw_regF(regF dst, regD src) %{
10828   // no match-rule, false predicate
10829   effect(DEF dst, USE src);
10830   predicate(false);
10831 
10832   format %{ "FCFIDS $dst, $src \t// convL2F" %}
10833   size(4);
10834   ins_encode %{
10835     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
10836     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
10837   %}
10838   ins_pipe(pipe_class_default);
10839 %}
10840 
10841 // Integer to Float conversion. Special version for Power7.
10842 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
10843   match(Set dst (ConvI2F src));
10844   predicate(VM_Version::has_fcfids());
10845   ins_cost(DEFAULT_COST);
10846 
10847   expand %{
10848     iRegLdst tmpL;
10849     stackSlotL tmpS;
10850     regD tmpD;
10851     convI2L_reg(tmpL, src);              // Sign-extension int to long.
10852     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
10853     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10854     convL2FRaw_regF(dst, tmpD);          // Convert to float.
10855   %}
10856 %}
10857 
10858 // L2F to avoid runtime call.
10859 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
10860   match(Set dst (ConvL2F src));
10861   predicate(VM_Version::has_fcfids());
10862   ins_cost(DEFAULT_COST);
10863 
10864   expand %{
10865     stackSlotL tmpS;
10866     regD tmpD;
10867     regL_to_stkL(tmpS, src);             // Store long to stack.
10868     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10869     convL2FRaw_regF(dst, tmpD);          // Convert to float.
10870   %}
10871 %}
10872 
10873 // Moved up as used in expand.
10874 //instruct convD2F_reg(regF dst, regD src) %{%}
10875 
10876 // Convert to Double
10877 
10878 // Integer to Double conversion.
10879 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
10880   match(Set dst (ConvI2D src));
10881   ins_cost(DEFAULT_COST);
10882 
10883   expand %{
10884     iRegLdst tmpL;
10885     stackSlotL tmpS;
10886     regD tmpD;
10887     convI2L_reg(tmpL, src);              // Sign-extension int to long.
10888     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
10889     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
10890     convL2DRaw_regD(dst, tmpD);          // Convert to double.
10891   %}
10892 %}
10893 
10894 // Long to Double conversion
10895 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
10896   match(Set dst (ConvL2D src));
10897   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
10898 
10899   expand %{
10900     regD tmpD;
10901     moveL2D_stack_reg(tmpD, src);
10902     convL2DRaw_regD(dst, tmpD);
10903   %}
10904 %}
10905 
10906 instruct convF2D_reg(regD dst, regF src) %{
10907   match(Set dst (ConvF2D src));
10908   format %{ "FMR     $dst, $src \t// float-&gt;double" %}
10909   // variable size, 0 or 4
10910   ins_encode %{
10911     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
10912     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
10913   %}
10914   ins_pipe(pipe_class_default);
10915 %}
10916 
10917 //----------Control Flow Instructions------------------------------------------
10918 // Compare Instructions
10919 
10920 // Compare Integers
10921 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
10922   match(Set crx (CmpI src1 src2));
10923   size(4);
10924   format %{ "CMPW    $crx, $src1, $src2" %}
10925   ins_encode %{
10926     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
10927     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
10928   %}
10929   ins_pipe(pipe_class_compare);
10930 %}
10931 
10932 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
10933   match(Set crx (CmpI src1 src2));
10934   format %{ "CMPWI   $crx, $src1, $src2" %}
10935   size(4);
10936   ins_encode %{
10937     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
10938     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
10939   %}
10940   ins_pipe(pipe_class_compare);
10941 %}
10942 
10943 // (src1 &amp; src2) == 0?
10944 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
10945   match(Set cr0 (CmpI (AndI src1 src2) zero));
10946   // r0 is killed
10947   format %{ "ANDI    R0, $src1, $src2 \t// BTST int" %}
10948   size(4);
10949   ins_encode %{
10950     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10951     __ andi_(R0, $src1$$Register, $src2$$constant);
10952   %}
10953   ins_pipe(pipe_class_compare);
10954 %}
10955 
10956 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
10957   match(Set crx (CmpL src1 src2));
10958   format %{ "CMPD    $crx, $src1, $src2" %}
10959   size(4);
10960   ins_encode %{
10961     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
10962     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
10963   %}
10964   ins_pipe(pipe_class_compare);
10965 %}
10966 
10967 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
10968   match(Set crx (CmpL src1 src2));
10969   format %{ "CMPDI   $crx, $src1, $src2" %}
10970   size(4);
10971   ins_encode %{
10972     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
10973     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
10974   %}
10975   ins_pipe(pipe_class_compare);
10976 %}
10977 
10978 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
10979   match(Set cr0 (CmpL (AndL src1 src2) zero));
10980   // r0 is killed
10981   format %{ "AND     R0, $src1, $src2 \t// BTST long" %}
10982   size(4);
10983   ins_encode %{
10984     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
10985     __ and_(R0, $src1$$Register, $src2$$Register);
10986   %}
10987   ins_pipe(pipe_class_compare);
10988 %}
10989 
10990 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
10991   match(Set cr0 (CmpL (AndL src1 src2) zero));
10992   // r0 is killed
10993   format %{ "ANDI    R0, $src1, $src2 \t// BTST long" %}
10994   size(4);
10995   ins_encode %{
10996     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10997     __ andi_(R0, $src1$$Register, $src2$$constant);
10998   %}
10999   ins_pipe(pipe_class_compare);
11000 %}
11001 
11002 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11003   // no match-rule, false predicate
11004   effect(DEF dst, USE crx);
11005   predicate(false);
11006 
11007   ins_variable_size_depending_on_alignment(true);
11008 
11009   format %{ "cmovI   $crx, $dst, -1, 0, +1" %}
11010   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11011   size(false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16);
11012   ins_encode %{
11013     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11014     Label done;
11015     // li(Rdst, 0);              // equal -&gt; 0
11016     __ beq($crx$$CondRegister, done);
11017     __ li($dst$$Register, 1);    // greater -&gt; +1
11018     __ bgt($crx$$CondRegister, done);
11019     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11020     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11021     __ bind(done);
11022   %}
11023   ins_pipe(pipe_class_compare);
11024 %}
11025 
11026 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11027   // no match-rule, false predicate
11028   effect(DEF dst, USE crx);
11029   predicate(false);
11030 
11031   format %{ "CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded" %}
11032   postalloc_expand %{
11033     //
11034     // replaces
11035     //
11036     //   region  crx
11037     //    \       |
11038     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11039     //
11040     // with
11041     //
11042     //   region
11043     //    \
11044     //     dst=loadConI16(0)
11045     //      |
11046     //      ^  region  crx
11047     //      |   \       |
11048     //      dst=cmovI_conIvalueMinus1_conIvalue1
11049     //
11050 
11051     // Create new nodes.
11052     MachNode *m1 = new loadConI16Node();
11053     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
11054 
11055     // inputs for new nodes
11056     m1-&gt;add_req(n_region);
11057     m2-&gt;add_req(n_region, n_crx);
11058     m2-&gt;add_prec(m1);
11059 
11060     // operands for new nodes
11061     m1-&gt;_opnds[0] = op_dst;
11062     m1-&gt;_opnds[1] = new immI16Oper(0);
11063     m2-&gt;_opnds[0] = op_dst;
11064     m2-&gt;_opnds[1] = op_crx;
11065 
11066     // registers for new nodes
11067     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11068     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11069 
11070     // Insert new nodes.
11071     nodes-&gt;push(m1);
11072     nodes-&gt;push(m2);
11073   %}
11074 %}
11075 
11076 // Manifest a CmpL3 result in an integer register. Very painful.
11077 // This is the test to avoid.
11078 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
11079 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
11080   match(Set dst (CmpL3 src1 src2));
11081   ins_cost(DEFAULT_COST*5+BRANCH_COST);
11082 
11083   expand %{
11084     flagsReg tmp1;
11085     cmpL_reg_reg(tmp1, src1, src2);
11086     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
11087   %}
11088 %}
11089 
11090 // Implicit range checks.
11091 // A range check in the ideal world has one of the following shapes:
11092 //  - (If le (CmpU length index)), (IfTrue  throw exception)
11093 //  - (If lt (CmpU index length)), (IfFalse throw exception)
11094 //
11095 // Match range check 'If le (CmpU length index)'.
11096 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
11097   match(If cmp (CmpU src_length index));
11098   effect(USE labl);
11099   predicate(TrapBasedRangeChecks &amp;&amp;
11100             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
11101             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
11102             (Matcher::branches_to_uncommon_trap(_leaf)));
11103 
11104   ins_is_TrapBasedCheckNode(true);
11105 
11106   format %{ "TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl" %}
11107   size(4);
11108   ins_encode %{
11109     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
11110     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
11111       __ trap_range_check_le($src_length$$Register, $index$$constant);
11112     } else {
11113       // Both successors are uncommon traps, probability is 0.
11114       // Node got flipped during fixup flow.
11115       assert($cmp$$cmpcode == 0x9, "must be greater");
11116       __ trap_range_check_g($src_length$$Register, $index$$constant);
11117     }
11118   %}
11119   ins_pipe(pipe_class_trap);
11120 %}
11121 
11122 // Match range check 'If lt (CmpU index length)'.
11123 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
11124   match(If cmp (CmpU src_index src_length));
11125   effect(USE labl);
11126   predicate(TrapBasedRangeChecks &amp;&amp;
11127             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
11128             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
11129             (Matcher::branches_to_uncommon_trap(_leaf)));
11130 
11131   ins_is_TrapBasedCheckNode(true);
11132 
11133   format %{ "TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl" %}
11134   size(4);
11135   ins_encode %{
11136     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
11137     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
11138       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
11139     } else {
11140       // Both successors are uncommon traps, probability is 0.
11141       // Node got flipped during fixup flow.
11142       assert($cmp$$cmpcode == 0x8, "must be less");
11143       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
11144     }
11145   %}
11146   ins_pipe(pipe_class_trap);
11147 %}
11148 
11149 // Match range check 'If lt (CmpU index length)'.
11150 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
11151   match(If cmp (CmpU src_index length));
11152   effect(USE labl);
11153   predicate(TrapBasedRangeChecks &amp;&amp;
11154             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
11155             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
11156             (Matcher::branches_to_uncommon_trap(_leaf)));
11157 
11158   ins_is_TrapBasedCheckNode(true);
11159 
11160   format %{ "TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl" %}
11161   size(4);
11162   ins_encode %{
11163     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
11164     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
11165       __ trap_range_check_ge($src_index$$Register, $length$$constant);
11166     } else {
11167       // Both successors are uncommon traps, probability is 0.
11168       // Node got flipped during fixup flow.
11169       assert($cmp$$cmpcode == 0x8, "must be less");
11170       __ trap_range_check_l($src_index$$Register, $length$$constant);
11171     }
11172   %}
11173   ins_pipe(pipe_class_trap);
11174 %}
11175 
11176 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11177   match(Set crx (CmpU src1 src2));
11178   format %{ "CMPLW   $crx, $src1, $src2 \t// unsigned" %}
11179   size(4);
11180   ins_encode %{
11181     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11182     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11183   %}
11184   ins_pipe(pipe_class_compare);
11185 %}
11186 
11187 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
11188   match(Set crx (CmpU src1 src2));
11189   size(4);
11190   format %{ "CMPLWI  $crx, $src1, $src2" %}
11191   ins_encode %{
11192     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11193     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11194   %}
11195   ins_pipe(pipe_class_compare);
11196 %}
11197 
11198 // Implicit zero checks (more implicit null checks).
11199 // No constant pool entries required.
11200 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
11201   match(If cmp (CmpN value zero));
11202   effect(USE labl);
11203   predicate(TrapBasedNullChecks &amp;&amp;
11204             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
11205             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
11206             Matcher::branches_to_uncommon_trap(_leaf));
11207   ins_cost(1);
11208 
11209   ins_is_TrapBasedCheckNode(true);
11210 
11211   format %{ "TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl" %}
11212   size(4);
11213   ins_encode %{
11214     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
11215     if ($cmp$$cmpcode == 0xA) {
11216       __ trap_null_check($value$$Register);
11217     } else {
11218       // Both successors are uncommon traps, probability is 0.
11219       // Node got flipped during fixup flow.
11220       assert($cmp$$cmpcode == 0x2 , "must be equal(0xA) or notEqual(0x2)");
11221       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
11222     }
11223   %}
11224   ins_pipe(pipe_class_trap);
11225 %}
11226 
11227 // Compare narrow oops.
11228 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
11229   match(Set crx (CmpN src1 src2));
11230 
11231   size(4);
11232   ins_cost(2);
11233   format %{ "CMPLW   $crx, $src1, $src2 \t// compressed ptr" %}
11234   ins_encode %{
11235     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11236     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11237   %}
11238   ins_pipe(pipe_class_compare);
11239 %}
11240 
11241 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
11242   match(Set crx (CmpN src1 src2));
11243   // Make this more expensive than zeroCheckN_iReg_imm0.
11244   ins_cost(2);
11245 
11246   format %{ "CMPLWI  $crx, $src1, $src2 \t// compressed ptr" %}
11247   size(4);
11248   ins_encode %{
11249     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11250     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11251   %}
11252   ins_pipe(pipe_class_compare);
11253 %}
11254 
11255 // Implicit zero checks (more implicit null checks).
11256 // No constant pool entries required.
11257 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
11258   match(If cmp (CmpP value zero));
11259   effect(USE labl);
11260   predicate(TrapBasedNullChecks &amp;&amp;
11261             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
11262             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
11263             Matcher::branches_to_uncommon_trap(_leaf));
11264   ins_cost(1); // Should not be cheaper than zeroCheckN.
11265 
11266   ins_is_TrapBasedCheckNode(true);
11267 
11268   format %{ "TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl" %}
11269   size(4);
11270   ins_encode %{
11271     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
11272     if ($cmp$$cmpcode == 0xA) {
11273       __ trap_null_check($value$$Register);
11274     } else {
11275       // Both successors are uncommon traps, probability is 0.
11276       // Node got flipped during fixup flow.
11277       assert($cmp$$cmpcode == 0x2 , "must be equal(0xA) or notEqual(0x2)");
11278       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
11279     }
11280   %}
11281   ins_pipe(pipe_class_trap);
11282 %}
11283 
11284 // Compare Pointers
11285 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
11286   match(Set crx (CmpP src1 src2));
11287   format %{ "CMPLD   $crx, $src1, $src2 \t// ptr" %}
11288   size(4);
11289   ins_encode %{
11290     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11291     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11292   %}
11293   ins_pipe(pipe_class_compare);
11294 %}
11295 
11296 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
11297   match(Set crx (CmpP src1 src2));
11298   format %{ "CMPLDI   $crx, $src1, $src2 \t// ptr" %}
11299   size(4);
11300   ins_encode %{
11301     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11302     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
11303   %}
11304   ins_pipe(pipe_class_compare);
11305 %}
11306 
11307 // Used in postalloc expand.
11308 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
11309   // This match rule prevents reordering of node before a safepoint.
11310   // This only makes sense if this instructions is used exclusively
11311   // for the expansion of EncodeP!
11312   match(Set crx (CmpP src1 src2));
11313   predicate(false);
11314 
11315   format %{ "CMPDI   $crx, $src1, $src2" %}
11316   size(4);
11317   ins_encode %{
11318     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11319     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11320   %}
11321   ins_pipe(pipe_class_compare);
11322 %}
11323 
11324 //----------Float Compares----------------------------------------------------
11325 
11326 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
11327   // Needs matchrule, see cmpDUnordered.
11328   match(Set crx (CmpF src1 src2));
11329   // no match-rule, false predicate
11330   predicate(false);
11331 
11332   format %{ "cmpFUrd $crx, $src1, $src2" %}
11333   size(4);
11334   ins_encode %{
11335     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
11336     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
11337   %}
11338   ins_pipe(pipe_class_default);
11339 %}
11340 
11341 instruct cmov_bns_less(flagsReg crx) %{
11342   // no match-rule, false predicate
11343   effect(DEF crx);
11344   predicate(false);
11345 
11346   ins_variable_size_depending_on_alignment(true);
11347 
11348   format %{ "cmov    $crx" %}
11349   // Worst case is branch + move + stop, no stop without scheduler.
11350   size(false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12);
11351   ins_encode %{
11352     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
11353     Label done;
11354     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
11355     __ li(R0, 0);
11356     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to 'less'
11357     // TODO PPC port __ endgroup_if_needed(_size == 16);
11358     __ bind(done);
11359   %}
11360   ins_pipe(pipe_class_default);
11361 %}
11362 
11363 // Compare floating, generate condition code.
11364 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
11365   // FIXME: should we match 'If cmp (CmpF src1 src2))' ??
11366   //
11367   // The following code sequence occurs a lot in mpegaudio:
11368   //
11369   // block BXX:
11370   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
11371   //    cmpFUrd CCR6, F11, F9
11372   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
11373   //    cmov CCR6
11374   // 8: instruct branchConSched:
11375   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
11376   match(Set crx (CmpF src1 src2));
11377   ins_cost(DEFAULT_COST+BRANCH_COST);
11378 
11379   format %{ "CmpF    $crx, $src1, $src2 \t// postalloc expanded" %}
11380   postalloc_expand %{
11381     //
11382     // replaces
11383     //
11384     //   region  src1  src2
11385     //    \       |     |
11386     //     crx=cmpF_reg_reg
11387     //
11388     // with
11389     //
11390     //   region  src1  src2
11391     //    \       |     |
11392     //     crx=cmpFUnordered_reg_reg
11393     //      |
11394     //      ^  region
11395     //      |   \
11396     //      crx=cmov_bns_less
11397     //
11398 
11399     // Create new nodes.
11400     MachNode *m1 = new cmpFUnordered_reg_regNode();
11401     MachNode *m2 = new cmov_bns_lessNode();
11402 
11403     // inputs for new nodes
11404     m1-&gt;add_req(n_region, n_src1, n_src2);
11405     m2-&gt;add_req(n_region);
11406     m2-&gt;add_prec(m1);
11407 
11408     // operands for new nodes
11409     m1-&gt;_opnds[0] = op_crx;
11410     m1-&gt;_opnds[1] = op_src1;
11411     m1-&gt;_opnds[2] = op_src2;
11412     m2-&gt;_opnds[0] = op_crx;
11413 
11414     // registers for new nodes
11415     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11416     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11417 
11418     // Insert new nodes.
11419     nodes-&gt;push(m1);
11420     nodes-&gt;push(m2);
11421   %}
11422 %}
11423 
11424 // Compare float, generate -1,0,1
11425 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
11426   match(Set dst (CmpF3 src1 src2));
11427   ins_cost(DEFAULT_COST*5+BRANCH_COST);
11428 
11429   expand %{
11430     flagsReg tmp1;
11431     cmpFUnordered_reg_reg(tmp1, src1, src2);
11432     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
11433   %}
11434 %}
11435 
11436 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
11437   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
11438   // node right before the conditional move using it.
11439   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
11440   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
11441   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
11442   // conditional move was supposed to be spilled.
11443   match(Set crx (CmpD src1 src2));
11444   // False predicate, shall not be matched.
11445   predicate(false);
11446 
11447   format %{ "cmpFUrd $crx, $src1, $src2" %}
11448   size(4);
11449   ins_encode %{
11450     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
11451     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
11452   %}
11453   ins_pipe(pipe_class_default);
11454 %}
11455 
11456 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
11457   match(Set crx (CmpD src1 src2));
11458   ins_cost(DEFAULT_COST+BRANCH_COST);
11459 
11460   format %{ "CmpD    $crx, $src1, $src2 \t// postalloc expanded" %}
11461   postalloc_expand %{
11462     //
11463     // replaces
11464     //
11465     //   region  src1  src2
11466     //    \       |     |
11467     //     crx=cmpD_reg_reg
11468     //
11469     // with
11470     //
11471     //   region  src1  src2
11472     //    \       |     |
11473     //     crx=cmpDUnordered_reg_reg
11474     //      |
11475     //      ^  region
11476     //      |   \
11477     //      crx=cmov_bns_less
11478     //
11479 
11480     // create new nodes
11481     MachNode *m1 = new cmpDUnordered_reg_regNode();
11482     MachNode *m2 = new cmov_bns_lessNode();
11483 
11484     // inputs for new nodes
11485     m1-&gt;add_req(n_region, n_src1, n_src2);
11486     m2-&gt;add_req(n_region);
11487     m2-&gt;add_prec(m1);
11488 
11489     // operands for new nodes
11490     m1-&gt;_opnds[0] = op_crx;
11491     m1-&gt;_opnds[1] = op_src1;
11492     m1-&gt;_opnds[2] = op_src2;
11493     m2-&gt;_opnds[0] = op_crx;
11494 
11495     // registers for new nodes
11496     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11497     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
11498 
11499     // Insert new nodes.
11500     nodes-&gt;push(m1);
11501     nodes-&gt;push(m2);
11502   %}
11503 %}
11504 
11505 // Compare double, generate -1,0,1
11506 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
11507   match(Set dst (CmpD3 src1 src2));
11508   ins_cost(DEFAULT_COST*5+BRANCH_COST);
11509 
11510   expand %{
11511     flagsReg tmp1;
11512     cmpDUnordered_reg_reg(tmp1, src1, src2);
11513     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
11514   %}
11515 %}
11516 
11517 //----------Branches---------------------------------------------------------
11518 // Jump
11519 
11520 // Direct Branch.
11521 instruct branch(label labl) %{
11522   match(Goto);
11523   effect(USE labl);
11524   ins_cost(BRANCH_COST);
11525 
11526   format %{ "B       $labl" %}
11527   size(4);
11528   ins_encode %{
11529     // TODO: PPC port $archOpcode(ppc64Opcode_b);
11530      Label d;    // dummy
11531      __ bind(d);
11532      Label* p = $labl$$label;
11533      // `p' is `NULL' when this encoding class is used only to
11534      // determine the size of the encoded instruction.
11535      Label&amp; l = (NULL == p)? d : *(p);
11536      __ b(l);
11537   %}
11538   ins_pipe(pipe_class_default);
11539 %}
11540 
11541 // Conditional Near Branch
11542 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
11543   // Same match rule as `branchConFar'.
11544   match(If cmp crx);
11545   effect(USE lbl);
11546   ins_cost(BRANCH_COST);
11547 
11548   // If set to 1 this indicates that the current instruction is a
11549   // short variant of a long branch. This avoids using this
11550   // instruction in first-pass matching. It will then only be used in
11551   // the `Shorten_branches' pass.
11552   ins_short_branch(1);
11553 
11554   format %{ "B$cmp     $crx, $lbl" %}
11555   size(4);
11556   ins_encode( enc_bc(crx, cmp, lbl) );
11557   ins_pipe(pipe_class_default);
11558 %}
11559 
11560 // This is for cases when the ppc64 `bc' instruction does not
11561 // reach far enough. So we emit a far branch here, which is more
11562 // expensive.
11563 //
11564 // Conditional Far Branch
11565 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
11566   // Same match rule as `branchCon'.
11567   match(If cmp crx);
11568   effect(USE crx, USE lbl);
11569   predicate(!false /* TODO: PPC port HB_Schedule*/);
11570   // Higher cost than `branchCon'.
11571   ins_cost(5*BRANCH_COST);
11572 
11573   // This is not a short variant of a branch, but the long variant.
11574   ins_short_branch(0);
11575 
11576   format %{ "B_FAR$cmp $crx, $lbl" %}
11577   size(8);
11578   ins_encode( enc_bc_far(crx, cmp, lbl) );
11579   ins_pipe(pipe_class_default);
11580 %}
11581 
11582 // Conditional Branch used with Power6 scheduler (can be far or short).
11583 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
11584   // Same match rule as `branchCon'.
11585   match(If cmp crx);
11586   effect(USE crx, USE lbl);
11587   predicate(false /* TODO: PPC port HB_Schedule*/);
11588   // Higher cost than `branchCon'.
11589   ins_cost(5*BRANCH_COST);
11590 
11591   // Actually size doesn't depend on alignment but on shortening.
11592   ins_variable_size_depending_on_alignment(true);
11593   // long variant.
11594   ins_short_branch(0);
11595 
11596   format %{ "B_FAR$cmp $crx, $lbl" %}
11597   size(8); // worst case
11598   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
11599   ins_pipe(pipe_class_default);
11600 %}
11601 
11602 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
11603   match(CountedLoopEnd cmp crx);
11604   effect(USE labl);
11605   ins_cost(BRANCH_COST);
11606 
11607   // short variant.
11608   ins_short_branch(1);
11609 
11610   format %{ "B$cmp     $crx, $labl \t// counted loop end" %}
11611   size(4);
11612   ins_encode( enc_bc(crx, cmp, labl) );
11613   ins_pipe(pipe_class_default);
11614 %}
11615 
11616 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
11617   match(CountedLoopEnd cmp crx);
11618   effect(USE labl);
11619   predicate(!false /* TODO: PPC port HB_Schedule */);
11620   ins_cost(BRANCH_COST);
11621 
11622   // Long variant.
11623   ins_short_branch(0);
11624 
11625   format %{ "B_FAR$cmp $crx, $labl \t// counted loop end" %}
11626   size(8);
11627   ins_encode( enc_bc_far(crx, cmp, labl) );
11628   ins_pipe(pipe_class_default);
11629 %}
11630 
11631 // Conditional Branch used with Power6 scheduler (can be far or short).
11632 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
11633   match(CountedLoopEnd cmp crx);
11634   effect(USE labl);
11635   predicate(false /* TODO: PPC port HB_Schedule */);
11636   // Higher cost than `branchCon'.
11637   ins_cost(5*BRANCH_COST);
11638 
11639   // Actually size doesn't depend on alignment but on shortening.
11640   ins_variable_size_depending_on_alignment(true);
11641   // Long variant.
11642   ins_short_branch(0);
11643 
11644   format %{ "B_FAR$cmp $crx, $labl \t// counted loop end" %}
11645   size(8); // worst case
11646   ins_encode( enc_bc_short_far(crx, cmp, labl) );
11647   ins_pipe(pipe_class_default);
11648 %}
11649 
11650 // ============================================================================
11651 // Java runtime operations, intrinsics and other complex operations.
11652 
11653 // The 2nd slow-half of a subtype check. Scan the subklass's 2ndary superklass
11654 // array for an instance of the superklass. Set a hidden internal cache on a
11655 // hit (cache is checked with exposed code in gen_subtype_check()). Return
11656 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
11657 //
11658 // GL TODO: Improve this.
11659 // - result should not be a TEMP
11660 // - Add match rule as on sparc avoiding additional Cmp.
11661 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
11662                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
11663   match(Set result (PartialSubtypeCheck subklass superklass));
11664   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
11665   ins_cost(DEFAULT_COST*10);
11666 
11667   format %{ "PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr" %}
11668   ins_encode %{
11669     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11670     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
11671                                      $tmp_klass$$Register, NULL, $result$$Register);
11672   %}
11673   ins_pipe(pipe_class_default);
11674 %}
11675 
11676 // inlined locking and unlocking
11677 
11678 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
11679   match(Set crx (FastLock oop box));
11680   effect(TEMP tmp1, TEMP tmp2);
11681   predicate(!Compile::current()-&gt;use_rtm());
11682 
11683   format %{ "FASTLOCK  $oop, $box, $tmp1, $tmp2" %}
11684   ins_encode %{
11685     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11686     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11687                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
11688                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
11689     // If locking was successfull, crx should indicate 'EQ'.
11690     // The compiler generates a branch to the runtime call to
11691     // _complete_monitor_locking_Java for the case where crx is 'NE'.
11692   %}
11693   ins_pipe(pipe_class_compare);
11694 %}
11695 
11696 // Separate version for TM. Use bound register for box to enable USE_KILL.
11697 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
11698   match(Set crx (FastLock oop box));
11699   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
11700   predicate(Compile::current()-&gt;use_rtm());
11701 
11702   format %{ "FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)" %}
11703   ins_encode %{
11704     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11705     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11706                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
11707                                  /*Biased Locking*/ false,
11708                                  _rtm_counters, _stack_rtm_counters,
11709                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11710                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
11711     // If locking was successfull, crx should indicate 'EQ'.
11712     // The compiler generates a branch to the runtime call to
11713     // _complete_monitor_locking_Java for the case where crx is 'NE'.
11714   %}
11715   ins_pipe(pipe_class_compare);
11716 %}
11717 
11718 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
11719   match(Set crx (FastUnlock oop box));
11720   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
11721   predicate(!Compile::current()-&gt;use_rtm());
11722 
11723   format %{ "FASTUNLOCK  $oop, $box, $tmp1, $tmp2" %}
11724   ins_encode %{
11725     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11726     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11727                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
11728                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
11729                                    false);
11730     // If unlocking was successfull, crx should indicate 'EQ'.
11731     // The compiler generates a branch to the runtime call to
11732     // _complete_monitor_unlocking_Java for the case where crx is 'NE'.
11733   %}
11734   ins_pipe(pipe_class_compare);
11735 %}
11736 
11737 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
11738   match(Set crx (FastUnlock oop box));
11739   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
11740   predicate(Compile::current()-&gt;use_rtm());
11741 
11742   format %{ "FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)" %}
11743   ins_encode %{
11744     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11745     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
11746                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
11747                                    /*Biased Locking*/ false, /*TM*/ true);
11748     // If unlocking was successfull, crx should indicate 'EQ'.
11749     // The compiler generates a branch to the runtime call to
11750     // _complete_monitor_unlocking_Java for the case where crx is 'NE'.
11751   %}
11752   ins_pipe(pipe_class_compare);
11753 %}
11754 
11755 // Align address.
11756 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
11757   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
11758 
11759   format %{ "ANDDI   $dst, $src, $mask \t// next aligned address" %}
11760   size(4);
11761   ins_encode %{
11762     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
11763     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
11764   %}
11765   ins_pipe(pipe_class_default);
11766 %}
11767 
11768 // Array size computation.
11769 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
11770   match(Set dst (SubL (CastP2X end) (CastP2X start)));
11771 
11772   format %{ "SUB     $dst, $end, $start \t// array size in bytes" %}
11773   size(4);
11774   ins_encode %{
11775     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
11776     __ subf($dst$$Register, $start$$Register, $end$$Register);
11777   %}
11778   ins_pipe(pipe_class_default);
11779 %}
11780 
11781 // Clear-array with dynamic array-size.
11782 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
11783   match(Set dummy (ClearArray cnt base));
11784   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
11785   ins_cost(MEMORY_REF_COST);
11786 
11787   ins_alignment(4); // 'compute_padding()' gets called, up to this number-1 nops will get inserted.
11788 
11789   format %{ "ClearArray $cnt, $base" %}
11790   ins_encode %{
11791     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11792     __ clear_memory_doubleword($base$$Register, $cnt$$Register); // kills cnt, base, R0
11793   %}
11794   ins_pipe(pipe_class_default);
11795 %}
11796 
11797 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11798                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11799   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11800   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11801   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11802   ins_cost(300);
11803   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11804   ins_encode %{
11805     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11806     __ string_compare($str1$$Register, $str2$$Register,
11807                       $cnt1$$Register, $cnt2$$Register,
11808                       $tmp$$Register,
11809                       $result$$Register, StrIntrinsicNode::LL);
11810   %}
11811   ins_pipe(pipe_class_default);
11812 %}
11813 
11814 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11815                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11816   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11817   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11818   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11819   ins_cost(300);
11820   format %{ "String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11821   ins_encode %{
11822     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11823     __ string_compare($str1$$Register, $str2$$Register,
11824                       $cnt1$$Register, $cnt2$$Register,
11825                       $tmp$$Register,
11826                       $result$$Register, StrIntrinsicNode::UU);
11827   %}
11828   ins_pipe(pipe_class_default);
11829 %}
11830 
11831 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11832                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11833   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11834   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11835   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11836   ins_cost(300);
11837   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11838   ins_encode %{
11839     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11840     __ string_compare($str1$$Register, $str2$$Register,
11841                       $cnt1$$Register, $cnt2$$Register,
11842                       $tmp$$Register,
11843                       $result$$Register, StrIntrinsicNode::LU);
11844   %}
11845   ins_pipe(pipe_class_default);
11846 %}
11847 
11848 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
11849                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11850   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11851   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11852   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
11853   ins_cost(300);
11854   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp" %}
11855   ins_encode %{
11856     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11857     __ string_compare($str2$$Register, $str1$$Register,
11858                       $cnt2$$Register, $cnt1$$Register,
11859                       $tmp$$Register,
11860                       $result$$Register, StrIntrinsicNode::UL);
11861   %}
11862   ins_pipe(pipe_class_default);
11863 %}
11864 
11865 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
11866                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11867   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11868   match(Set result (StrEquals (Binary str1 str2) cnt));
11869   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
11870   ins_cost(300);
11871   format %{ "String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp" %}
11872   ins_encode %{
11873     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11874     __ array_equals(false, $str1$$Register, $str2$$Register,
11875                     $cnt$$Register, $tmp$$Register,
11876                     $result$$Register, true /* byte */);
11877   %}
11878   ins_pipe(pipe_class_default);
11879 %}
11880 
11881 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
11882                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
11883   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11884   match(Set result (StrEquals (Binary str1 str2) cnt));
11885   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
11886   ins_cost(300);
11887   format %{ "String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp" %}
11888   ins_encode %{
11889     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11890     __ array_equals(false, $str1$$Register, $str2$$Register,
11891                     $cnt$$Register, $tmp$$Register,
11892                     $result$$Register, false /* byte */);
11893   %}
11894   ins_pipe(pipe_class_default);
11895 %}
11896 
11897 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
11898                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
11899   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11900   match(Set result (AryEq ary1 ary2));
11901   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
11902   ins_cost(300);
11903   format %{ "Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2" %}
11904   ins_encode %{
11905     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11906     __ array_equals(true, $ary1$$Register, $ary2$$Register,
11907                     $tmp1$$Register, $tmp2$$Register,
11908                     $result$$Register, true /* byte */);
11909   %}
11910   ins_pipe(pipe_class_default);
11911 %}
11912 
11913 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
11914                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
11915   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11916   match(Set result (AryEq ary1 ary2));
11917   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
11918   ins_cost(300);
11919   format %{ "Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2" %}
11920   ins_encode %{
11921     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11922     __ array_equals(true, $ary1$$Register, $ary2$$Register,
11923                     $tmp1$$Register, $tmp2$$Register,
11924                     $result$$Register, false /* byte */);
11925   %}
11926   ins_pipe(pipe_class_default);
11927 %}
11928 
11929 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
11930                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
11931                              iRegIdst tmp1, iRegIdst tmp2,
11932                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
11933   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
11934   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
11935   // Required for EA: check if it is still a type_array.
11936   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11937   ins_cost(150);
11938 
11939   format %{ "String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]"
11940             "-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
11941 
11942   ins_encode %{
11943     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11944     immPOper *needleOper = (immPOper *)$needleImm;
11945     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
11946     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
11947     jchar chr;
11948 #ifdef VM_LITTLE_ENDIAN
11949     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
11950            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
11951 #else
11952     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
11953            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
11954 #endif
11955     __ string_indexof_char($result$$Register,
11956                            $haystack$$Register, $haycnt$$Register,
11957                            R0, chr,
11958                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
11959   %}
11960   ins_pipe(pipe_class_compare);
11961 %}
11962 
11963 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
11964                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
11965                              iRegIdst tmp1, iRegIdst tmp2,
11966                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
11967   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
11968   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
11969   // Required for EA: check if it is still a type_array.
11970   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11971   ins_cost(150);
11972 
11973   format %{ "String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]"
11974             "-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
11975 
11976   ins_encode %{
11977     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
11978     immPOper *needleOper = (immPOper *)$needleImm;
11979     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
11980     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
11981     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
11982     __ string_indexof_char($result$$Register,
11983                            $haystack$$Register, $haycnt$$Register,
11984                            R0, chr,
11985                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
11986   %}
11987   ins_pipe(pipe_class_compare);
11988 %}
11989 
11990 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
11991                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
11992                               iRegIdst tmp1, iRegIdst tmp2,
11993                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
11994   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
11995   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
11996   // Required for EA: check if it is still a type_array.
11997   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11998   ins_cost(150);
11999 
12000   format %{ "String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]"
12001             "-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
12002 
12003   ins_encode %{
12004     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12005     immPOper *needleOper = (immPOper *)$needleImm;
12006     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
12007     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
12008     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12009     __ string_indexof_char($result$$Register,
12010                            $haystack$$Register, $haycnt$$Register,
12011                            R0, chr,
12012                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12013   %}
12014   ins_pipe(pipe_class_compare);
12015 %}
12016 
12017 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12018                         rscratch2RegP needle, immI_1 needlecntImm,
12019                         iRegIdst tmp1, iRegIdst tmp2,
12020                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12021   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12022   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12023   // Required for EA: check if it is still a type_array.
12024   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
12025             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12026             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12027   ins_cost(180);
12028 
12029   format %{ "String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12030             " -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1" %}
12031   ins_encode %{
12032     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12033     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12034     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12035     guarantee(needle_values, "sanity");
12036     jchar chr;
12037 #ifdef VM_LITTLE_ENDIAN
12038     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
12039            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
12040 #else
12041     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
12042            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
12043 #endif
12044     __ string_indexof_char($result$$Register,
12045                            $haystack$$Register, $haycnt$$Register,
12046                            R0, chr,
12047                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12048   %}
12049   ins_pipe(pipe_class_compare);
12050 %}
12051 
12052 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12053                         rscratch2RegP needle, immI_1 needlecntImm,
12054                         iRegIdst tmp1, iRegIdst tmp2,
12055                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12056   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12057   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12058   // Required for EA: check if it is still a type_array.
12059   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
12060             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12061             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12062   ins_cost(180);
12063 
12064   format %{ "String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12065             " -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1" %}
12066   ins_encode %{
12067     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12068     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12069     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12070     guarantee(needle_values, "sanity");
12071     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12072     __ string_indexof_char($result$$Register,
12073                            $haystack$$Register, $haycnt$$Register,
12074                            R0, chr,
12075                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
12076   %}
12077   ins_pipe(pipe_class_compare);
12078 %}
12079 
12080 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12081                          rscratch2RegP needle, immI_1 needlecntImm,
12082                          iRegIdst tmp1, iRegIdst tmp2,
12083                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12084   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12085   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12086   // Required for EA: check if it is still a type_array.
12087   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
12088             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12089             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12090   ins_cost(180);
12091 
12092   format %{ "String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12093             " -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1" %}
12094   ins_encode %{
12095     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12096     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12097     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12098     guarantee(needle_values, "sanity");
12099     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
12100     __ string_indexof_char($result$$Register,
12101                            $haystack$$Register, $haycnt$$Register,
12102                            R0, chr,
12103                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12104   %}
12105   ins_pipe(pipe_class_compare);
12106 %}
12107 
12108 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
12109                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
12110                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
12111   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
12112   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
12113   ins_cost(180);
12114 
12115   format %{ "String IndexOfChar $haystack[0..$haycnt], $ch"
12116             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1" %}
12117   ins_encode %{
12118     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12119     __ string_indexof_char($result$$Register,
12120                            $haystack$$Register, $haycnt$$Register,
12121                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
12122                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
12123   %}
12124   ins_pipe(pipe_class_compare);
12125 %}
12126 
12127 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
12128                        iRegPsrc needle, uimmI15 needlecntImm,
12129                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
12130                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12131   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12132   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
12133          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12134   // Required for EA: check if it is still a type_array.
12135   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
12136             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12137             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12138   ins_cost(250);
12139 
12140   format %{ "String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12141             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1" %}
12142   ins_encode %{
12143     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12144     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12145     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12146 
12147     __ string_indexof($result$$Register,
12148                       $haystack$$Register, $haycnt$$Register,
12149                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
12150                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
12151   %}
12152   ins_pipe(pipe_class_compare);
12153 %}
12154 
12155 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
12156                        iRegPsrc needle, uimmI15 needlecntImm,
12157                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
12158                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12159   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12160   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
12161          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12162   // Required for EA: check if it is still a type_array.
12163   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
12164             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12165             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12166   ins_cost(250);
12167 
12168   format %{ "String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12169             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1" %}
12170   ins_encode %{
12171     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12172     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12173     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12174 
12175     __ string_indexof($result$$Register,
12176                       $haystack$$Register, $haycnt$$Register,
12177                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
12178                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
12179   %}
12180   ins_pipe(pipe_class_compare);
12181 %}
12182 
12183 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
12184                         iRegPsrc needle, uimmI15 needlecntImm,
12185                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
12186                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12187   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
12188   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
12189          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12190   // Required for EA: check if it is still a type_array.
12191   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
12192             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
12193             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
12194   ins_cost(250);
12195 
12196   format %{ "String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]"
12197             " -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1" %}
12198   ins_encode %{
12199     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12200     Node *ndl = in(operand_index($needle));  // The node that defines needle.
12201     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
12202 
12203     __ string_indexof($result$$Register,
12204                       $haystack$$Register, $haycnt$$Register,
12205                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
12206                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
12207   %}
12208   ins_pipe(pipe_class_compare);
12209 %}
12210 
12211 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
12212                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
12213                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12214   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
12215   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
12216          TEMP_DEF result,
12217          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12218   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12219   ins_cost(300);
12220 
12221   format %{ "String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]"
12222              " -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1" %}
12223   ins_encode %{
12224     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12225     __ string_indexof($result$$Register,
12226                       $haystack$$Register, $haycnt$$Register,
12227                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
12228                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
12229   %}
12230   ins_pipe(pipe_class_compare);
12231 %}
12232 
12233 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
12234                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
12235                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12236   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
12237   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
12238          TEMP_DEF result,
12239          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12240   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12241   ins_cost(300);
12242 
12243   format %{ "String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]"
12244              " -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1" %}
12245   ins_encode %{
12246     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12247     __ string_indexof($result$$Register,
12248                       $haystack$$Register, $haycnt$$Register,
12249                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
12250                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
12251   %}
12252   ins_pipe(pipe_class_compare);
12253 %}
12254 
12255 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
12256                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
12257                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
12258   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
12259   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
12260          TEMP_DEF result,
12261          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
12262   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12263   ins_cost(300);
12264 
12265   format %{ "String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]"
12266              " -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1" %}
12267   ins_encode %{
12268     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12269     __ string_indexof($result$$Register,
12270                       $haystack$$Register, $haycnt$$Register,
12271                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
12272                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
12273   %}
12274   ins_pipe(pipe_class_compare);
12275 %}
12276 
12277 // char[] to byte[] compression
12278 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
12279                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
12280   match(Set result (StrCompressedCopy src (Binary dst len)));
12281   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
12282          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
12283   ins_cost(300);
12284   format %{ "String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5" %}
12285   ins_encode %{
12286     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12287     Label Lskip, Ldone;
12288     __ li($result$$Register, 0);
12289     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
12290                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
12291     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
12292     __ beq(CCR0, Lskip);
12293     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
12294     __ bind(Lskip);
12295     __ mr($result$$Register, $len$$Register);
12296     __ bind(Ldone);
12297   %}
12298   ins_pipe(pipe_class_default);
12299 %}
12300 
12301 // byte[] to char[] inflation
12302 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
12303                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
12304   match(Set dummy (StrInflatedCopy src (Binary dst len)));
12305   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
12306   ins_cost(300);
12307   format %{ "String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5" %}
12308   ins_encode %{
12309     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12310     Label Ldone;
12311     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
12312                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
12313     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
12314     __ beq(CCR0, Ldone);
12315     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
12316     __ bind(Ldone);
12317   %}
12318   ins_pipe(pipe_class_default);
12319 %}
12320 
12321 // StringCoding.java intrinsics
12322 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
12323                        regCTR ctr, flagsRegCR0 cr0)
12324 %{
12325   match(Set result (HasNegatives ary1 len));
12326   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
12327   ins_cost(300);
12328   format %{ "has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2" %}
12329   ins_encode %{
12330     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12331     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
12332                      $tmp1$$Register, $tmp2$$Register);
12333   %}
12334   ins_pipe(pipe_class_default);
12335 %}
12336 
12337 // encode char[] to byte[] in ISO_8859_1
12338 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
12339                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
12340   match(Set result (EncodeISOArray src (Binary dst len)));
12341   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
12342          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
12343   ins_cost(300);
12344   format %{ "Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5" %}
12345   ins_encode %{
12346     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12347     Label Lslow, Lfailure1, Lfailure2, Ldone;
12348     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
12349                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
12350     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
12351     __ beq(CCR0, Ldone);
12352     __ bind(Lslow);
12353     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
12354     __ li($result$$Register, 0);
12355     __ b(Ldone);
12356 
12357     __ bind(Lfailure1);
12358     __ mr($result$$Register, $len$$Register);
12359     __ mfctr($tmp1$$Register);
12360     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
12361     __ beq(CCR0, Ldone);
12362     __ b(Lslow);
12363 
12364     __ bind(Lfailure2);
12365     __ mfctr($result$$Register); // Remaining characters.
12366 
12367     __ bind(Ldone);
12368     __ subf($result$$Register, $result$$Register, $len$$Register);
12369   %}
12370   ins_pipe(pipe_class_default);
12371 %}
12372 
12373 
12374 //---------- Min/Max Instructions ---------------------------------------------
12375 
12376 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
12377   match(Set dst (MinI src1 src2));
12378   ins_cost(DEFAULT_COST*6);
12379 
12380   expand %{
12381     iRegLdst src1s;
12382     iRegLdst src2s;
12383     iRegLdst diff;
12384     iRegLdst sm;
12385     iRegLdst doz; // difference or zero
12386     convI2L_reg(src1s, src1); // Ensure proper sign extension.
12387     convI2L_reg(src2s, src2); // Ensure proper sign extension.
12388     subL_reg_reg(diff, src2s, src1s);
12389     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
12390     signmask64L_regL(sm, diff);
12391     andL_reg_reg(doz, diff, sm); // &lt;=0
12392     addI_regL_regL(dst, doz, src1s);
12393   %}
12394 %}
12395 
12396 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
12397   match(Set dst (MinI src1 src2));
12398   effect(KILL cr0);
12399   predicate(VM_Version::has_isel());
12400   ins_cost(DEFAULT_COST*2);
12401 
12402   ins_encode %{
12403     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12404     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
12405     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
12406   %}
12407   ins_pipe(pipe_class_default);
12408 %}
12409 
12410 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
12411   match(Set dst (MaxI src1 src2));
12412   ins_cost(DEFAULT_COST*6);
12413 
12414   expand %{
12415     iRegLdst src1s;
12416     iRegLdst src2s;
12417     iRegLdst diff;
12418     iRegLdst sm;
12419     iRegLdst doz; // difference or zero
12420     convI2L_reg(src1s, src1); // Ensure proper sign extension.
12421     convI2L_reg(src2s, src2); // Ensure proper sign extension.
12422     subL_reg_reg(diff, src2s, src1s);
12423     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
12424     signmask64L_regL(sm, diff);
12425     andcL_reg_reg(doz, diff, sm); // &gt;=0
12426     addI_regL_regL(dst, doz, src1s);
12427   %}
12428 %}
12429 
12430 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
12431   match(Set dst (MaxI src1 src2));
12432   effect(KILL cr0);
12433   predicate(VM_Version::has_isel());
12434   ins_cost(DEFAULT_COST*2);
12435 
12436   ins_encode %{
12437     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12438     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
12439     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
12440   %}
12441   ins_pipe(pipe_class_default);
12442 %}
12443 
12444 //---------- Population Count Instructions ------------------------------------
12445 
12446 // Popcnt for Power7.
12447 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
12448   match(Set dst (PopCountI src));
12449   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
12450   ins_cost(DEFAULT_COST);
12451 
12452   format %{ "POPCNTW $dst, $src" %}
12453   size(4);
12454   ins_encode %{
12455     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
12456     __ popcntw($dst$$Register, $src$$Register);
12457   %}
12458   ins_pipe(pipe_class_default);
12459 %}
12460 
12461 // Popcnt for Power7.
12462 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
12463   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
12464   match(Set dst (PopCountL src));
12465   ins_cost(DEFAULT_COST);
12466 
12467   format %{ "POPCNTD $dst, $src" %}
12468   size(4);
12469   ins_encode %{
12470     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
12471     __ popcntd($dst$$Register, $src$$Register);
12472   %}
12473   ins_pipe(pipe_class_default);
12474 %}
12475 
12476 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
12477   match(Set dst (CountLeadingZerosI src));
12478   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
12479   ins_cost(DEFAULT_COST);
12480 
12481   format %{ "CNTLZW  $dst, $src" %}
12482   size(4);
12483   ins_encode %{
12484     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
12485     __ cntlzw($dst$$Register, $src$$Register);
12486   %}
12487   ins_pipe(pipe_class_default);
12488 %}
12489 
12490 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
12491   match(Set dst (CountLeadingZerosL src));
12492   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
12493   ins_cost(DEFAULT_COST);
12494 
12495   format %{ "CNTLZD  $dst, $src" %}
12496   size(4);
12497   ins_encode %{
12498     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
12499     __ cntlzd($dst$$Register, $src$$Register);
12500   %}
12501   ins_pipe(pipe_class_default);
12502 %}
12503 
12504 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
12505   // no match-rule, false predicate
12506   effect(DEF dst, USE src);
12507   predicate(false);
12508 
12509   format %{ "CNTLZD  $dst, $src" %}
12510   size(4);
12511   ins_encode %{
12512     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
12513     __ cntlzd($dst$$Register, $src$$Register);
12514   %}
12515   ins_pipe(pipe_class_default);
12516 %}
12517 
12518 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
12519   match(Set dst (CountTrailingZerosI src));
12520   predicate(UseCountLeadingZerosInstructionsPPC64);
12521   ins_cost(DEFAULT_COST);
12522 
12523   expand %{
12524     immI16 imm1 %{ (int)-1 %}
12525     immI16 imm2 %{ (int)32 %}
12526     immI_minus1 m1 %{ -1 %}
12527     iRegIdst tmpI1;
12528     iRegIdst tmpI2;
12529     iRegIdst tmpI3;
12530     addI_reg_imm16(tmpI1, src, imm1);
12531     andcI_reg_reg(tmpI2, src, m1, tmpI1);
12532     countLeadingZerosI(tmpI3, tmpI2);
12533     subI_imm16_reg(dst, imm2, tmpI3);
12534   %}
12535 %}
12536 
12537 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
12538   match(Set dst (CountTrailingZerosL src));
12539   predicate(UseCountLeadingZerosInstructionsPPC64);
12540   ins_cost(DEFAULT_COST);
12541 
12542   expand %{
12543     immL16 imm1 %{ (long)-1 %}
12544     immI16 imm2 %{ (int)64 %}
12545     iRegLdst tmpL1;
12546     iRegLdst tmpL2;
12547     iRegIdst tmpL3;
12548     addL_reg_imm16(tmpL1, src, imm1);
12549     andcL_reg_reg(tmpL2, tmpL1, src);
12550     countLeadingZerosL(tmpL3, tmpL2);
12551     subI_imm16_reg(dst, imm2, tmpL3);
12552  %}
12553 %}
12554 
12555 // Expand nodes for byte_reverse_int.
12556 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
12557   effect(DEF dst, USE src, USE pos, USE shift);
12558   predicate(false);
12559 
12560   format %{ "INSRWI  $dst, $src, $pos, $shift" %}
12561   size(4);
12562   ins_encode %{
12563     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
12564     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
12565   %}
12566   ins_pipe(pipe_class_default);
12567 %}
12568 
12569 // As insrwi_a, but with USE_DEF.
12570 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
12571   effect(USE_DEF dst, USE src, USE pos, USE shift);
12572   predicate(false);
12573 
12574   format %{ "INSRWI  $dst, $src, $pos, $shift" %}
12575   size(4);
12576   ins_encode %{
12577     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
12578     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
12579   %}
12580   ins_pipe(pipe_class_default);
12581 %}
12582 
12583 // Just slightly faster than java implementation.
12584 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
12585   match(Set dst (ReverseBytesI src));
12586   predicate(UseCountLeadingZerosInstructionsPPC64);
12587   ins_cost(DEFAULT_COST);
12588 
12589   expand %{
12590     immI16 imm24 %{ (int) 24 %}
12591     immI16 imm16 %{ (int) 16 %}
12592     immI16  imm8 %{ (int)  8 %}
12593     immI16  imm4 %{ (int)  4 %}
12594     immI16  imm0 %{ (int)  0 %}
12595     iRegLdst tmpI1;
12596     iRegLdst tmpI2;
12597     iRegLdst tmpI3;
12598 
12599     urShiftI_reg_imm(tmpI1, src, imm24);
12600     insrwi_a(dst, tmpI1, imm24, imm8);
12601     urShiftI_reg_imm(tmpI2, src, imm16);
12602     insrwi(dst, tmpI2, imm8, imm16);
12603     urShiftI_reg_imm(tmpI3, src, imm8);
12604     insrwi(dst, tmpI3, imm8, imm8);
12605     insrwi(dst, src, imm0, imm8);
12606   %}
12607 %}
12608 
12609 //---------- Replicate Vector Instructions ------------------------------------
12610 
12611 // Insrdi does replicate if src == dst.
12612 instruct repl32(iRegLdst dst) %{
12613   predicate(false);
12614   effect(USE_DEF dst);
12615 
12616   format %{ "INSRDI  $dst, #0, $dst, #32 \t// replicate" %}
12617   size(4);
12618   ins_encode %{
12619     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
12620     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
12621   %}
12622   ins_pipe(pipe_class_default);
12623 %}
12624 
12625 // Insrdi does replicate if src == dst.
12626 instruct repl48(iRegLdst dst) %{
12627   predicate(false);
12628   effect(USE_DEF dst);
12629 
12630   format %{ "INSRDI  $dst, #0, $dst, #48 \t// replicate" %}
12631   size(4);
12632   ins_encode %{
12633     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
12634     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
12635   %}
12636   ins_pipe(pipe_class_default);
12637 %}
12638 
12639 // Insrdi does replicate if src == dst.
12640 instruct repl56(iRegLdst dst) %{
12641   predicate(false);
12642   effect(USE_DEF dst);
12643 
12644   format %{ "INSRDI  $dst, #0, $dst, #56 \t// replicate" %}
12645   size(4);
12646   ins_encode %{
12647     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
12648     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
12649   %}
12650   ins_pipe(pipe_class_default);
12651 %}
12652 
12653 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
12654   match(Set dst (ReplicateB src));
12655   predicate(n-&gt;as_Vector()-&gt;length() == 8);
12656   expand %{
12657     moveReg(dst, src);
12658     repl56(dst);
12659     repl48(dst);
12660     repl32(dst);
12661   %}
12662 %}
12663 
12664 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
12665   match(Set dst (ReplicateB zero));
12666   predicate(n-&gt;as_Vector()-&gt;length() == 8);
12667   format %{ "LI      $dst, #0 \t// replicate8B" %}
12668   size(4);
12669   ins_encode %{
12670     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12671     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
12672   %}
12673   ins_pipe(pipe_class_default);
12674 %}
12675 
12676 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
12677   match(Set dst (ReplicateB src));
12678   predicate(n-&gt;as_Vector()-&gt;length() == 8);
12679   format %{ "LI      $dst, #-1 \t// replicate8B" %}
12680   size(4);
12681   ins_encode %{
12682     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12683     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
12684   %}
12685   ins_pipe(pipe_class_default);
12686 %}
12687 
12688 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
12689   match(Set dst (ReplicateS src));
12690   predicate(n-&gt;as_Vector()-&gt;length() == 4);
12691   expand %{
12692     moveReg(dst, src);
12693     repl48(dst);
12694     repl32(dst);
12695   %}
12696 %}
12697 
12698 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
12699   match(Set dst (ReplicateS zero));
12700   predicate(n-&gt;as_Vector()-&gt;length() == 4);
12701   format %{ "LI      $dst, #0 \t// replicate4C" %}
12702   size(4);
12703   ins_encode %{
12704     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12705     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
12706   %}
12707   ins_pipe(pipe_class_default);
12708 %}
12709 
12710 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
12711   match(Set dst (ReplicateS src));
12712   predicate(n-&gt;as_Vector()-&gt;length() == 4);
12713   format %{ "LI      $dst, -1 \t// replicate4C" %}
12714   size(4);
12715   ins_encode %{
12716     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12717     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
12718   %}
12719   ins_pipe(pipe_class_default);
12720 %}
12721 
12722 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
12723   match(Set dst (ReplicateI src));
12724   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12725   ins_cost(2 * DEFAULT_COST);
12726   expand %{
12727     moveReg(dst, src);
12728     repl32(dst);
12729   %}
12730 %}
12731 
12732 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
12733   match(Set dst (ReplicateI zero));
12734   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12735   format %{ "LI      $dst, #0 \t// replicate4C" %}
12736   size(4);
12737   ins_encode %{
12738     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12739     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
12740   %}
12741   ins_pipe(pipe_class_default);
12742 %}
12743 
12744 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
12745   match(Set dst (ReplicateI src));
12746   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12747   format %{ "LI      $dst, -1 \t// replicate4C" %}
12748   size(4);
12749   ins_encode %{
12750     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12751     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
12752   %}
12753   ins_pipe(pipe_class_default);
12754 %}
12755 
12756 // Move float to int register via stack, replicate.
12757 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
12758   match(Set dst (ReplicateF src));
12759   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12760   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
12761   expand %{
12762     stackSlotL tmpS;
12763     iRegIdst tmpI;
12764     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
12765     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
12766     moveReg(dst, tmpI);             // Move int to long reg.
12767     repl32(dst);                    // Replicate bitpattern.
12768   %}
12769 %}
12770 
12771 // Replicate scalar constant to packed float values in Double register
12772 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
12773   match(Set dst (ReplicateF src));
12774   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12775   ins_cost(5 * DEFAULT_COST);
12776 
12777   format %{ "LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded" %}
12778   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
12779 %}
12780 
12781 // Replicate scalar zero constant to packed float values in Double register
12782 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
12783   match(Set dst (ReplicateF zero));
12784   predicate(n-&gt;as_Vector()-&gt;length() == 2);
12785 
12786   format %{ "LI      $dst, #0 \t// replicate2F" %}
12787   ins_encode %{
12788     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
12789     __ li($dst$$Register, 0x0);
12790   %}
12791   ins_pipe(pipe_class_default);
12792 %}
12793 
12794 
12795 //----------Overflow Math Instructions-----------------------------------------
12796 
12797 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
12798 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
12799 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
12800 
12801 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
12802   match(Set cr0 (OverflowAddL op1 op2));
12803 
12804   format %{ "add_    $op1, $op2\t# overflow check long" %}
12805   ins_encode %{
12806     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12807     __ li(R0, 0);
12808     __ mtxer(R0); // clear XER.SO
12809     __ addo_(R0, $op1$$Register, $op2$$Register);
12810   %}
12811   ins_pipe(pipe_class_default);
12812 %}
12813 
12814 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
12815   match(Set cr0 (OverflowSubL op1 op2));
12816 
12817   format %{ "subfo_  R0, $op2, $op1\t# overflow check long" %}
12818   ins_encode %{
12819     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12820     __ li(R0, 0);
12821     __ mtxer(R0); // clear XER.SO
12822     __ subfo_(R0, $op2$$Register, $op1$$Register);
12823   %}
12824   ins_pipe(pipe_class_default);
12825 %}
12826 
12827 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
12828   match(Set cr0 (OverflowSubL zero op2));
12829 
12830   format %{ "nego_   R0, $op2\t# overflow check long" %}
12831   ins_encode %{
12832     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12833     __ li(R0, 0);
12834     __ mtxer(R0); // clear XER.SO
12835     __ nego_(R0, $op2$$Register);
12836   %}
12837   ins_pipe(pipe_class_default);
12838 %}
12839 
12840 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
12841   match(Set cr0 (OverflowMulL op1 op2));
12842 
12843   format %{ "mulldo_ R0, $op1, $op2\t# overflow check long" %}
12844   ins_encode %{
12845     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12846     __ li(R0, 0);
12847     __ mtxer(R0); // clear XER.SO
12848     __ mulldo_(R0, $op1$$Register, $op2$$Register);
12849   %}
12850   ins_pipe(pipe_class_default);
12851 %}
12852 
12853 
12854 // ============================================================================
12855 // Safepoint Instruction
12856 
12857 instruct safePoint_poll(iRegPdst poll) %{
12858   match(SafePoint poll);
12859   predicate(LoadPollAddressFromThread);
12860 
12861   // It caused problems to add the effect that r0 is killed, but this
12862   // effect no longer needs to be mentioned, since r0 is not contained
12863   // in a reg_class.
12864 
12865   format %{ "LD      R0, #0, $poll \t// Safepoint poll for GC" %}
12866   size(4);
12867   ins_encode( enc_poll(0x0, poll) );
12868   ins_pipe(pipe_class_default);
12869 %}
12870 
12871 // Safepoint without per-thread support. Load address of page to poll
12872 // as constant.
12873 // Rscratch2RegP is R12.
12874 // LoadConPollAddr node is added in pd_post_matching_hook(). It must be
12875 // a seperate node so that the oop map is at the right location.
12876 instruct safePoint_poll_conPollAddr(rscratch2RegP poll) %{
12877   match(SafePoint poll);
12878   predicate(!LoadPollAddressFromThread);
12879 
12880   // It caused problems to add the effect that r0 is killed, but this
12881   // effect no longer needs to be mentioned, since r0 is not contained
12882   // in a reg_class.
12883 
12884   format %{ "LD      R0, #0, R12 \t// Safepoint poll for GC" %}
12885   ins_encode( enc_poll(0x0, poll) );
12886   ins_pipe(pipe_class_default);
12887 %}
12888 
12889 // ============================================================================
12890 // Call Instructions
12891 
12892 // Call Java Static Instruction
12893 
12894 // Schedulable version of call static node.
12895 instruct CallStaticJavaDirect(method meth) %{
12896   match(CallStaticJava);
12897   effect(USE meth);
12898   ins_cost(CALL_COST);
12899 
12900   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
12901 
12902   format %{ "CALL,static $meth \t// ==&gt; " %}
12903   size(4);
12904   ins_encode( enc_java_static_call(meth) );
12905   ins_pipe(pipe_class_call);
12906 %}
12907 
12908 // Call Java Dynamic Instruction
12909 
12910 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
12911 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
12912 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
12913 // The call destination must still be placed in the constant pool.
12914 instruct CallDynamicJavaDirectSched(method meth) %{
12915   match(CallDynamicJava); // To get all the data fields we need ...
12916   effect(USE meth);
12917   predicate(false);       // ... but never match.
12918 
12919   ins_field_load_ic_hi_node(loadConL_hiNode*);
12920   ins_field_load_ic_node(loadConLNode*);
12921   ins_num_consts(1 /* 1 patchable constant: call destination */);
12922 
12923   format %{ "BL        \t// dynamic $meth ==&gt; " %}
12924   size(4);
12925   ins_encode( enc_java_dynamic_call_sched(meth) );
12926   ins_pipe(pipe_class_call);
12927 %}
12928 
12929 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
12930 // We use postalloc expanded calls if we use inline caches
12931 // and do not update method data.
12932 //
12933 // This instruction has two constants: inline cache (IC) and call destination.
12934 // Loading the inline cache will be postalloc expanded, thus leaving a call with
12935 // one constant.
12936 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
12937   match(CallDynamicJava);
12938   effect(USE meth);
12939   predicate(UseInlineCaches);
12940   ins_cost(CALL_COST);
12941 
12942   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
12943 
12944   format %{ "CALL,dynamic $meth \t// postalloc expanded" %}
12945   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
12946 %}
12947 
12948 // Compound version of call dynamic java
12949 // We use postalloc expanded calls if we use inline caches
12950 // and do not update method data.
12951 instruct CallDynamicJavaDirect(method meth) %{
12952   match(CallDynamicJava);
12953   effect(USE meth);
12954   predicate(!UseInlineCaches);
12955   ins_cost(CALL_COST);
12956 
12957   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
12958   ins_num_consts(4);
12959 
12960   format %{ "CALL,dynamic $meth \t// ==&gt; " %}
12961   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
12962   ins_pipe(pipe_class_call);
12963 %}
12964 
12965 // Call Runtime Instruction
12966 
12967 instruct CallRuntimeDirect(method meth) %{
12968   match(CallRuntime);
12969   effect(USE meth);
12970   ins_cost(CALL_COST);
12971 
12972   // Enc_java_to_runtime_call needs up to 3 constants: call target,
12973   // env for callee, C-toc.
12974   ins_num_consts(3);
12975 
12976   format %{ "CALL,runtime" %}
12977   ins_encode( enc_java_to_runtime_call(meth) );
12978   ins_pipe(pipe_class_call);
12979 %}
12980 
12981 // Call Leaf
12982 
12983 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
12984 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
12985   effect(DEF dst, USE src);
12986 
12987   ins_num_consts(1);
12988 
12989   format %{ "MTCTR   $src" %}
12990   size(4);
12991   ins_encode( enc_leaf_call_mtctr(src) );
12992   ins_pipe(pipe_class_default);
12993 %}
12994 
12995 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
12996 instruct CallLeafDirect(method meth) %{
12997   match(CallLeaf);   // To get the data all the data fields we need ...
12998   effect(USE meth);
12999   predicate(false);  // but never match.
13000 
13001   format %{ "BCTRL     \t// leaf call $meth ==&gt; " %}
13002   size(4);
13003   ins_encode %{
13004     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
13005     __ bctrl();
13006   %}
13007   ins_pipe(pipe_class_call);
13008 %}
13009 
13010 // postalloc expand of CallLeafDirect.
13011 // Load adress to call from TOC, then bl to it.
13012 instruct CallLeafDirect_Ex(method meth) %{
13013   match(CallLeaf);
13014   effect(USE meth);
13015   ins_cost(CALL_COST);
13016 
13017   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
13018   // env for callee, C-toc.
13019   ins_num_consts(3);
13020 
13021   format %{ "CALL,runtime leaf $meth \t// postalloc expanded" %}
13022   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
13023 %}
13024 
13025 // Call runtime without safepoint - same as CallLeaf.
13026 // postalloc expand of CallLeafNoFPDirect.
13027 // Load adress to call from TOC, then bl to it.
13028 instruct CallLeafNoFPDirect_Ex(method meth) %{
13029   match(CallLeafNoFP);
13030   effect(USE meth);
13031   ins_cost(CALL_COST);
13032 
13033   // Enc_java_to_runtime_call needs up to 3 constants: call target,
13034   // env for callee, C-toc.
13035   ins_num_consts(3);
13036 
13037   format %{ "CALL,runtime leaf nofp $meth \t// postalloc expanded" %}
13038   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
13039 %}
13040 
13041 // Tail Call; Jump from runtime stub to Java code.
13042 // Also known as an 'interprocedural jump'.
13043 // Target of jump will eventually return to caller.
13044 // TailJump below removes the return address.
13045 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
13046   match(TailCall jump_target method_oop);
13047   ins_cost(CALL_COST);
13048 
13049   format %{ "MTCTR   $jump_target \t// $method_oop holds method oop\n\t"
13050             "BCTR         \t// tail call" %}
13051   size(8);
13052   ins_encode %{
13053     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13054     __ mtctr($jump_target$$Register);
13055     __ bctr();
13056   %}
13057   ins_pipe(pipe_class_call);
13058 %}
13059 
13060 // Return Instruction
13061 instruct Ret() %{
13062   match(Return);
13063   format %{ "BLR      \t// branch to link register" %}
13064   size(4);
13065   ins_encode %{
13066     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
13067     // LR is restored in MachEpilogNode. Just do the RET here.
13068     __ blr();
13069   %}
13070   ins_pipe(pipe_class_default);
13071 %}
13072 
13073 // Tail Jump; remove the return address; jump to target.
13074 // TailCall above leaves the return address around.
13075 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
13076 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
13077 // "restore" before this instruction (in Epilogue), we need to materialize it
13078 // in %i0.
13079 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
13080   match(TailJump jump_target ex_oop);
13081   ins_cost(CALL_COST);
13082 
13083   format %{ "LD      R4_ARG2 = LR\n\t"
13084             "MTCTR   $jump_target\n\t"
13085             "BCTR     \t// TailJump, exception oop: $ex_oop" %}
13086   size(12);
13087   ins_encode %{
13088     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13089     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
13090     __ mtctr($jump_target$$Register);
13091     __ bctr();
13092   %}
13093   ins_pipe(pipe_class_call);
13094 %}
13095 
13096 // Create exception oop: created by stack-crawling runtime code.
13097 // Created exception is now available to this handler, and is setup
13098 // just prior to jumping to this handler. No code emitted.
13099 instruct CreateException(rarg1RegP ex_oop) %{
13100   match(Set ex_oop (CreateEx));
13101   ins_cost(0);
13102 
13103   format %{ " -- \t// exception oop; no code emitted" %}
13104   size(0);
13105   ins_encode( /*empty*/ );
13106   ins_pipe(pipe_class_default);
13107 %}
13108 
13109 // Rethrow exception: The exception oop will come in the first
13110 // argument position. Then JUMP (not call) to the rethrow stub code.
13111 instruct RethrowException() %{
13112   match(Rethrow);
13113   ins_cost(CALL_COST);
13114 
13115   format %{ "Jmp     rethrow_stub" %}
13116   ins_encode %{
13117     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13118     cbuf.set_insts_mark();
13119     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
13120   %}
13121   ins_pipe(pipe_class_call);
13122 %}
13123 
13124 // Die now.
13125 instruct ShouldNotReachHere() %{
13126   match(Halt);
13127   ins_cost(CALL_COST);
13128 
13129   format %{ "ShouldNotReachHere" %}
13130   size(4);
13131   ins_encode %{
13132     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
13133     __ trap_should_not_reach_here();
13134   %}
13135   ins_pipe(pipe_class_default);
13136 %}
13137 
13138 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
13139 // forces a 'TypeRawPtr::BOTTOM' output type for this guy.
13140 // Get a DEF on threadRegP, no costs, no encoding, use
13141 // 'ins_should_rematerialize(true)' to avoid spilling.
13142 instruct tlsLoadP(threadRegP dst) %{
13143   match(Set dst (ThreadLocal));
13144   ins_cost(0);
13145 
13146   ins_should_rematerialize(true);
13147 
13148   format %{ " -- \t// $dst=Thread::current(), empty" %}
13149   size(0);
13150   ins_encode( /*empty*/ );
13151   ins_pipe(pipe_class_empty);
13152 %}
13153 
13154 //---Some PPC specific nodes---------------------------------------------------
13155 
13156 // Stop a group.
13157 instruct endGroup() %{
13158   ins_cost(0);
13159 
13160   ins_is_nop(true);
13161 
13162   format %{ "End Bundle (ori r1, r1, 0)" %}
13163   size(4);
13164   ins_encode %{
13165     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
13166     __ endgroup();
13167   %}
13168   ins_pipe(pipe_class_default);
13169 %}
13170 
13171 // Nop instructions
13172 
13173 instruct fxNop() %{
13174   ins_cost(0);
13175 
13176   ins_is_nop(true);
13177 
13178   format %{ "fxNop" %}
13179   size(4);
13180   ins_encode %{
13181     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
13182     __ nop();
13183   %}
13184   ins_pipe(pipe_class_default);
13185 %}
13186 
13187 instruct fpNop0() %{
13188   ins_cost(0);
13189 
13190   ins_is_nop(true);
13191 
13192   format %{ "fpNop0" %}
13193   size(4);
13194   ins_encode %{
13195     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
13196     __ fpnop0();
13197   %}
13198   ins_pipe(pipe_class_default);
13199 %}
13200 
13201 instruct fpNop1() %{
13202   ins_cost(0);
13203 
13204   ins_is_nop(true);
13205 
13206   format %{ "fpNop1" %}
13207   size(4);
13208   ins_encode %{
13209     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
13210     __ fpnop1();
13211   %}
13212   ins_pipe(pipe_class_default);
13213 %}
13214 
13215 instruct brNop0() %{
13216   ins_cost(0);
13217   size(4);
13218   format %{ "brNop0" %}
13219   ins_encode %{
13220     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
13221     __ brnop0();
13222   %}
13223   ins_is_nop(true);
13224   ins_pipe(pipe_class_default);
13225 %}
13226 
13227 instruct brNop1() %{
13228   ins_cost(0);
13229 
13230   ins_is_nop(true);
13231 
13232   format %{ "brNop1" %}
13233   size(4);
13234   ins_encode %{
13235     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
13236     __ brnop1();
13237   %}
13238   ins_pipe(pipe_class_default);
13239 %}
13240 
13241 instruct brNop2() %{
13242   ins_cost(0);
13243 
13244   ins_is_nop(true);
13245 
13246   format %{ "brNop2" %}
13247   size(4);
13248   ins_encode %{
13249     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
13250     __ brnop2();
13251   %}
13252   ins_pipe(pipe_class_default);
13253 %}
13254 
13255 //----------PEEPHOLE RULES-----------------------------------------------------
13256 // These must follow all instruction definitions as they use the names
13257 // defined in the instructions definitions.
13258 //
13259 // peepmatch ( root_instr_name [preceeding_instruction]* );
13260 //
13261 // peepconstraint %{
13262 // (instruction_number.operand_name relational_op instruction_number.operand_name
13263 //  [, ...] );
13264 // // instruction numbers are zero-based using left to right order in peepmatch
13265 //
13266 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
13267 // // provide an instruction_number.operand_name for each operand that appears
13268 // // in the replacement instruction's match rule
13269 //
13270 // ---------VM FLAGS---------------------------------------------------------
13271 //
13272 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13273 //
13274 // Each peephole rule is given an identifying number starting with zero and
13275 // increasing by one in the order seen by the parser. An individual peephole
13276 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13277 // on the command-line.
13278 //
13279 // ---------CURRENT LIMITATIONS----------------------------------------------
13280 //
13281 // Only match adjacent instructions in same basic block
13282 // Only equality constraints
13283 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13284 // Only one replacement instruction
13285 //
13286 // ---------EXAMPLE----------------------------------------------------------
13287 //
13288 // // pertinent parts of existing instructions in architecture description
13289 // instruct movI(eRegI dst, eRegI src) %{
13290 //   match(Set dst (CopyI src));
13291 // %}
13292 //
13293 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
13294 //   match(Set dst (AddI dst src));
13295 //   effect(KILL cr);
13296 // %}
13297 //
13298 // // Change (inc mov) to lea
13299 // peephole %{
13300 //   // increment preceeded by register-register move
13301 //   peepmatch ( incI_eReg movI );
13302 //   // require that the destination register of the increment
13303 //   // match the destination register of the move
13304 //   peepconstraint ( 0.dst == 1.dst );
13305 //   // construct a replacement instruction that sets
13306 //   // the destination to ( move's source register + one )
13307 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13308 // %}
13309 //
13310 // Implementation no longer uses movX instructions since
13311 // machine-independent system no longer uses CopyX nodes.
13312 //
13313 // peephole %{
13314 //   peepmatch ( incI_eReg movI );
13315 //   peepconstraint ( 0.dst == 1.dst );
13316 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13317 // %}
13318 //
13319 // peephole %{
13320 //   peepmatch ( decI_eReg movI );
13321 //   peepconstraint ( 0.dst == 1.dst );
13322 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13323 // %}
13324 //
13325 // peephole %{
13326 //   peepmatch ( addI_eReg_imm movI );
13327 //   peepconstraint ( 0.dst == 1.dst );
13328 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13329 // %}
13330 //
13331 // peephole %{
13332 //   peepmatch ( addP_eReg_imm movP );
13333 //   peepconstraint ( 0.dst == 1.dst );
13334 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13335 // %}
13336 
13337 // // Change load of spilled value to only a spill
13338 // instruct storeI(memory mem, eRegI src) %{
13339 //   match(Set mem (StoreI mem src));
13340 // %}
13341 //
13342 // instruct loadI(eRegI dst, memory mem) %{
13343 //   match(Set dst (LoadI mem));
13344 // %}
13345 //
13346 peephole %{
13347   peepmatch ( loadI storeI );
13348   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13349   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13350 %}
13351 
13352 peephole %{
13353   peepmatch ( loadL storeL );
13354   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13355   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
13356 %}
13357 
13358 peephole %{
13359   peepmatch ( loadP storeP );
13360   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
13361   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
13362 %}
13363 
13364 //----------SMARTSPILL RULES---------------------------------------------------
13365 // These must follow all instruction definitions as they use the names
13366 // defined in the instructions definitions.
</pre></body></html>

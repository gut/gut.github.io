<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/cpu/ppc/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/cpu/ppc/vm/register_ppc.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/templateInterpreterGenerator_ppc.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/cpu/ppc/vm/stubGenerator_ppc.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12270">12270</a> : Reserve R30 to a cleared content register on C1 and C2 code

Several times a 0 is loaded to a register as a temporary value. This can be
improved by caching a 0 into a register.

I didn't notice a performance drop since only applying this patch showed no
drop of performance, hence there are more registers available than normally
needed and this caching technique can be applied.

Despite setting R30_zero as a dedicated register and initialized with 0 for the
C1 and C2 code, new rules for storing 0 related to stb,sth,stw,std were added.</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 247       // Set R15_prev_state to 0 for simplifying checks in callee.
 248       __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
 249       // Stack on entry to frame manager / native entry:
 250       //
 251       //      F0      [TOP_IJAVA_FRAME_ABI]
 252       //              alignment (optional)
 253       //              [outgoing Java arguments]
 254       //              [ENTRY_FRAME_LOCALS]
 255       //      F1      [C_FRAME]
 256       //              ...
 257       //
 258 
 259       // global toc register
 260       __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R11_scratch1);
 261       // Remember the senderSP so we interpreter can pop c2i arguments off of the stack
 262       // when called via a c2i.
 263 
 264       // Pass initial_caller_sp to framemanager.
 265       __ mr(R21_tmp1, R1_SP);
 266 



 267       // Do a light-weight C-call here, r_new_arg_entry holds the address
 268       // of the interpreter entry point (frame manager or native entry)
 269       // and save runtime-value of LR in return_address.
 270       assert(r_new_arg_entry != tos &amp;&amp; r_new_arg_entry != R19_method &amp;&amp; r_new_arg_entry != R16_thread,
 271              "trashed r_new_arg_entry");
 272       return_address = __ call_stub(r_new_arg_entry);
 273     }
 274 
 275     {
 276       BLOCK_COMMENT("Returned from frame manager or native entry.");
 277       // Returned from frame manager or native entry.
 278       // Now pop frame, process result, and return to caller.
 279 
 280       // Stack on exit from frame manager / native entry:
 281       //
 282       //      F0      [ABI]
 283       //              ...
 284       //              [ENTRY_FRAME_LOCALS]
 285       //      F1      [C_FRAME]
 286       //              ...

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 247       // Set R15_prev_state to 0 for simplifying checks in callee.
 248       __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
 249       // Stack on entry to frame manager / native entry:
 250       //
 251       //      F0      [TOP_IJAVA_FRAME_ABI]
 252       //              alignment (optional)
 253       //              [outgoing Java arguments]
 254       //              [ENTRY_FRAME_LOCALS]
 255       //      F1      [C_FRAME]
 256       //              ...
 257       //
 258 
 259       // global toc register
 260       __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R11_scratch1);
 261       // Remember the senderSP so we interpreter can pop c2i arguments off of the stack
 262       // when called via a c2i.
 263 
 264       // Pass initial_caller_sp to framemanager.
 265       __ mr(R21_tmp1, R1_SP);
 266 
<span class="new"> 267       // Zero the register that caches zero (optimization)</span>
<span class="new"> 268       __ li(R30_zero, 0);</span>
<span class="new"> 269 </span>
 270       // Do a light-weight C-call here, r_new_arg_entry holds the address
 271       // of the interpreter entry point (frame manager or native entry)
 272       // and save runtime-value of LR in return_address.
 273       assert(r_new_arg_entry != tos &amp;&amp; r_new_arg_entry != R19_method &amp;&amp; r_new_arg_entry != R16_thread,
 274              "trashed r_new_arg_entry");
 275       return_address = __ call_stub(r_new_arg_entry);
 276     }
 277 
 278     {
 279       BLOCK_COMMENT("Returned from frame manager or native entry.");
 280       // Returned from frame manager or native entry.
 281       // Now pop frame, process result, and return to caller.
 282 
 283       // Stack on exit from frame manager / native entry:
 284       //
 285       //      F0      [ABI]
 286       //              ...
 287       //              [ENTRY_FRAME_LOCALS]
 288       //      F1      [C_FRAME]
 289       //              ...

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/cpu/ppc/vm/register_ppc.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/templateInterpreterGenerator_ppc.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>

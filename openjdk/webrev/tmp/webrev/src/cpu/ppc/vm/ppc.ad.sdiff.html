<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/cpu/ppc/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/cpu/ppc/vm/c1_Runtime1_ppc.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/register_ppc.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/cpu/ppc/vm/ppc.ad</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12270">12270</a> : Reserve R30 to a cleared content register on C1 and C2 code

Several times a 0 is loaded to a register as a temporary value. This can be
improved by caching a 0 into a register.

I didn't notice a performance drop since only applying this patch showed no
drop of performance, hence there are more registers available than normally
needed and this caching technique can be applied.

Despite setting R30_zero as a dedicated register and initialized with 0 for the
C1 and C2 code, new rules for storing 0 related to stb,sth,stw,std were added.</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 283 
 284 alloc_class chunk0 (
 285   // Chunk0 contains *all* 64 integer registers halves.
 286 
 287   // "non-volatile" registers
 288   R14, R14_H,
 289   R15, R15_H,
 290   R17, R17_H,
 291   R18, R18_H,
 292   R19, R19_H,
 293   R20, R20_H,
 294   R21, R21_H,
 295   R22, R22_H,
 296   R23, R23_H,
 297   R24, R24_H,
 298   R25, R25_H,
 299   R26, R26_H,
 300   R27, R27_H,
 301   R28, R28_H,
 302   R29, R29_H,
<span class="removed"> 303   R30, R30_H,</span>
 304   R31, R31_H,
 305 
 306   // scratch/special registers
 307   R11, R11_H,
 308   R12, R12_H,
 309 
 310   // argument registers
 311   R10, R10_H,
 312   R9,  R9_H,
 313   R8,  R8_H,
 314   R7,  R7_H,
 315   R6,  R6_H,
 316   R5,  R5_H,
 317   R4,  R4_H,
 318   R3,  R3_H,
 319 
 320   // special registers, not available for allocation

 321   R16, R16_H,     // R16_thread
 322   R13, R13_H,     // system thread id
 323   R2,  R2_H,      // may be used for TOC
 324   R1,  R1_H,      // SP
 325   R0,  R0_H       // R0 (scratch)
 326 );
 327 
 328 // If you change this allocation class, please have a look at the
 329 // default values for the parameters RoundRobinIntegerRegIntervalStart
 330 // and RoundRobinFloatRegIntervalStart
 331 
 332 alloc_class chunk1 (
 333   // Chunk1 contains *all* 64 floating-point registers halves.
 334 
 335   // scratch register
 336   F0,  F0_H,
 337 
 338   // argument registers
 339   F13, F13_H,
 340   F12, F12_H,

</pre><hr></hr><pre>
 431   R10,
 432   R11,
 433   R12,
 434 /*R13*/             // system thread id
 435   R14,
 436   R15,
 437 /*R16*/             // R16_thread
 438   R17,
 439   R18,
 440   R19,
 441   R20,
 442   R21,
 443   R22,
 444   R23,
 445   R24,
 446   R25,
 447   R26,
 448   R27,
 449   R28,
 450 /*R29,*/             // global TOC
<span class="changed"> 451   R30,</span>
 452   R31
 453 );
 454 
 455 // 32 bit registers that can only be read i.e. these registers can
 456 // only be src of all instructions.
 457 reg_class bits32_reg_ro(
 458 /*R0*/              // R0
 459 /*R1*/              // SP
 460   R2                // TOC
 461   R3,
 462   R4,
 463   R5,
 464   R6,
 465   R7,
 466   R8,
 467   R9,
 468   R10,
 469   R11,
 470   R12,
 471 /*R13*/             // system thread id
 472   R14,
 473   R15,
 474 /*R16*/             // R16_thread
 475   R17,
 476   R18,
 477   R19,
 478   R20,
 479   R21,
 480   R22,
 481   R23,
 482   R24,
 483   R25,
 484   R26,
 485   R27,
 486   R28,
 487 /*R29,*/
<span class="changed"> 488   R30,</span>
 489   R31
 490 );
 491 
 492 reg_class rscratch1_bits32_reg(R11);
 493 reg_class rscratch2_bits32_reg(R12);
 494 reg_class rarg1_bits32_reg(R3);
 495 reg_class rarg2_bits32_reg(R4);
 496 reg_class rarg3_bits32_reg(R5);
 497 reg_class rarg4_bits32_reg(R6);
 498 
 499 // ----------------------------
 500 // 64 Bit Register Classes
 501 // ----------------------------
 502 // 64-bit build means 64-bit pointers means hi/lo pairs
 503 
 504 reg_class rscratch1_bits64_reg(R11_H, R11);
 505 reg_class rscratch2_bits64_reg(R12_H, R12);
 506 reg_class rarg1_bits64_reg(R3_H, R3);
 507 reg_class rarg2_bits64_reg(R4_H, R4);
 508 reg_class rarg3_bits64_reg(R5_H, R5);

</pre><hr></hr><pre>
 528   R10_H, R10,
 529   R11_H, R11,
 530   R12_H, R12,
 531 /*R13_H, R13*/   // system thread id
 532   R14_H, R14,
 533   R15_H, R15,
 534 /*R16_H, R16*/   // R16_thread
 535   R17_H, R17,
 536   R18_H, R18,
 537   R19_H, R19,
 538   R20_H, R20,
 539   R21_H, R21,
 540   R22_H, R22,
 541   R23_H, R23,
 542   R24_H, R24,
 543   R25_H, R25,
 544   R26_H, R26,
 545   R27_H, R27,
 546   R28_H, R28,
 547 /*R29_H, R29,*/
<span class="changed"> 548   R30_H, R30,</span>
 549   R31_H, R31
 550 );
 551 
 552 // 64 bit registers used excluding r2, r11 and r12
 553 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
 554 // r2, r11 and r12 internally.
 555 reg_class bits64_reg_leaf_call(
 556 /*R0_H,  R0*/     // R0
 557 /*R1_H,  R1*/     // SP
 558 /*R2_H,  R2*/     // TOC
 559   R3_H,  R3,
 560   R4_H,  R4,
 561   R5_H,  R5,
 562   R6_H,  R6,
 563   R7_H,  R7,
 564   R8_H,  R8,
 565   R9_H,  R9,
 566   R10_H, R10,
 567 /*R11_H, R11*/
 568 /*R12_H, R12*/
 569 /*R13_H, R13*/   // system thread id
 570   R14_H, R14,
 571   R15_H, R15,
 572 /*R16_H, R16*/   // R16_thread
 573   R17_H, R17,
 574   R18_H, R18,
 575   R19_H, R19,
 576   R20_H, R20,
 577   R21_H, R21,
 578   R22_H, R22,
 579   R23_H, R23,
 580   R24_H, R24,
 581   R25_H, R25,
 582   R26_H, R26,
 583   R27_H, R27,
 584   R28_H, R28,
 585 /*R29_H, R29,*/
<span class="changed"> 586   R30_H, R30,</span>
 587   R31_H, R31
 588 );
 589 
 590 // Used to hold the TOC to avoid collisions with expanded DynamicCall
 591 // which uses r19 as inline cache internally and expanded LeafCall which uses
 592 // r2, r11 and r12 internally.
 593 reg_class bits64_constant_table_base(
 594 /*R0_H,  R0*/     // R0
 595 /*R1_H,  R1*/     // SP
 596 /*R2_H,  R2*/     // TOC
 597   R3_H,  R3,
 598   R4_H,  R4,
 599   R5_H,  R5,
 600   R6_H,  R6,
 601   R7_H,  R7,
 602   R8_H,  R8,
 603   R9_H,  R9,
 604   R10_H, R10,
 605 /*R11_H, R11*/
 606 /*R12_H, R12*/
 607 /*R13_H, R13*/   // system thread id
 608   R14_H, R14,
 609   R15_H, R15,
 610 /*R16_H, R16*/   // R16_thread
 611   R17_H, R17,
 612   R18_H, R18,
 613 /*R19_H, R19*/
 614   R20_H, R20,
 615   R21_H, R21,
 616   R22_H, R22,
 617   R23_H, R23,
 618   R24_H, R24,
 619   R25_H, R25,
 620   R26_H, R26,
 621   R27_H, R27,
 622   R28_H, R28,
 623 /*R29_H, R29,*/
<span class="changed"> 624   R30_H, R30,</span>
 625   R31_H, R31
 626 );
 627 
 628 // 64 bit registers that can only be read i.e. these registers can
 629 // only be src of all instructions.
 630 reg_class bits64_reg_ro(
 631 /*R0_H,  R0*/     // R0
 632   R1_H,  R1,
 633   R2_H,  R2,       // TOC
 634   R3_H,  R3,
 635   R4_H,  R4,
 636   R5_H,  R5,
 637   R6_H,  R6,
 638   R7_H,  R7,
 639   R8_H,  R8,
 640   R9_H,  R9,
 641   R10_H, R10,
 642   R11_H, R11,
 643   R12_H, R12,
 644 /*R13_H, R13*/   // system thread id
 645   R14_H, R14,
 646   R15_H, R15,
 647   R16_H, R16,    // R16_thread
 648   R17_H, R17,
 649   R18_H, R18,
 650   R19_H, R19,
 651   R20_H, R20,
 652   R21_H, R21,
 653   R22_H, R22,
 654   R23_H, R23,
 655   R24_H, R24,
 656   R25_H, R25,
 657   R26_H, R26,
 658   R27_H, R27,
 659   R28_H, R28,
 660 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
<span class="changed"> 661   R30_H, R30,</span>
 662   R31_H, R31
 663 );
 664 
 665 
 666 // ----------------------------
 667 // Special Class for Condition Code Flags Register
 668 
 669 reg_class int_flags(
 670 /*CCR0*/             // scratch
 671 /*CCR1*/             // scratch
 672 /*CCR2*/             // nv!
 673 /*CCR3*/             // nv!
 674 /*CCR4*/             // nv!
 675   CCR5,
 676   CCR6,
 677   CCR7
 678 );
 679 
 680 reg_class int_flags_ro(
 681   CCR0,

</pre><hr></hr><pre>
6263   ins_pipe(pipe_class_memory);
6264 %}
6265 
6266 //----------Store Instructions-------------------------------------------------
6267 
6268 // Store Byte
6269 instruct storeB(memory mem, iRegIsrc src) %{
6270   match(Set mem (StoreB mem src));
6271   ins_cost(MEMORY_REF_COST);
6272 
6273   format %{ "STB     $src, $mem \t// byte" %}
6274   size(4);
6275   ins_encode %{
6276     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
6277     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6278     __ stb($src$$Register, Idisp, $mem$$base$$Register);
6279   %}
6280   ins_pipe(pipe_class_memory);
6281 %}
6282 














6283 // Store Char/Short
6284 instruct storeC(memory mem, iRegIsrc src) %{
6285   match(Set mem (StoreC mem src));
6286   ins_cost(MEMORY_REF_COST);
6287 
6288   format %{ "STH     $src, $mem \t// short" %}
6289   size(4);
6290   ins_encode %{
6291     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
6292     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6293     __ sth($src$$Register, Idisp, $mem$$base$$Register);
6294   %}
6295   ins_pipe(pipe_class_memory);
6296 %}
6297 














6298 // Store Integer
6299 instruct storeI(memory mem, iRegIsrc src) %{
6300   match(Set mem (StoreI mem src));
6301   ins_cost(MEMORY_REF_COST);
6302 
6303   format %{ "STW     $src, $mem" %}
6304   size(4);
6305   ins_encode( enc_stw(src, mem) );
6306   ins_pipe(pipe_class_memory);
6307 %}
6308 













6309 // ConvL2I + StoreI.
6310 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
6311   match(Set mem (StoreI mem (ConvL2I src)));
6312   ins_cost(MEMORY_REF_COST);
6313 
6314   format %{ "STW     l2i($src), $mem" %}
6315   size(4);
6316   ins_encode( enc_stw(src, mem) );
6317   ins_pipe(pipe_class_memory);
6318 %}
6319 
6320 // Store Long
6321 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
6322   match(Set mem (StoreL mem src));
6323   ins_cost(MEMORY_REF_COST);
6324 
6325   format %{ "STD     $src, $mem \t// long" %}
6326   size(4);
6327   ins_encode( enc_std(src, mem) );















6328   ins_pipe(pipe_class_memory);
6329 %}
6330 
6331 // Store super word nodes.
6332 
6333 // Store Aligned Packed Byte long register to memory
6334 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
6335   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
6336   match(Set mem (StoreVector mem src));
6337   ins_cost(MEMORY_REF_COST);
6338 
6339   format %{ "STD     $mem, $src \t// packed8B" %}
6340   size(4);
6341   ins_encode( enc_std(src, mem) );
6342   ins_pipe(pipe_class_memory);
6343 %}
6344 
6345 // Store Compressed Oop
6346 instruct storeN(memory dst, iRegN_P2N src) %{
6347   match(Set dst (StoreN dst src));

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 283 
 284 alloc_class chunk0 (
 285   // Chunk0 contains *all* 64 integer registers halves.
 286 
 287   // "non-volatile" registers
 288   R14, R14_H,
 289   R15, R15_H,
 290   R17, R17_H,
 291   R18, R18_H,
 292   R19, R19_H,
 293   R20, R20_H,
 294   R21, R21_H,
 295   R22, R22_H,
 296   R23, R23_H,
 297   R24, R24_H,
 298   R25, R25_H,
 299   R26, R26_H,
 300   R27, R27_H,
 301   R28, R28_H,
 302   R29, R29_H,

 303   R31, R31_H,
 304 
 305   // scratch/special registers
 306   R11, R11_H,
 307   R12, R12_H,
 308 
 309   // argument registers
 310   R10, R10_H,
 311   R9,  R9_H,
 312   R8,  R8_H,
 313   R7,  R7_H,
 314   R6,  R6_H,
 315   R5,  R5_H,
 316   R4,  R4_H,
 317   R3,  R3_H,
 318 
 319   // special registers, not available for allocation
<span class="new"> 320   R30, R30_H,     // R30_zero</span>
 321   R16, R16_H,     // R16_thread
 322   R13, R13_H,     // system thread id
 323   R2,  R2_H,      // may be used for TOC
 324   R1,  R1_H,      // SP
 325   R0,  R0_H       // R0 (scratch)
 326 );
 327 
 328 // If you change this allocation class, please have a look at the
 329 // default values for the parameters RoundRobinIntegerRegIntervalStart
 330 // and RoundRobinFloatRegIntervalStart
 331 
 332 alloc_class chunk1 (
 333   // Chunk1 contains *all* 64 floating-point registers halves.
 334 
 335   // scratch register
 336   F0,  F0_H,
 337 
 338   // argument registers
 339   F13, F13_H,
 340   F12, F12_H,

</pre><hr></hr><pre>
 431   R10,
 432   R11,
 433   R12,
 434 /*R13*/             // system thread id
 435   R14,
 436   R15,
 437 /*R16*/             // R16_thread
 438   R17,
 439   R18,
 440   R19,
 441   R20,
 442   R21,
 443   R22,
 444   R23,
 445   R24,
 446   R25,
 447   R26,
 448   R27,
 449   R28,
 450 /*R29,*/             // global TOC
<span class="changed"> 451 /*R30,*/             // R30_zero</span>
 452   R31
 453 );
 454 
 455 // 32 bit registers that can only be read i.e. these registers can
 456 // only be src of all instructions.
 457 reg_class bits32_reg_ro(
 458 /*R0*/              // R0
 459 /*R1*/              // SP
 460   R2                // TOC
 461   R3,
 462   R4,
 463   R5,
 464   R6,
 465   R7,
 466   R8,
 467   R9,
 468   R10,
 469   R11,
 470   R12,
 471 /*R13*/             // system thread id
 472   R14,
 473   R15,
 474 /*R16*/             // R16_thread
 475   R17,
 476   R18,
 477   R19,
 478   R20,
 479   R21,
 480   R22,
 481   R23,
 482   R24,
 483   R25,
 484   R26,
 485   R27,
 486   R28,
 487 /*R29,*/
<span class="changed"> 488 /*R30,*/            // R30_zero</span>
 489   R31
 490 );
 491 
 492 reg_class rscratch1_bits32_reg(R11);
 493 reg_class rscratch2_bits32_reg(R12);
 494 reg_class rarg1_bits32_reg(R3);
 495 reg_class rarg2_bits32_reg(R4);
 496 reg_class rarg3_bits32_reg(R5);
 497 reg_class rarg4_bits32_reg(R6);
 498 
 499 // ----------------------------
 500 // 64 Bit Register Classes
 501 // ----------------------------
 502 // 64-bit build means 64-bit pointers means hi/lo pairs
 503 
 504 reg_class rscratch1_bits64_reg(R11_H, R11);
 505 reg_class rscratch2_bits64_reg(R12_H, R12);
 506 reg_class rarg1_bits64_reg(R3_H, R3);
 507 reg_class rarg2_bits64_reg(R4_H, R4);
 508 reg_class rarg3_bits64_reg(R5_H, R5);

</pre><hr></hr><pre>
 528   R10_H, R10,
 529   R11_H, R11,
 530   R12_H, R12,
 531 /*R13_H, R13*/   // system thread id
 532   R14_H, R14,
 533   R15_H, R15,
 534 /*R16_H, R16*/   // R16_thread
 535   R17_H, R17,
 536   R18_H, R18,
 537   R19_H, R19,
 538   R20_H, R20,
 539   R21_H, R21,
 540   R22_H, R22,
 541   R23_H, R23,
 542   R24_H, R24,
 543   R25_H, R25,
 544   R26_H, R26,
 545   R27_H, R27,
 546   R28_H, R28,
 547 /*R29_H, R29,*/
<span class="changed"> 548 /*R30_H, R30,*/  // R30_zero</span>
 549   R31_H, R31
 550 );
 551 
 552 // 64 bit registers used excluding r2, r11 and r12
 553 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
 554 // r2, r11 and r12 internally.
 555 reg_class bits64_reg_leaf_call(
 556 /*R0_H,  R0*/     // R0
 557 /*R1_H,  R1*/     // SP
 558 /*R2_H,  R2*/     // TOC
 559   R3_H,  R3,
 560   R4_H,  R4,
 561   R5_H,  R5,
 562   R6_H,  R6,
 563   R7_H,  R7,
 564   R8_H,  R8,
 565   R9_H,  R9,
 566   R10_H, R10,
 567 /*R11_H, R11*/
 568 /*R12_H, R12*/
 569 /*R13_H, R13*/   // system thread id
 570   R14_H, R14,
 571   R15_H, R15,
 572 /*R16_H, R16*/   // R16_thread
 573   R17_H, R17,
 574   R18_H, R18,
 575   R19_H, R19,
 576   R20_H, R20,
 577   R21_H, R21,
 578   R22_H, R22,
 579   R23_H, R23,
 580   R24_H, R24,
 581   R25_H, R25,
 582   R26_H, R26,
 583   R27_H, R27,
 584   R28_H, R28,
 585 /*R29_H, R29,*/
<span class="changed"> 586 /*R30_H, R30,*/  // R30_zero</span>
 587   R31_H, R31
 588 );
 589 
 590 // Used to hold the TOC to avoid collisions with expanded DynamicCall
 591 // which uses r19 as inline cache internally and expanded LeafCall which uses
 592 // r2, r11 and r12 internally.
 593 reg_class bits64_constant_table_base(
 594 /*R0_H,  R0*/     // R0
 595 /*R1_H,  R1*/     // SP
 596 /*R2_H,  R2*/     // TOC
 597   R3_H,  R3,
 598   R4_H,  R4,
 599   R5_H,  R5,
 600   R6_H,  R6,
 601   R7_H,  R7,
 602   R8_H,  R8,
 603   R9_H,  R9,
 604   R10_H, R10,
 605 /*R11_H, R11*/
 606 /*R12_H, R12*/
 607 /*R13_H, R13*/   // system thread id
 608   R14_H, R14,
 609   R15_H, R15,
 610 /*R16_H, R16*/   // R16_thread
 611   R17_H, R17,
 612   R18_H, R18,
 613 /*R19_H, R19*/
 614   R20_H, R20,
 615   R21_H, R21,
 616   R22_H, R22,
 617   R23_H, R23,
 618   R24_H, R24,
 619   R25_H, R25,
 620   R26_H, R26,
 621   R27_H, R27,
 622   R28_H, R28,
 623 /*R29_H, R29,*/
<span class="changed"> 624 /*R30_H, R30,*/  // R30_zero</span>
 625   R31_H, R31
 626 );
 627 
 628 // 64 bit registers that can only be read i.e. these registers can
 629 // only be src of all instructions.
 630 reg_class bits64_reg_ro(
 631 /*R0_H,  R0*/     // R0
 632   R1_H,  R1,
 633   R2_H,  R2,       // TOC
 634   R3_H,  R3,
 635   R4_H,  R4,
 636   R5_H,  R5,
 637   R6_H,  R6,
 638   R7_H,  R7,
 639   R8_H,  R8,
 640   R9_H,  R9,
 641   R10_H, R10,
 642   R11_H, R11,
 643   R12_H, R12,
 644 /*R13_H, R13*/   // system thread id
 645   R14_H, R14,
 646   R15_H, R15,
 647   R16_H, R16,    // R16_thread
 648   R17_H, R17,
 649   R18_H, R18,
 650   R19_H, R19,
 651   R20_H, R20,
 652   R21_H, R21,
 653   R22_H, R22,
 654   R23_H, R23,
 655   R24_H, R24,
 656   R25_H, R25,
 657   R26_H, R26,
 658   R27_H, R27,
 659   R28_H, R28,
 660 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
<span class="changed"> 661 /*R30_H, R30,*/  // R30_zero</span>
 662   R31_H, R31
 663 );
 664 
 665 
 666 // ----------------------------
 667 // Special Class for Condition Code Flags Register
 668 
 669 reg_class int_flags(
 670 /*CCR0*/             // scratch
 671 /*CCR1*/             // scratch
 672 /*CCR2*/             // nv!
 673 /*CCR3*/             // nv!
 674 /*CCR4*/             // nv!
 675   CCR5,
 676   CCR6,
 677   CCR7
 678 );
 679 
 680 reg_class int_flags_ro(
 681   CCR0,

</pre><hr></hr><pre>
6263   ins_pipe(pipe_class_memory);
6264 %}
6265 
6266 //----------Store Instructions-------------------------------------------------
6267 
6268 // Store Byte
6269 instruct storeB(memory mem, iRegIsrc src) %{
6270   match(Set mem (StoreB mem src));
6271   ins_cost(MEMORY_REF_COST);
6272 
6273   format %{ "STB     $src, $mem \t// byte" %}
6274   size(4);
6275   ins_encode %{
6276     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
6277     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6278     __ stb($src$$Register, Idisp, $mem$$base$$Register);
6279   %}
6280   ins_pipe(pipe_class_memory);
6281 %}
6282 
<span class="new">6283 instruct storeB_0(memory mem, immI_0 zero) %{</span>
<span class="new">6284   match(Set mem (StoreB mem zero));</span>
<span class="new">6285   ins_cost(MEMORY_REF_COST);</span>
<span class="new">6286 </span>
<span class="new">6287   format %{ "STB     0, $mem \t// store 0 on a byte" %}</span>
<span class="new">6288   size(4);</span>
<span class="new">6289   ins_encode %{</span>
<span class="new">6290     // TODO: PPC port $archOpcode(ppc64Opcode_stb);</span>
<span class="new">6291     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);</span>
<span class="new">6292     __ stb(R30_zero, Idisp, $mem$$base$$Register);</span>
<span class="new">6293   %}</span>
<span class="new">6294   ins_pipe(pipe_class_memory);</span>
<span class="new">6295 %}</span>
<span class="new">6296 </span>
6297 // Store Char/Short
6298 instruct storeC(memory mem, iRegIsrc src) %{
6299   match(Set mem (StoreC mem src));
6300   ins_cost(MEMORY_REF_COST);
6301 
6302   format %{ "STH     $src, $mem \t// short" %}
6303   size(4);
6304   ins_encode %{
6305     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
6306     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
6307     __ sth($src$$Register, Idisp, $mem$$base$$Register);
6308   %}
6309   ins_pipe(pipe_class_memory);
6310 %}
6311 
<span class="new">6312 instruct storeC_0(memory mem, immI_0 zero) %{</span>
<span class="new">6313   match(Set mem (StoreC mem zero));</span>
<span class="new">6314   ins_cost(MEMORY_REF_COST);</span>
<span class="new">6315 </span>
<span class="new">6316   format %{ "STH     0, $mem \t// store 0 on a short" %}</span>
<span class="new">6317   size(4);</span>
<span class="new">6318   ins_encode %{</span>
<span class="new">6319     // TODO: PPC port $archOpcode(ppc64Opcode_sth);</span>
<span class="new">6320     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);</span>
<span class="new">6321     __ sth(R30_zero, Idisp, $mem$$base$$Register);</span>
<span class="new">6322   %}</span>
<span class="new">6323   ins_pipe(pipe_class_memory);</span>
<span class="new">6324 %}</span>
<span class="new">6325 </span>
6326 // Store Integer
6327 instruct storeI(memory mem, iRegIsrc src) %{
6328   match(Set mem (StoreI mem src));
6329   ins_cost(MEMORY_REF_COST);
6330 
6331   format %{ "STW     $src, $mem" %}
6332   size(4);
6333   ins_encode( enc_stw(src, mem) );
6334   ins_pipe(pipe_class_memory);
6335 %}
6336 
<span class="new">6337 instruct storeI_0(memory mem, immI_0 zero) %{</span>
<span class="new">6338   match(Set mem (StoreI mem zero));</span>
<span class="new">6339   ins_cost(MEMORY_REF_COST);</span>
<span class="new">6340 </span>
<span class="new">6341   format %{ "STW     0, $mem \t// store 0 on a word" %}</span>
<span class="new">6342   size(4);</span>
<span class="new">6343   ins_encode %{</span>
<span class="new">6344     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);</span>
<span class="new">6345     __ stw(R30_zero, Idisp, $mem$$base$$Register);</span>
<span class="new">6346   %}</span>
<span class="new">6347   ins_pipe(pipe_class_memory);</span>
<span class="new">6348 %}</span>
<span class="new">6349 </span>
6350 // ConvL2I + StoreI.
6351 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
6352   match(Set mem (StoreI mem (ConvL2I src)));
6353   ins_cost(MEMORY_REF_COST);
6354 
6355   format %{ "STW     l2i($src), $mem" %}
6356   size(4);
6357   ins_encode( enc_stw(src, mem) );
6358   ins_pipe(pipe_class_memory);
6359 %}
6360 
6361 // Store Long
6362 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
6363   match(Set mem (StoreL mem src));
6364   ins_cost(MEMORY_REF_COST);
6365 
6366   format %{ "STD     $src, $mem \t// long" %}
6367   size(4);
6368   ins_encode( enc_std(src, mem) );
<span class="new">6369   ins_pipe(pipe_class_memory);</span>
<span class="new">6370 %}</span>
<span class="new">6371 </span>
<span class="new">6372 instruct storeL_0(memoryAlg4 mem, immL_0 zero) %{</span>
<span class="new">6373   match(Set mem (StoreL mem zero));</span>
<span class="new">6374   ins_cost(MEMORY_REF_COST);</span>
<span class="new">6375 </span>
<span class="new">6376   format %{ "STD     0, $mem \t// store 0 on a long" %}</span>
<span class="new">6377   size(4);</span>
<span class="new">6378   ins_encode %{</span>
<span class="new">6379     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);</span>
<span class="new">6380     // Operand 'ds' requires 4-alignment.</span>
<span class="new">6381     assert((Idisp &amp; 0x3) == 0, "unaligned offset");</span>
<span class="new">6382     __ std(R30_zero, Idisp, $mem$$base$$Register);</span>
<span class="new">6383   %}</span>
6384   ins_pipe(pipe_class_memory);
6385 %}
6386 
6387 // Store super word nodes.
6388 
6389 // Store Aligned Packed Byte long register to memory
6390 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
6391   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
6392   match(Set mem (StoreVector mem src));
6393   ins_cost(MEMORY_REF_COST);
6394 
6395   format %{ "STD     $mem, $src \t// packed8B" %}
6396   size(4);
6397   ins_encode( enc_std(src, mem) );
6398   ins_pipe(pipe_class_memory);
6399 %}
6400 
6401 // Store Compressed Oop
6402 instruct storeN(memory dst, iRegN_P2N src) %{
6403   match(Set dst (StoreN dst src));

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/cpu/ppc/vm/c1_Runtime1_ppc.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/register_ppc.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>

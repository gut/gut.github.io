<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/cpu/ppc/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/cpu/ppc/vm/c1_FrameMap_ppc.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/ppc.ad.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/cpu/ppc/vm/c1_Runtime1_ppc.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-12270">12270</a> : Reserve R30 to a cleared content register on C1 and C2 code

Several times a 0 is loaded to a register as a temporary value. This can be
improved by caching a 0 into a register.

I didn't notice a performance drop since only applying this patch showed no
drop of performance, hence there are more registers available than normally
needed and this caching technique can be applied.

Despite setting R30_zero as a dedicated register and initialized with 0 for the
C1 and C2 code, new rules for storing 0 related to stb,sth,stw,std were added.</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 564         oop_maps = generate_handle_exception(id, sasm);
 565       }
 566       break;
 567 
 568     case unwind_exception_id:
 569       {
 570         const Register Rexception    = R3 /*LIRGenerator::exceptionOopOpr()*/,
 571                        Rexception_pc = R4 /*LIRGenerator::exceptionPcOpr()*/,
 572                        Rexception_save = R31, Rcaller_sp = R30;
 573         __ set_info("unwind_exception", dont_gc_arguments);
 574 
 575         __ ld(Rcaller_sp, 0, R1_SP);
 576         __ push_frame_reg_args(0, R0); // dummy frame for C call
 577         __ mr(Rexception_save, Rexception); // save over C call
 578         __ ld(Rexception_pc, _abi(lr), Rcaller_sp); // return pc
 579         __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), R16_thread, Rexception_pc);
 580         __ verify_not_null_oop(Rexception_save);
 581         __ mtctr(R3_RET);
 582         __ ld(Rexception_pc, _abi(lr), Rcaller_sp); // return pc
 583         __ mr(R1_SP, Rcaller_sp); // Pop both frames at once.

 584         __ mr(Rexception, Rexception_save); // restore
 585         __ mtlr(Rexception_pc);
 586         __ bctr();
 587       }
 588       break;
 589 
 590     case throw_array_store_exception_id:
 591       {
 592         __ set_info("throw_array_store_exception", dont_gc_arguments);
 593         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_array_store_exception), true);
 594       }
 595       break;
 596 
 597     case throw_class_cast_exception_id:
 598       {
 599         __ set_info("throw_class_cast_exception", dont_gc_arguments);
 600         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_class_cast_exception), true);
 601       }
 602       break;
 603 

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 564         oop_maps = generate_handle_exception(id, sasm);
 565       }
 566       break;
 567 
 568     case unwind_exception_id:
 569       {
 570         const Register Rexception    = R3 /*LIRGenerator::exceptionOopOpr()*/,
 571                        Rexception_pc = R4 /*LIRGenerator::exceptionPcOpr()*/,
 572                        Rexception_save = R31, Rcaller_sp = R30;
 573         __ set_info("unwind_exception", dont_gc_arguments);
 574 
 575         __ ld(Rcaller_sp, 0, R1_SP);
 576         __ push_frame_reg_args(0, R0); // dummy frame for C call
 577         __ mr(Rexception_save, Rexception); // save over C call
 578         __ ld(Rexception_pc, _abi(lr), Rcaller_sp); // return pc
 579         __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), R16_thread, Rexception_pc);
 580         __ verify_not_null_oop(Rexception_save);
 581         __ mtctr(R3_RET);
 582         __ ld(Rexception_pc, _abi(lr), Rcaller_sp); // return pc
 583         __ mr(R1_SP, Rcaller_sp); // Pop both frames at once.
<span class="new"> 584         __ li(R30_zero, 0); // redefine R30 after Rcaller_sp usage</span>
 585         __ mr(Rexception, Rexception_save); // restore
 586         __ mtlr(Rexception_pc);
 587         __ bctr();
 588       }
 589       break;
 590 
 591     case throw_array_store_exception_id:
 592       {
 593         __ set_info("throw_array_store_exception", dont_gc_arguments);
 594         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_array_store_exception), true);
 595       }
 596       break;
 597 
 598     case throw_class_cast_exception_id:
 599       {
 600         __ set_info("throw_class_cast_exception", dont_gc_arguments);
 601         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_class_cast_exception), true);
 602       }
 603       break;
 604 

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/cpu/ppc/vm/c1_FrameMap_ppc.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/ppc.ad.sdiff.html' target='_top'>next &gt</a></center>
</body></html>

<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13550">13550</a> : PPC: Implement MulAdd and SquareToLen intrinsics</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2017 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_VM_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_VM_ASSEMBLER_PPC_HPP
  28 
  29 #include "asm/register.hpp"
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 class Address VALUE_OBJ_CLASS_SPEC {
  35  private:
  36   Register _base;         // Base register.
  37   Register _index;        // Index register.
  38   intptr_t _disp;         // Displacement.
  39 
  40  public:
  41   Address(Register b, Register i, address d = 0)
  42     : _base(b), _index(i), _disp((intptr_t)d) {
  43     assert(i == noreg || d == 0, "can't have both");
  44   }
  45 
  46   Address(Register b, address d = 0)
  47     : _base(b), _index(noreg), _disp((intptr_t)d) {}
  48 
  49   Address(Register b, intptr_t d)
  50     : _base(b), _index(noreg), _disp(d) {}
  51 
  52   Address(Register b, RegisterOrConstant roc)
  53     : _base(b), _index(noreg), _disp(0) {
  54     if (roc.is_constant()) _disp = roc.as_constant(); else _index = roc.as_register();
  55   }
  56 
  57   Address()
  58     : _base(noreg), _index(noreg), _disp(0) {}
  59 
  60   // accessors
  61   Register base()  const { return _base; }
  62   Register index() const { return _index; }
  63   int      disp()  const { return (int)_disp; }
  64   bool     is_const() const { return _base == noreg &amp;&amp; _index == noreg; }
  65 };
  66 
  67 class AddressLiteral VALUE_OBJ_CLASS_SPEC {
  68  private:
  69   address          _address;
  70   RelocationHolder _rspec;
  71 
  72   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  73     switch (rtype) {
  74     case relocInfo::external_word_type:
  75       return external_word_Relocation::spec(addr);
  76     case relocInfo::internal_word_type:
  77       return internal_word_Relocation::spec(addr);
  78     case relocInfo::opt_virtual_call_type:
  79       return opt_virtual_call_Relocation::spec();
  80     case relocInfo::static_call_type:
  81       return static_call_Relocation::spec();
  82     case relocInfo::runtime_call_type:
  83       return runtime_call_Relocation::spec();
  84     case relocInfo::none:
  85       return RelocationHolder();
  86     default:
  87       ShouldNotReachHere();
  88       return RelocationHolder();
  89     }
  90   }
  91 
  92  protected:
  93   // creation
  94   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  95 
  96  public:
  97   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  98     : _address(addr),
  99       _rspec(rspec) {}
 100 
 101   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 102     : _address((address) addr),
 103       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 104 
 105   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
 106     : _address((address) addr),
 107       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 108 
 109   intptr_t value() const { return (intptr_t) _address; }
 110 
 111   const RelocationHolder&amp; rspec() const { return _rspec; }
 112 };
 113 
 114 // Argument is an abstraction used to represent an outgoing
 115 // actual argument or an incoming formal parameter, whether
 116 // it resides in memory or in a register, in a manner consistent
 117 // with the PPC Application Binary Interface, or ABI. This is
 118 // often referred to as the native or C calling convention.
 119 
 120 class Argument VALUE_OBJ_CLASS_SPEC {
 121  private:
 122   int _number;  // The number of the argument.
 123  public:
 124   enum {
 125     // Only 8 registers may contain integer parameters.
 126     n_register_parameters = 8,
 127     // Can have up to 8 floating registers.
 128     n_float_register_parameters = 8,
 129 
 130     // PPC C calling conventions.
 131     // The first eight arguments are passed in int regs if they are int.
 132     n_int_register_parameters_c = 8,
 133     // The first thirteen float arguments are passed in float regs.
 134     n_float_register_parameters_c = 13,
 135     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 136     // shows that xlC places all float args after argument 8 on the stack AND
 137     // in a register. This is not documented, but we follow this convention, too.
 138     n_regs_not_on_stack_c = 8,
 139   };
 140   // creation
 141   Argument(int number) : _number(number) {}
 142 
 143   int  number() const { return _number; }
 144 
 145   // Locating register-based arguments:
 146   bool is_register() const { return _number &lt; n_register_parameters; }
 147 
 148   Register as_register() const {
 149     assert(is_register(), "must be a register argument");
 150     return as_Register(number() + R3_ARG1-&gt;encoding());
 151   }
 152 };
 153 
 154 #if !defined(ABI_ELFv2)
 155 // A ppc64 function descriptor.
 156 struct FunctionDescriptor VALUE_OBJ_CLASS_SPEC {
 157  private:
 158   address _entry;
 159   address _toc;
 160   address _env;
 161 
 162  public:
 163   inline address entry() const { return _entry; }
 164   inline address toc()   const { return _toc; }
 165   inline address env()   const { return _env; }
 166 
 167   inline void set_entry(address entry) { _entry = entry; }
 168   inline void set_toc(  address toc)   { _toc   = toc; }
 169   inline void set_env(  address env)   { _env   = env; }
 170 
 171   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 172   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 173   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 174 
 175   // Friend functions can be called without loading toc and env.
 176   enum {
 177     friend_toc = 0xcafe,
 178     friend_env = 0xc0de
 179   };
 180 
 181   inline bool is_friend_function() const {
 182     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 183   }
 184 
 185   // Constructor for stack-allocated instances.
 186   FunctionDescriptor() {
 187     _entry = (address) 0xbad;
 188     _toc   = (address) 0xbad;
 189     _env   = (address) 0xbad;
 190   }
 191 };
 192 #endif
 193 
 194 
 195 // The PPC Assembler: Pure assembler doing NO optimizations on the
 196 // instruction level; i.e., what you write is what you get. The
 197 // Assembler is generating code into a CodeBuffer.
 198 
 199 class Assembler : public AbstractAssembler {
 200  protected:
 201   // Displacement routines
 202   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 203   static int  branch_destination(int inst, int pos);
 204 
 205   friend class AbstractAssembler;
 206 
 207   // Code patchers need various routines like inv_wdisp()
 208   friend class NativeInstruction;
 209   friend class NativeGeneralJump;
 210   friend class Relocation;
 211 
 212  public:
 213 
 214   enum shifts {
 215     XO_21_29_SHIFT = 2,
 216     XO_21_30_SHIFT = 1,
 217     XO_27_29_SHIFT = 2,
 218     XO_30_31_SHIFT = 0,
 219     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 220     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 221     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 222     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 223   };
 224 
 225   enum opcdxos_masks {
 226     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 227     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 228     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 229     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 230     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 231     // trap instructions
 232     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 233     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 234     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 235     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 236     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 237     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 238     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 239     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 240     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 241     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 242     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 243     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 244     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 245     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 246     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 247     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 248     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 249   };
 250 
 251   enum opcdxos {
 252     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 253     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 254     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 255     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 256     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 257     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 258     ADDME_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 234u &lt;&lt; 1),
 259     ADDZE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 202u &lt;&lt; 1),
 260     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 261     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 262     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 263     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 264     SUBFME_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 232u &lt;&lt; 1),
 265     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 266     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 267     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 268     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 269     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 270     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 271     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 272     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 273     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 274     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 275     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 276     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 277     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 278     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 279     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 280     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 281     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 282 
 283     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 284 
 285     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 286     CLRRWI_OPCODE = RLWINM_OPCODE,
 287     CLRLWI_OPCODE = RLWINM_OPCODE,
 288 
 289     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 290 
 291     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 292     SLWI_OPCODE   = RLWINM_OPCODE,
 293     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 294     SRWI_OPCODE   = RLWINM_OPCODE,
 295     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 296     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 297 
 298     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 299     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 300     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 301     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 302 
 303     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 304 
 305     // Special purpose registers
 306     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 307     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 308 
 309     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 310     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 311 
 312     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 313     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 314 
 315     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 316     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 317 
 318     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 319     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 320 
 321     // Attention: Higher and lower half are inserted in reversed order.
 322     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 323     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 324     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 325     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 326     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 327     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 328     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 329     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 330 
 331     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 332     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 333 
 334     MFTB_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 12 &lt;&lt; SPR_0_4_SHIFT),
 335 
 336     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 337     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 338     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 339 
 340     // condition register logic instructions
 341     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 342     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 343     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 344     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 345     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 346     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 347     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 348     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 349 
 350     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 351     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 352     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 353 
 354     // CTR-related opcodes
 355     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 356 
 357     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 358     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 359     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 360     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 361 
 362     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 363     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 364     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 365 
 366     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 367     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 368     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 369     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 370 
 371     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 372     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 373     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 374 
 375     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 376     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 377     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 378     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 379     STWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 662u &lt;&lt; 1),
 380 
 381     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 382     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 383     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 384     STHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 918u &lt;&lt; 1),
 385 
 386     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 387     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 388     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 389 
 390     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 391     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 392     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 393 
 394     // 32 bit opcode encodings
 395 
 396     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 397     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 398 
 399     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 400 
 401     // 64 bit opcode encodings
 402 
 403     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 404     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 405     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 406     LDBRX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 532u &lt;&lt; 1),              // X-FORM
 407 
 408     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 409     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 410     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),              // X-FORM
 411     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 412     STDBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 660u &lt;&lt; 1),              // X-FORM
 413 
 414     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 415     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 416     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 417     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 418 
 419     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 420 
 421     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 422     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 423     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 424 
 425     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 426     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 427     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 428     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 429 
 430     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 431     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 432     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 433 
 434 
 435     // opcodes only used for floating arithmetic
 436     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 437     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 438     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 439     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 440     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 441     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
 442     // These are special Power6 opcodes, reused for "lfdepx" and "stfdepx"
 443     // on Power7.  Do not use.
 444     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 445     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 446     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 447     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 448     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 449     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 450     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 451     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 452     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 453     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 454     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 455     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 456     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 457 
 458     // PPC64-internal FPU conversion opcodes
 459     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 460     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 461     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 462     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 463     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 464     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 465     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 466 
 467     // Fused multiply-accumulate instructions.
 468     FMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 469     FMADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 470     FMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 471     FMSUBS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 472     FNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 473     FNMADDS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 474     FNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 475     FNMSUBS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 476 
 477     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 478     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 479     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 480     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 481     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 482     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 483 
 484     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 485     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 486     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 487     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 488     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 489     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 490 
 491     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 492     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 493 
 494     // Vector instruction support for &gt;= Power6
 495     // Vector Storage Access
 496     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 497     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 498     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 499     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 500     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 501     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 502     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 503     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 504     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 505     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 506     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 507     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 508 
 509     // Vector-Scalar (VSX) instruction support.
 510     LXVD2X_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  844u &lt;&lt; 1),
 511     STXVD2X_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  972u &lt;&lt; 1),
 512     MTVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  179u &lt;&lt; 1),
 513     MTVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  243u &lt;&lt; 1),
 514     MFVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   51u &lt;&lt; 1),
 515     MTVSRWA_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  211u &lt;&lt; 1),
 516     MFVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  115u &lt;&lt; 1),
 517     XXPERMDI_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |   10u &lt;&lt; 3),
 518     XXMRGHW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   18u &lt;&lt; 3),
 519     XXMRGLW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   50u &lt;&lt; 3),
 520 
 521     // Vector Permute and Formatting
 522     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 523     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 524     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 525     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 526     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 527     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 528     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 529     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 530     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 531     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 532     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 533     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 534     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 535     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 536     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 537 
 538     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 539     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 540     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 541     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 542     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 543     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 544 
 545     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 546     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 547     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 548     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 549     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 550     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 551 
 552     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 553     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 554 
 555     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 556     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 557     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 558     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 559     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 560 
 561     // Vector Integer
 562     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 563     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 564     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 565     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 566     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 567     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 568     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
 569     VADDUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  192u     ),
 570     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 571     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 572     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 573     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 574     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 575     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 576     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 577     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 578     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 579     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 580     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 581     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 582     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 583 
 584     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 585     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 586     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 587     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 588     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 589     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 590     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 591     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 592     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 593     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 594     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 595     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 596     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 597     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 598     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 599     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 600     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 601 
 602     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 603     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 604     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 605     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 606     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 607 
 608     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 609     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 610     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 611     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 612     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 613     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 614 
 615     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 616     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 617     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 618     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 619     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 620     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 621     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 622     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 623     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 624     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 625     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 626     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 627 
 628     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 629     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 630     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 631     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 632     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 633     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 634     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 635     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 636     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 637 
 638     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 639     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 640     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 641     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 642     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 643     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 644     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 645     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 646     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 647     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 648     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 649     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 650     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 651     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 652     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 653     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 654     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 655     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 656 
 657     // Vector Floating-Point
 658     // not implemented yet
 659 
 660     // Vector Status and Control
 661     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 662     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 663 
 664     // AES (introduced with Power 8)
 665     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 666     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 667     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 668     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 669     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 670 
 671     // SHA (introduced with Power 8)
 672     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 673     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 674 
 675     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 676     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 677     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 678     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 679     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 680 
 681     // Vector Permute and Xor (introduced with Power 8)
 682     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 683 
 684     // Transactional Memory instructions (introduced with Power 8)
 685     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 686     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 687     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 688     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 689     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 690     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 691     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 692     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 693     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 694 
 695     // Icache and dcache related instructions
 696     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 697     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 698     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 699     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 700 
 701     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 702     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 703     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 704 
 705     // Instruction synchronization
 706     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 707     // Memory barriers
 708     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 709     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 710 
 711     // Wait instructions for polling.
 712     WAIT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   62u &lt;&lt; 1),
 713 
 714     // Trap instructions
 715     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 716     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 717     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 718     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 719 
 720     // Atomics.
 721     LBARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   52u &lt;&lt; 1),
 722     LHARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  116u &lt;&lt; 1),
 723     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 724     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 725     LQARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  276u &lt;&lt; 1),
 726     STBCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  694u &lt;&lt; 1),
 727     STHCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  726u &lt;&lt; 1),
 728     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 729     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1),
 730     STQCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  182u &lt;&lt; 1)
 731 
 732   };
 733 
 734   // Trap instructions TO bits
 735   enum trap_to_bits {
 736     // single bits
 737     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 738     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 739     traptoEqual               = 1 &lt;&lt; 2,
 740     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 741     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 742 
 743     // compound ones
 744     traptoUnconditional       = (traptoLessThanSigned |
 745                                  traptoGreaterThanSigned |
 746                                  traptoEqual |
 747                                  traptoLessThanUnsigned |
 748                                  traptoGreaterThanUnsigned)
 749   };
 750 
 751   // Branch hints BH field
 752   enum branch_hint_bh {
 753     // bclr cases:
 754     bhintbhBCLRisReturn            = 0,
 755     bhintbhBCLRisNotReturnButSame  = 1,
 756     bhintbhBCLRisNotPredictable    = 3,
 757 
 758     // bcctr cases:
 759     bhintbhBCCTRisNotReturnButSame = 0,
 760     bhintbhBCCTRisNotPredictable   = 3
 761   };
 762 
 763   // Branch prediction hints AT field
 764   enum branch_hint_at {
 765     bhintatNoHint     = 0,  // at=00
 766     bhintatIsNotTaken = 2,  // at=10
 767     bhintatIsTaken    = 3   // at=11
 768   };
 769 
 770   // Branch prediction hints
 771   enum branch_hint_concept {
 772     // Use the same encoding as branch_hint_at to simply code.
 773     bhintNoHint       = bhintatNoHint,
 774     bhintIsNotTaken   = bhintatIsNotTaken,
 775     bhintIsTaken      = bhintatIsTaken
 776   };
 777 
 778   // Used in BO field of branch instruction.
 779   enum branch_condition {
 780     bcondCRbiIs0      =  4, // bo=001at
 781     bcondCRbiIs1      = 12, // bo=011at
 782     bcondAlways       = 20  // bo=10100
 783   };
 784 
 785   // Branch condition with combined prediction hints.
 786   enum branch_condition_with_hint {
 787     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 788     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 789     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 790     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 791     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 792     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 793   };
 794 
 795   // Elemental Memory Barriers (&gt;=Power 8)
 796   enum Elemental_Membar_mask_bits {
 797     StoreStore = 1 &lt;&lt; 0,
 798     StoreLoad  = 1 &lt;&lt; 1,
 799     LoadStore  = 1 &lt;&lt; 2,
 800     LoadLoad   = 1 &lt;&lt; 3
 801   };
 802 
 803   // Branch prediction hints.
 804   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 805     switch (boint) {
 806       case bcondCRbiIs0:
 807       case bcondCRbiIs1:
 808         // branch_hint and branch_hint_at have same encodings
 809         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 810                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 811                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 812                "wrong encodings");
 813         assert((bhint &amp; 0x03) == bhint, "wrong encodings");
 814         return (boint &amp; ~0x03) | bhint;
 815       case bcondAlways:
 816         // no branch_hint
 817         return boint;
 818       default:
 819         ShouldNotReachHere();
 820         return 0;
 821     }
 822   }
 823 
 824   // Extract bcond from boint.
 825   inline static int inv_boint_bcond(const int boint) {
 826     int r_bcond = boint &amp; ~0x03;
 827     assert(r_bcond == bcondCRbiIs0 ||
 828            r_bcond == bcondCRbiIs1 ||
 829            r_bcond == bcondAlways,
 830            "bad branch condition");
 831     return r_bcond;
 832   }
 833 
 834   // Extract bhint from boint.
 835   inline static int inv_boint_bhint(const int boint) {
 836     int r_bhint = boint &amp; 0x03;
 837     assert(r_bhint == bhintatNoHint ||
 838            r_bhint == bhintatIsNotTaken ||
 839            r_bhint == bhintatIsTaken,
 840            "bad branch hint");
 841     return r_bhint;
 842   }
 843 
 844   // Calculate opposite of given bcond.
 845   inline static int opposite_bcond(const int bcond) {
 846     switch (bcond) {
 847       case bcondCRbiIs0:
 848         return bcondCRbiIs1;
 849       case bcondCRbiIs1:
 850         return bcondCRbiIs0;
 851       default:
 852         ShouldNotReachHere();
 853         return 0;
 854     }
 855   }
 856 
 857   // Calculate opposite of given bhint.
 858   inline static int opposite_bhint(const int bhint) {
 859     switch (bhint) {
 860       case bhintatNoHint:
 861         return bhintatNoHint;
 862       case bhintatIsNotTaken:
 863         return bhintatIsTaken;
 864       case bhintatIsTaken:
 865         return bhintatIsNotTaken;
 866       default:
 867         ShouldNotReachHere();
 868         return 0;
 869     }
 870   }
 871 
 872   // PPC branch instructions
 873   enum ppcops {
 874     b_op    = 18,
 875     bc_op   = 16,
 876     bcr_op  = 19
 877   };
 878 
 879   enum Condition {
 880     negative         = 0,
 881     less             = 0,
 882     positive         = 1,
 883     greater          = 1,
 884     zero             = 2,
 885     equal            = 2,
 886     summary_overflow = 3,
 887   };
 888 
 889  public:
 890   // Helper functions for groups of instructions
 891 
 892   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 893 
 894   // Instruction must start at passed address.
 895   static int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 896 
 897   // longest instructions
 898   static int instr_maxlen() { return BytesPerInstWord; }
 899 
 900   // Test if x is within signed immediate range for nbits.
 901   static bool is_simm(int x, unsigned int nbits) {
 902     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 903     const int   min      = -(((int)1) &lt;&lt; nbits-1);
 904     const int   maxplus1 =  (((int)1) &lt;&lt; nbits-1);
 905     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 906   }
 907 
 908   static bool is_simm(jlong x, unsigned int nbits) {
 909     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 910     const jlong min      = -(((jlong)1) &lt;&lt; nbits-1);
 911     const jlong maxplus1 =  (((jlong)1) &lt;&lt; nbits-1);
 912     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 913   }
 914 
 915   // Test if x is within unsigned immediate range for nbits.
 916   static bool is_uimm(int x, unsigned int nbits) {
 917     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 918     const unsigned int maxplus1 = (((unsigned int)1) &lt;&lt; nbits);
 919     return (unsigned int)x &lt; maxplus1;
 920   }
 921 
 922   static bool is_uimm(jlong x, unsigned int nbits) {
 923     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 924     const julong maxplus1 = (((julong)1) &lt;&lt; nbits);
 925     return (julong)x &lt; maxplus1;
 926   }
 927 
 928  protected:
 929   // helpers
 930 
 931   // X is supposed to fit in a field "nbits" wide
 932   // and be sign-extended. Check the range.
 933   static void assert_signed_range(intptr_t x, int nbits) {
 934     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 935            "value out of range");
 936   }
 937 
 938   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 939     assert((x &amp; 3) == 0, "not word aligned");
 940     assert_signed_range(x, nbits + 2);
 941   }
 942 
 943   static void assert_unsigned_const(int x, int nbits) {
 944     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), "unsigned constant out of range");
 945   }
 946 
 947   static int fmask(juint hi_bit, juint lo_bit) {
 948     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, "bad bits");
 949     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 950   }
 951 
 952   // inverse of u_field
 953   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 954     juint r = juint(x) &gt;&gt; lo_bit;
 955     r &amp;= fmask(hi_bit, lo_bit);
 956     return int(r);
 957   }
 958 
 959   // signed version: extract from field and sign-extend
 960   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
 961     x = x &lt;&lt; (31-hi_bit);
 962     x = x &gt;&gt; (31-hi_bit+lo_bit);
 963     return x;
 964   }
 965 
 966   static int u_field(int x, int hi_bit, int lo_bit) {
 967     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, "value out of range");
 968     int r = x &lt;&lt; lo_bit;
 969     assert(inv_u_field(r, hi_bit, lo_bit) == x, "just checking");
 970     return r;
 971   }
 972 
 973   // Same as u_field for signed values
 974   static int s_field(int x, int hi_bit, int lo_bit) {
 975     int nbits = hi_bit - lo_bit + 1;
 976     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 977       "value out of range");
 978     x &amp;= fmask(hi_bit, lo_bit);
 979     int r = x &lt;&lt; lo_bit;
 980     return r;
 981   }
 982 
 983   // inv_op for ppc instructions
 984   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
 985 
 986   // Determine target address from li, bd field of branch instruction.
 987   static intptr_t inv_li_field(int x) {
 988     intptr_t r = inv_s_field_ppc(x, 25, 2);
 989     r = (r &lt;&lt; 2);
 990     return r;
 991   }
 992   static intptr_t inv_bd_field(int x, intptr_t pos) {
 993     intptr_t r = inv_s_field_ppc(x, 15, 2);
 994     r = (r &lt;&lt; 2) + pos;
 995     return r;
 996   }
 997 
 998   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
 999   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
1000   // Extract instruction fields from instruction words.
1001  public:
1002   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1003   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
1004   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1005   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
1006   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1007   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
1008   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
1009   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
1010   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1011   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1012   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
1013   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
1014   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1015   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1016 
1017   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
1018   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
1019 
1020   // instruction fields
1021   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
1022   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
1023   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
1024   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
1025   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
1026   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
1027   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
1028   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
1029   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
1030   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
1031   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
1032   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
1033   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
1034   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
1035   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
1036   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, "unaligned offset"); return opp_s_field(x, 31, 16); }
1037   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
1038   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
1039   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
1040   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
1041   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
1042   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
1043   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
1044   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
1045   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
1046   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
1047   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
1048   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
1049   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
1050   static int l10(      int         x)  { return  opp_u_field(x,             10, 10); }
1051   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
1052   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
1053   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
1054   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
1055   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
1056   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1057   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1058   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1059   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1060   static int me2126(   int         x)  { return  mb2126(x); }
1061   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1062   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1063   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1064   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1065   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1066   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1067   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1068   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1069   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1070   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1071   // we don't want to use R0 in memory accesses, because it has value `0' then
1072   static int ra0mem(   Register    r)  { assert(r != R0, "cannot use register R0 in memory access"); return ra(r); }
1073   static int ra0mem(   int         x)  { assert(x != 0,  "cannot use register 0 in memory access");  return ra(x); }
1074 
1075   // register r is target
1076   static int rt(       Register    r)  { return rs(r); }
1077   static int rt(       int         x)  { return rs(x); }
1078   static int rta(      Register    r)  { return ra(r); }
1079   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1080 
1081   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1082   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1083   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1084   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1085   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1086   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1087   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1088   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1089   static int thct(     int         x)  { assert((x&amp;8) == 0, "must be valid cache specification");  return th(x); }
1090   static int thds(     int         x)  { assert((x&amp;8) == 8, "must be valid stream specification"); return th(x); }
1091   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1092   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1093   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1094 
1095   // Support vector instructions for &gt;= Power6.
1096   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1097   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1098   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1099   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1100   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1101 
1102   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1103   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1104   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1105   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1106   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1107 
1108   // Only used on SHA sigma instructions (VX-form)
1109   static int vst(      int         x)  { return  opp_u_field(x,             16, 16); }
1110   static int vsix(     int         x)  { return  opp_u_field(x,             20, 17); }
1111 
1112   // Support Vector-Scalar (VSX) instructions.
1113   static int vsra(      int         x)  { return  opp_u_field(x &amp; 0x1F,     15, 11) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 29, 29); }
1114   static int vsrb(      int         x)  { return  opp_u_field(x &amp; 0x1F,     20, 16) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 30, 30); }
1115   static int vsrs(      int         x)  { return  opp_u_field(x &amp; 0x1F,     10,  6) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 31, 31); }
1116   static int vsrt(      int         x)  { return  vsrs(x); }
1117   static int vsdm(      int         x)  { return  opp_u_field(x,            23, 22); }
1118 
1119   static int vsra(   VectorSRegister r)  { return  vsra(r-&gt;encoding());}
1120   static int vsrb(   VectorSRegister r)  { return  vsrb(r-&gt;encoding());}
1121   static int vsrs(   VectorSRegister r)  { return  vsrs(r-&gt;encoding());}
1122   static int vsrt(   VectorSRegister r)  { return  vsrt(r-&gt;encoding());}
1123 
1124   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1125   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1126   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1127   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1128 
1129   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1130   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1131   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1132   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1133   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1134   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1135   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1136 
1137  protected:
1138   // Compute relative address for branch.
1139   static intptr_t disp(intptr_t x, intptr_t off) {
1140     int xx = x - off;
1141     xx = xx &gt;&gt; 2;
1142     return xx;
1143   }
1144 
1145  public:
1146   // signed immediate, in low bits, nbits long
1147   static int simm(int x, int nbits) {
1148     assert_signed_range(x, nbits);
1149     return x &amp; ((1 &lt;&lt; nbits) - 1);
1150   }
1151 
1152   // unsigned immediate, in low bits, nbits long
1153   static int uimm(int x, int nbits) {
1154     assert_unsigned_const(x, nbits);
1155     return x &amp; ((1 &lt;&lt; nbits) - 1);
1156   }
1157 
1158   static void set_imm(int* instr, short s) {
1159     // imm is always in the lower 16 bits of the instruction,
1160     // so this is endian-neutral. Same for the get_imm below.
1161     uint32_t w = *(uint32_t *)instr;
1162     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1163   }
1164 
1165   static int get_imm(address a, int instruction_number) {
1166     return (short)((int *)a)[instruction_number];
1167   }
1168 
1169   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1170   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1171 
1172  protected:
1173 
1174   // Extract the top 32 bits in a 64 bit word.
1175   static int32_t hi32(int64_t x) {
1176     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1177     return r;
1178   }
1179 
1180  public:
1181 
1182   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1183     return ((addr + (a - 1)) &amp; ~(a - 1));
1184   }
1185 
1186   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1187     return (0 == addr % a);
1188   }
1189 
1190   void flush() {
1191     AbstractAssembler::flush();
1192   }
1193 
1194   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1195   inline void emit_data(int);
1196   inline void emit_data(int, RelocationHolder const&amp;);
1197   inline void emit_data(int, relocInfo::relocType rtype);
1198 
1199   // Emit an address.
1200   inline address emit_addr(const address addr = NULL);
1201 
1202 #if !defined(ABI_ELFv2)
1203   // Emit a function descriptor with the specified entry point, TOC,
1204   // and ENV. If the entry point is NULL, the descriptor will point
1205   // just past the descriptor.
1206   // Use values from friend functions as defaults.
1207   inline address emit_fd(address entry = NULL,
1208                          address toc = (address) FunctionDescriptor::friend_toc,
1209                          address env = (address) FunctionDescriptor::friend_env);
1210 #endif
1211 
1212   /////////////////////////////////////////////////////////////////////////////////////
1213   // PPC instructions
1214   /////////////////////////////////////////////////////////////////////////////////////
1215 
1216   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1217   // immediates. The normal instruction encoders enforce that r0 is not
1218   // passed to them. Use either extended mnemonics encoders or the special ra0
1219   // versions.
1220 
1221   // Issue an illegal instruction.
1222   inline void illtrap();
1223   static inline bool is_illtrap(int x);
1224 
1225   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1226   inline void addi( Register d, Register a, int si16);
1227   inline void addis(Register d, Register a, int si16);
1228  private:
1229   inline void addi_r0ok( Register d, Register a, int si16);
1230   inline void addis_r0ok(Register d, Register a, int si16);
1231  public:
1232   inline void addic_( Register d, Register a, int si16);
1233   inline void subfic( Register d, Register a, int si16);
1234   inline void add(    Register d, Register a, Register b);
1235   inline void add_(   Register d, Register a, Register b);
1236   inline void subf(   Register d, Register a, Register b);  // d = b - a    "Sub_from", as in ppc spec.
1237   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1238   inline void subf_(  Register d, Register a, Register b);
1239   inline void addc(   Register d, Register a, Register b);
1240   inline void addc_(  Register d, Register a, Register b);
1241   inline void subfc(  Register d, Register a, Register b);
1242   inline void subfc_( Register d, Register a, Register b);
1243   inline void adde(   Register d, Register a, Register b);
1244   inline void adde_(  Register d, Register a, Register b);
1245   inline void subfe(  Register d, Register a, Register b);
1246   inline void subfe_( Register d, Register a, Register b);
1247   inline void addme(  Register d, Register a);
1248   inline void addme_( Register d, Register a);
1249   inline void subfme( Register d, Register a);
1250   inline void subfme_(Register d, Register a);
1251   inline void addze(  Register d, Register a);
1252   inline void addze_( Register d, Register a);
1253   inline void subfze( Register d, Register a);
1254   inline void subfze_(Register d, Register a);
1255   inline void neg(    Register d, Register a);
1256   inline void neg_(   Register d, Register a);
1257   inline void mulli(  Register d, Register a, int si16);
1258   inline void mulld(  Register d, Register a, Register b);
1259   inline void mulld_( Register d, Register a, Register b);
1260   inline void mullw(  Register d, Register a, Register b);
1261   inline void mullw_( Register d, Register a, Register b);
1262   inline void mulhw(  Register d, Register a, Register b);
1263   inline void mulhw_( Register d, Register a, Register b);
1264   inline void mulhwu( Register d, Register a, Register b);
1265   inline void mulhwu_(Register d, Register a, Register b);
1266   inline void mulhd(  Register d, Register a, Register b);
1267   inline void mulhd_( Register d, Register a, Register b);
1268   inline void mulhdu( Register d, Register a, Register b);
1269   inline void mulhdu_(Register d, Register a, Register b);
1270   inline void divd(   Register d, Register a, Register b);
1271   inline void divd_(  Register d, Register a, Register b);
1272   inline void divw(   Register d, Register a, Register b);
1273   inline void divw_(  Register d, Register a, Register b);
1274 
1275   // Fixed-Point Arithmetic Instructions with Overflow detection
1276   inline void addo(    Register d, Register a, Register b);
1277   inline void addo_(   Register d, Register a, Register b);
1278   inline void subfo(   Register d, Register a, Register b);
1279   inline void subfo_(  Register d, Register a, Register b);
1280   inline void addco(   Register d, Register a, Register b);
1281   inline void addco_(  Register d, Register a, Register b);
1282   inline void subfco(  Register d, Register a, Register b);
1283   inline void subfco_( Register d, Register a, Register b);
1284   inline void addeo(   Register d, Register a, Register b);
1285   inline void addeo_(  Register d, Register a, Register b);
1286   inline void subfeo(  Register d, Register a, Register b);
1287   inline void subfeo_( Register d, Register a, Register b);
1288   inline void addmeo(  Register d, Register a);
1289   inline void addmeo_( Register d, Register a);
1290   inline void subfmeo( Register d, Register a);
1291   inline void subfmeo_(Register d, Register a);
1292   inline void addzeo(  Register d, Register a);
1293   inline void addzeo_( Register d, Register a);
1294   inline void subfzeo( Register d, Register a);
1295   inline void subfzeo_(Register d, Register a);
1296   inline void nego(    Register d, Register a);
1297   inline void nego_(   Register d, Register a);
1298   inline void mulldo(  Register d, Register a, Register b);
1299   inline void mulldo_( Register d, Register a, Register b);
1300   inline void mullwo(  Register d, Register a, Register b);
1301   inline void mullwo_( Register d, Register a, Register b);
1302   inline void divdo(   Register d, Register a, Register b);
1303   inline void divdo_(  Register d, Register a, Register b);
1304   inline void divwo(   Register d, Register a, Register b);
1305   inline void divwo_(  Register d, Register a, Register b);
1306 
1307   // extended mnemonics
1308   inline void li(   Register d, int si16);
1309   inline void lis(  Register d, int si16);
1310   inline void addir(Register d, int si16, Register a);
<a name="1" id="anc1"></a><span class="new">1311   inline void subi( Register d, Register a, int si16);</span>
1312 
1313   static bool is_addi(int x) {
1314      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1315   }
1316   static bool is_addis(int x) {
1317      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1318   }
1319   static bool is_bxx(int x) {
1320      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1321   }
1322   static bool is_b(int x) {
1323      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1324   }
1325   static bool is_bl(int x) {
1326      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1327   }
1328   static bool is_bcxx(int x) {
1329      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1330   }
1331   static bool is_bxx_or_bcxx(int x) {
1332      return is_bxx(x) || is_bcxx(x);
1333   }
1334   static bool is_bctrl(int x) {
1335      return x == 0x4e800421;
1336   }
1337   static bool is_bctr(int x) {
1338      return x == 0x4e800420;
1339   }
1340   static bool is_bclr(int x) {
1341      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1342   }
1343   static bool is_li(int x) {
1344      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1345   }
1346   static bool is_lis(int x) {
1347      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1348   }
1349   static bool is_mtctr(int x) {
1350      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1351   }
1352   static bool is_ld(int x) {
1353      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1354   }
1355   static bool is_std(int x) {
1356      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1357   }
1358   static bool is_stdu(int x) {
1359      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1360   }
1361   static bool is_stdx(int x) {
1362      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1363   }
1364   static bool is_stdux(int x) {
1365      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1366   }
1367   static bool is_stwx(int x) {
1368      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1369   }
1370   static bool is_stwux(int x) {
1371      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1372   }
1373   static bool is_stw(int x) {
1374      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1375   }
1376   static bool is_stwu(int x) {
1377      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1378   }
1379   static bool is_ori(int x) {
1380      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1381   };
1382   static bool is_oris(int x) {
1383      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1384   };
1385   static bool is_rldicr(int x) {
1386      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1387   };
1388   static bool is_nop(int x) {
1389     return x == 0x60000000;
1390   }
1391   // endgroup opcode for Power6
1392   static bool is_endgroup(int x) {
1393     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1394   }
1395 
1396 
1397  private:
1398   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1399   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1400   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1401   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1402   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1403 
1404  public:
1405   // extended mnemonics of Compare Instructions
1406   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1407   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1408   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1409   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1410   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1411   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1412   inline void cmplw( ConditionRegister crx, Register a, Register b);
1413   inline void cmpld( ConditionRegister crx, Register a, Register b);
1414 
1415   inline void isel(   Register d, Register a, Register b, int bc);
1416   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1417   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1418   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1419   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1420 
1421   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1422          void andi(   Register a, Register s, long ui16);   // optimized version
1423   inline void andi_(  Register a, Register s, int ui16);
1424   inline void andis_( Register a, Register s, int ui16);
1425   inline void ori(    Register a, Register s, int ui16);
1426   inline void oris(   Register a, Register s, int ui16);
1427   inline void xori(   Register a, Register s, int ui16);
1428   inline void xoris(  Register a, Register s, int ui16);
1429   inline void andr(   Register a, Register s, Register b);  // suffixed by 'r' as 'and' is C++ keyword
1430   inline void and_(   Register a, Register s, Register b);
1431   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1432   // SMT-priority change instruction (see SMT instructions below).
1433   inline void or_unchecked(Register a, Register s, Register b);
1434   inline void orr(    Register a, Register s, Register b);  // suffixed by 'r' as 'or' is C++ keyword
1435   inline void or_(    Register a, Register s, Register b);
1436   inline void xorr(   Register a, Register s, Register b);  // suffixed by 'r' as 'xor' is C++ keyword
1437   inline void xor_(   Register a, Register s, Register b);
1438   inline void nand(   Register a, Register s, Register b);
1439   inline void nand_(  Register a, Register s, Register b);
1440   inline void nor(    Register a, Register s, Register b);
1441   inline void nor_(   Register a, Register s, Register b);
1442   inline void andc(   Register a, Register s, Register b);
1443   inline void andc_(  Register a, Register s, Register b);
1444   inline void orc(    Register a, Register s, Register b);
1445   inline void orc_(   Register a, Register s, Register b);
1446   inline void extsb(  Register a, Register s);
1447   inline void extsb_( Register a, Register s);
1448   inline void extsh(  Register a, Register s);
1449   inline void extsh_( Register a, Register s);
1450   inline void extsw(  Register a, Register s);
1451   inline void extsw_( Register a, Register s);
1452 
1453   // extended mnemonics
1454   inline void nop();
1455   // NOP for FP and BR units (different versions to allow them to be in one group)
1456   inline void fpnop0();
1457   inline void fpnop1();
1458   inline void brnop0();
1459   inline void brnop1();
1460   inline void brnop2();
1461 
1462   inline void mr(      Register d, Register s);
1463   inline void ori_opt( Register d, int ui16);
1464   inline void oris_opt(Register d, int ui16);
1465 
1466   // endgroup opcode for Power6
1467   inline void endgroup();
1468 
1469   // count instructions
1470   inline void cntlzw(  Register a, Register s);
1471   inline void cntlzw_( Register a, Register s);
1472   inline void cntlzd(  Register a, Register s);
1473   inline void cntlzd_( Register a, Register s);
1474 
1475   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1476   inline void sld(     Register a, Register s, Register b);
1477   inline void sld_(    Register a, Register s, Register b);
1478   inline void slw(     Register a, Register s, Register b);
1479   inline void slw_(    Register a, Register s, Register b);
1480   inline void srd(     Register a, Register s, Register b);
1481   inline void srd_(    Register a, Register s, Register b);
1482   inline void srw(     Register a, Register s, Register b);
1483   inline void srw_(    Register a, Register s, Register b);
1484   inline void srad(    Register a, Register s, Register b);
1485   inline void srad_(   Register a, Register s, Register b);
1486   inline void sraw(    Register a, Register s, Register b);
1487   inline void sraw_(   Register a, Register s, Register b);
1488   inline void sradi(   Register a, Register s, int sh6);
1489   inline void sradi_(  Register a, Register s, int sh6);
1490   inline void srawi(   Register a, Register s, int sh5);
1491   inline void srawi_(  Register a, Register s, int sh5);
1492 
1493   // extended mnemonics for Shift Instructions
1494   inline void sldi(    Register a, Register s, int sh6);
1495   inline void sldi_(   Register a, Register s, int sh6);
1496   inline void slwi(    Register a, Register s, int sh5);
1497   inline void slwi_(   Register a, Register s, int sh5);
1498   inline void srdi(    Register a, Register s, int sh6);
1499   inline void srdi_(   Register a, Register s, int sh6);
1500   inline void srwi(    Register a, Register s, int sh5);
1501   inline void srwi_(   Register a, Register s, int sh5);
1502 
1503   inline void clrrdi(  Register a, Register s, int ui6);
1504   inline void clrrdi_( Register a, Register s, int ui6);
1505   inline void clrldi(  Register a, Register s, int ui6);
1506   inline void clrldi_( Register a, Register s, int ui6);
1507   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1508   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1509   inline void extrdi(  Register a, Register s, int n, int b);
1510   // testbit with condition register
1511   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1512 
1513   // rotate instructions
1514   inline void rotldi(  Register a, Register s, int n);
1515   inline void rotrdi(  Register a, Register s, int n);
1516   inline void rotlwi(  Register a, Register s, int n);
1517   inline void rotrwi(  Register a, Register s, int n);
1518 
1519   // Rotate Instructions
1520   inline void rldic(   Register a, Register s, int sh6, int mb6);
1521   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1522   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1523   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1524   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1525   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1526   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1527   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1528   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1529   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1530   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1531   inline void insrdi(  Register a, Register s, int n,   int b);
1532   inline void insrwi(  Register a, Register s, int n,   int b);
1533 
1534   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1535   // 4 bytes
1536   inline void lwzx( Register d, Register s1, Register s2);
1537   inline void lwz(  Register d, int si16,    Register s1);
1538   inline void lwzu( Register d, int si16,    Register s1);
1539 
1540   // 4 bytes
1541   inline void lwax( Register d, Register s1, Register s2);
1542   inline void lwa(  Register d, int si16,    Register s1);
1543 
1544   // 4 bytes reversed
1545   inline void lwbrx( Register d, Register s1, Register s2);
1546 
1547   // 2 bytes
1548   inline void lhzx( Register d, Register s1, Register s2);
1549   inline void lhz(  Register d, int si16,    Register s1);
1550   inline void lhzu( Register d, int si16,    Register s1);
1551 
1552   // 2 bytes reversed
1553   inline void lhbrx( Register d, Register s1, Register s2);
1554 
1555   // 2 bytes
1556   inline void lhax( Register d, Register s1, Register s2);
1557   inline void lha(  Register d, int si16,    Register s1);
1558   inline void lhau( Register d, int si16,    Register s1);
1559 
1560   // 1 byte
1561   inline void lbzx( Register d, Register s1, Register s2);
1562   inline void lbz(  Register d, int si16,    Register s1);
1563   inline void lbzu( Register d, int si16,    Register s1);
1564 
1565   // 8 bytes
1566   inline void ldx(  Register d, Register s1, Register s2);
1567   inline void ld(   Register d, int si16,    Register s1);
1568   inline void ldu(  Register d, int si16,    Register s1);
1569 
1570   // 8 bytes reversed
1571   inline void ldbrx( Register d, Register s1, Register s2);
1572 
1573   // For convenience. Load pointer into d from b+s1.
1574   inline void ld_ptr(Register d, int b, Register s1);
1575   DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)
1576 
1577   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1578   inline void stwx( Register d, Register s1, Register s2);
1579   inline void stw(  Register d, int si16,    Register s1);
1580   inline void stwu( Register d, int si16,    Register s1);
1581   inline void stwbrx( Register d, Register s1, Register s2);
1582 
1583   inline void sthx( Register d, Register s1, Register s2);
1584   inline void sth(  Register d, int si16,    Register s1);
1585   inline void sthu( Register d, int si16,    Register s1);
1586   inline void sthbrx( Register d, Register s1, Register s2);
1587 
1588   inline void stbx( Register d, Register s1, Register s2);
1589   inline void stb(  Register d, int si16,    Register s1);
1590   inline void stbu( Register d, int si16,    Register s1);
1591 
1592   inline void stdx( Register d, Register s1, Register s2);
1593   inline void std(  Register d, int si16,    Register s1);
1594   inline void stdu( Register d, int si16,    Register s1);
1595   inline void stdux(Register s, Register a,  Register b);
1596   inline void stdbrx( Register d, Register s1, Register s2);
1597 
1598   inline void st_ptr(Register d, int si16,    Register s1);
1599   DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)
1600 
1601   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1602   inline void mtlr( Register s1);
1603   inline void mflr( Register d);
1604   inline void mtctr(Register s1);
1605   inline void mfctr(Register d);
1606   inline void mtcrf(int fxm, Register s);
1607   inline void mfcr( Register d);
1608   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1609   inline void mtcr( Register s);
1610 
1611   // Special purpose registers
1612   // Exception Register
1613   inline void mtxer(Register s1);
1614   inline void mfxer(Register d);
1615   // Vector Register Save Register
1616   inline void mtvrsave(Register s1);
1617   inline void mfvrsave(Register d);
1618   // Timebase
1619   inline void mftb(Register d);
1620   // Introduced with Power 8:
1621   // Data Stream Control Register
1622   inline void mtdscr(Register s1);
1623   inline void mfdscr(Register d );
1624   // Transactional Memory Registers
1625   inline void mftfhar(Register d);
1626   inline void mftfiar(Register d);
1627   inline void mftexasr(Register d);
1628   inline void mftexasru(Register d);
1629 
1630   // TEXASR bit description
1631   enum transaction_failure_reason {
1632     // Upper half (TEXASRU):
1633     tm_failure_persistent =  7, // The failure is likely to recur on each execution.
1634     tm_disallowed         =  8, // The instruction is not permitted.
1635     tm_nesting_of         =  9, // The maximum transaction level was exceeded.
1636     tm_footprint_of       = 10, // The tracking limit for transactional storage accesses was exceeded.
1637     tm_self_induced_cf    = 11, // A self-induced conflict occurred in Suspended state.
1638     tm_non_trans_cf       = 12, // A conflict occurred with a non-transactional access by another processor.
1639     tm_trans_cf           = 13, // A conflict occurred with another transaction.
1640     tm_translation_cf     = 14, // A conflict occurred with a TLB invalidation.
1641     tm_inst_fetch_cf      = 16, // An instruction fetch was performed from a block that was previously written transactionally.
1642     tm_tabort             = 31, // Termination was caused by the execution of an abort instruction.
1643     // Lower half:
1644     tm_suspended          = 32, // Failure was recorded in Suspended state.
1645     tm_failure_summary    = 36, // Failure has been detected and recorded.
1646     tm_tfiar_exact        = 37, // Value in the TFIAR is exact.
1647     tm_rot                = 38, // Rollback-only transaction.
1648   };
1649 
1650   // PPC 1, section 2.4.1 Branch Instructions
1651   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1652   inline void b(  Label&amp; L);
1653   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1654   inline void bl( Label&amp; L);
1655   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1656   inline void bc( int boint, int biint, Label&amp; L);
1657   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1658   inline void bcl(int boint, int biint, Label&amp; L);
1659 
1660   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1661   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1662   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1663                          relocInfo::relocType rt = relocInfo::none);
1664   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1665                          relocInfo::relocType rt = relocInfo::none);
1666 
1667   // helper function for b, bcxx
1668   inline bool is_within_range_of_b(address a, address pc);
1669   inline bool is_within_range_of_bcxx(address a, address pc);
1670 
1671   // get the destination of a bxx branch (b, bl, ba, bla)
1672   static inline address  bxx_destination(address baddr);
1673   static inline address  bxx_destination(int instr, address pc);
1674   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1675 
1676   // extended mnemonics for branch instructions
1677   inline void blt(ConditionRegister crx, Label&amp; L);
1678   inline void bgt(ConditionRegister crx, Label&amp; L);
1679   inline void beq(ConditionRegister crx, Label&amp; L);
1680   inline void bso(ConditionRegister crx, Label&amp; L);
1681   inline void bge(ConditionRegister crx, Label&amp; L);
1682   inline void ble(ConditionRegister crx, Label&amp; L);
1683   inline void bne(ConditionRegister crx, Label&amp; L);
1684   inline void bns(ConditionRegister crx, Label&amp; L);
1685 
1686   // Branch instructions with static prediction hints.
1687   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1688   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1689   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1690   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1691   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1692   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1693   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1694   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1695   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1696   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1697   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1698   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1699   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1700   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1701   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1702   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1703 
1704   // for use in conjunction with testbitdi:
1705   inline void btrue( ConditionRegister crx, Label&amp; L);
1706   inline void bfalse(ConditionRegister crx, Label&amp; L);
1707 
1708   inline void bltl(ConditionRegister crx, Label&amp; L);
1709   inline void bgtl(ConditionRegister crx, Label&amp; L);
1710   inline void beql(ConditionRegister crx, Label&amp; L);
1711   inline void bsol(ConditionRegister crx, Label&amp; L);
1712   inline void bgel(ConditionRegister crx, Label&amp; L);
1713   inline void blel(ConditionRegister crx, Label&amp; L);
1714   inline void bnel(ConditionRegister crx, Label&amp; L);
1715   inline void bnsl(ConditionRegister crx, Label&amp; L);
1716 
1717   // extended mnemonics for Branch Instructions via LR
1718   // We use `blr' for returns.
1719   inline void blr(relocInfo::relocType rt = relocInfo::none);
1720 
1721   // extended mnemonics for Branch Instructions with CTR
1722   // bdnz means `decrement CTR and jump to L if CTR is not zero'
1723   inline void bdnz(Label&amp; L);
1724   // Decrement and branch if result is zero.
1725   inline void bdz(Label&amp; L);
1726   // we use `bctr[l]' for jumps/calls in function descriptor glue
1727   // code, e.g. calls to runtime functions
1728   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1729   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1730   // conditional jumps/branches via CTR
1731   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1732   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1733   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1734   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1735 
1736   // condition register logic instructions
1737   // NOTE: There's a preferred form: d and s2 should point into the same condition register.
1738   inline void crand( int d, int s1, int s2);
1739   inline void crnand(int d, int s1, int s2);
1740   inline void cror(  int d, int s1, int s2);
1741   inline void crxor( int d, int s1, int s2);
1742   inline void crnor( int d, int s1, int s2);
1743   inline void creqv( int d, int s1, int s2);
1744   inline void crandc(int d, int s1, int s2);
1745   inline void crorc( int d, int s1, int s2);
1746 
1747   // More convenient version.
1748   int condition_register_bit(ConditionRegister cr, Condition c) {
1749     return 4 * (int)(intptr_t)cr + c;
1750   }
1751   void crand( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1752   void crnand(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1753   void cror(  ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1754   void crxor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1755   void crnor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1756   void creqv( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1757   void crandc(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1758   void crorc( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1759 
1760   // icache and dcache related instructions
1761   inline void icbi(  Register s1, Register s2);
1762   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1763   inline void dcbz(  Register s1, Register s2);
1764   inline void dcbst( Register s1, Register s2);
1765   inline void dcbf(  Register s1, Register s2);
1766 
1767   enum ct_cache_specification {
1768     ct_primary_cache   = 0,
1769     ct_secondary_cache = 2
1770   };
1771   // dcache read hint
1772   inline void dcbt(    Register s1, Register s2);
1773   inline void dcbtct(  Register s1, Register s2, int ct);
1774   inline void dcbtds(  Register s1, Register s2, int ds);
1775   // dcache write hint
1776   inline void dcbtst(  Register s1, Register s2);
1777   inline void dcbtstct(Register s1, Register s2, int ct);
1778 
1779   //  machine barrier instructions:
1780   //
1781   //  - sync    two-way memory barrier, aka fence
1782   //  - lwsync  orders  Store|Store,
1783   //                     Load|Store,
1784   //                     Load|Load,
1785   //            but not Store|Load
1786   //  - eieio   orders memory accesses for device memory (only)
1787   //  - isync   invalidates speculatively executed instructions
1788   //            From the Power ISA 2.06 documentation:
1789   //             "[...] an isync instruction prevents the execution of
1790   //            instructions following the isync until instructions
1791   //            preceding the isync have completed, [...]"
1792   //            From IBM's AIX assembler reference:
1793   //             "The isync [...] instructions causes the processor to
1794   //            refetch any instructions that might have been fetched
1795   //            prior to the isync instruction. The instruction isync
1796   //            causes the processor to wait for all previous instructions
1797   //            to complete. Then any instructions already fetched are
1798   //            discarded and instruction processing continues in the
1799   //            environment established by the previous instructions."
1800   //
1801   //  semantic barrier instructions:
1802   //  (as defined in orderAccess.hpp)
1803   //
1804   //  - release  orders Store|Store,       (maps to lwsync)
1805   //                     Load|Store
1806   //  - acquire  orders  Load|Store,       (maps to lwsync)
1807   //                     Load|Load
1808   //  - fence    orders Store|Store,       (maps to sync)
1809   //                     Load|Store,
1810   //                     Load|Load,
1811   //                    Store|Load
1812   //
1813  private:
1814   inline void sync(int l);
1815  public:
1816   inline void sync();
1817   inline void lwsync();
1818   inline void ptesync();
1819   inline void eieio();
1820   inline void isync();
1821   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1822 
1823   // Wait instructions for polling. Attention: May result in SIGILL.
1824   inline void wait();
1825   inline void waitrsv(); // &gt;=Power7
1826 
1827   // atomics
1828   inline void lbarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1829   inline void lharx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1830   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1831   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1832   inline void lqarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1833   inline bool lxarx_hint_exclusive_access();
1834   inline void lbarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1835   inline void lharx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1836   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1837   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1838   inline void lqarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1839   inline void stbcx_( Register s, Register a, Register b);
1840   inline void sthcx_( Register s, Register a, Register b);
1841   inline void stwcx_( Register s, Register a, Register b);
1842   inline void stdcx_( Register s, Register a, Register b);
1843   inline void stqcx_( Register s, Register a, Register b);
1844 
1845   // Instructions for adjusting thread priority for simultaneous
1846   // multithreading (SMT) on Power5.
1847  private:
1848   inline void smt_prio_very_low();
1849   inline void smt_prio_medium_high();
1850   inline void smt_prio_high();
1851 
1852  public:
1853   inline void smt_prio_low();
1854   inline void smt_prio_medium_low();
1855   inline void smt_prio_medium();
1856   // &gt;= Power7
1857   inline void smt_yield();
1858   inline void smt_mdoio();
1859   inline void smt_mdoom();
1860   // &gt;= Power8
1861   inline void smt_miso();
1862 
1863   // trap instructions
1864   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can't occur)
1865   // NOT FOR DIRECT USE!!
1866  protected:
1867   inline void tdi_unchecked(int tobits, Register a, int si16);
1868   inline void twi_unchecked(int tobits, Register a, int si16);
1869   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1870   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1871   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1872   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1873 
1874   static bool is_tdi(int x, int tobits, int ra, int si16) {
1875      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1876          &amp;&amp; (tobits == inv_to_field(x))
1877          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1878          &amp;&amp; (si16 == inv_si_field(x));
1879   }
1880 
1881   static bool is_twi(int x, int tobits, int ra, int si16) {
1882      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1883          &amp;&amp; (tobits == inv_to_field(x))
1884          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1885          &amp;&amp; (si16 == inv_si_field(x));
1886   }
1887 
1888   static bool is_twi(int x, int tobits, int ra) {
1889      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1890          &amp;&amp; (tobits == inv_to_field(x))
1891          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1892   }
1893 
1894   static bool is_td(int x, int tobits, int ra, int rb) {
1895      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1896          &amp;&amp; (tobits == inv_to_field(x))
1897          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1898          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1899   }
1900 
1901   static bool is_tw(int x, int tobits, int ra, int rb) {
1902      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1903          &amp;&amp; (tobits == inv_to_field(x))
1904          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1905          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1906   }
1907 
1908  public:
1909   // PPC floating point instructions
1910   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1911   inline void lfs(  FloatRegister d, int si16,   Register a);
1912   inline void lfsu( FloatRegister d, int si16,   Register a);
1913   inline void lfsx( FloatRegister d, Register a, Register b);
1914   inline void lfd(  FloatRegister d, int si16,   Register a);
1915   inline void lfdu( FloatRegister d, int si16,   Register a);
1916   inline void lfdx( FloatRegister d, Register a, Register b);
1917 
1918   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1919   inline void stfs(  FloatRegister s, int si16,   Register a);
1920   inline void stfsu( FloatRegister s, int si16,   Register a);
1921   inline void stfsx( FloatRegister s, Register a, Register b);
1922   inline void stfd(  FloatRegister s, int si16,   Register a);
1923   inline void stfdu( FloatRegister s, int si16,   Register a);
1924   inline void stfdx( FloatRegister s, Register a, Register b);
1925 
1926   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1927   inline void fmr(  FloatRegister d, FloatRegister b);
1928   inline void fmr_( FloatRegister d, FloatRegister b);
1929 
1930   //  inline void mffgpr( FloatRegister d, Register b);
1931   //  inline void mftgpr( Register d, FloatRegister b);
1932   inline void cmpb(   Register a, Register s, Register b);
1933   inline void popcntb(Register a, Register s);
1934   inline void popcntw(Register a, Register s);
1935   inline void popcntd(Register a, Register s);
1936 
1937   inline void fneg(  FloatRegister d, FloatRegister b);
1938   inline void fneg_( FloatRegister d, FloatRegister b);
1939   inline void fabs(  FloatRegister d, FloatRegister b);
1940   inline void fabs_( FloatRegister d, FloatRegister b);
1941   inline void fnabs( FloatRegister d, FloatRegister b);
1942   inline void fnabs_(FloatRegister d, FloatRegister b);
1943 
1944   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
1945   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
1946   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
1947   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
1948   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
1949   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
1950   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
1951   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
1952   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
1953   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
1954   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
1955   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
1956   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
1957   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
1958   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
1959   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
1960   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
1961 
1962   // Fused multiply-accumulate instructions.
1963   // WARNING: Use only when rounding between the 2 parts is not desired.
1964   // Some floating point tck tests will fail if used incorrectly.
1965   inline void fmadd(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1966   inline void fmadd_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1967   inline void fmadds(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1968   inline void fmadds_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1969   inline void fmsub(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1970   inline void fmsub_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1971   inline void fmsubs(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1972   inline void fmsubs_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1973   inline void fnmadd(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1974   inline void fnmadd_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1975   inline void fnmadds( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1976   inline void fnmadds_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1977   inline void fnmsub(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1978   inline void fnmsub_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1979   inline void fnmsubs( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1980   inline void fnmsubs_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1981 
1982   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
1983   inline void frsp(  FloatRegister d, FloatRegister b);
1984   inline void fctid( FloatRegister d, FloatRegister b);
1985   inline void fctidz(FloatRegister d, FloatRegister b);
1986   inline void fctiw( FloatRegister d, FloatRegister b);
1987   inline void fctiwz(FloatRegister d, FloatRegister b);
1988   inline void fcfid( FloatRegister d, FloatRegister b);
1989   inline void fcfids(FloatRegister d, FloatRegister b);
1990 
1991   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
1992   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
1993 
1994   inline void fsqrt( FloatRegister d, FloatRegister b);
1995   inline void fsqrts(FloatRegister d, FloatRegister b);
1996 
1997   // Vector instructions for &gt;= Power6.
1998   inline void lvebx(    VectorRegister d, Register s1, Register s2);
1999   inline void lvehx(    VectorRegister d, Register s1, Register s2);
2000   inline void lvewx(    VectorRegister d, Register s1, Register s2);
2001   inline void lvx(      VectorRegister d, Register s1, Register s2);
2002   inline void lvxl(     VectorRegister d, Register s1, Register s2);
2003   inline void stvebx(   VectorRegister d, Register s1, Register s2);
2004   inline void stvehx(   VectorRegister d, Register s1, Register s2);
2005   inline void stvewx(   VectorRegister d, Register s1, Register s2);
2006   inline void stvx(     VectorRegister d, Register s1, Register s2);
2007   inline void stvxl(    VectorRegister d, Register s1, Register s2);
2008   inline void lvsl(     VectorRegister d, Register s1, Register s2);
2009   inline void lvsr(     VectorRegister d, Register s1, Register s2);
2010   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
2011   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
2012   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
2013   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
2014   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
2015   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
2016   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
2017   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
2018   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
2019   inline void vupkhpx(  VectorRegister d, VectorRegister b);
2020   inline void vupkhsb(  VectorRegister d, VectorRegister b);
2021   inline void vupkhsh(  VectorRegister d, VectorRegister b);
2022   inline void vupklpx(  VectorRegister d, VectorRegister b);
2023   inline void vupklsb(  VectorRegister d, VectorRegister b);
2024   inline void vupklsh(  VectorRegister d, VectorRegister b);
2025   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
2026   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
2027   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
2028   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
2029   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
2030   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
2031   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
2032   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
2033   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
2034   inline void vspltisb( VectorRegister d, int si5);
2035   inline void vspltish( VectorRegister d, int si5);
2036   inline void vspltisw( VectorRegister d, int si5);
2037   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2038   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2039   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
2040   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int ui4);
2041   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
2042   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
2043   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
2044   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2045   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2046   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2047   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2048   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
2049   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2050   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2051   inline void vaddudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2052   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
2053   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
2054   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2055   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2056   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2057   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2058   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2059   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
2060   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2061   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2062   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
2063   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
2064   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2065   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
2066   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
2067   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
2068   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
2069   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
2070   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
2071   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
2072   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
2073   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2074   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
2075   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2076   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2077   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2078   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2079   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2080   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2081   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2082   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2083   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
2084   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
2085   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
2086   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
2087   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2088   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2089   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2090   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
2091   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
2092   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
2093   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2094   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2095   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2096   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
2097   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2098   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2099   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2100   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2101   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2102   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
2103   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2104   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2105   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
2106   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
2107   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
2108   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
2109   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
2110   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
2111   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
2112   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
2113   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
2114   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
2115   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
2116   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
2117   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
2118   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
2119   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
2120   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
2121   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
2122   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
2123   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
2124   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
2125   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
2126   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
2127   inline void vmr(      VectorRegister d, VectorRegister a);
2128   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
2129   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
2130   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
2131   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
2132   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
2133   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
2134   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
2135   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
2136   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
2137   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
2138   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
2139   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
2140   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
2141   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
2142   // Vector Floating-Point not implemented yet
2143   inline void mtvscr(   VectorRegister b);
2144   inline void mfvscr(   VectorRegister d);
2145 
2146   // Vector-Scalar (VSX) instructions.
2147   inline void lxvd2x(   VectorSRegister d, Register a);
2148   inline void lxvd2x(   VectorSRegister d, Register a, Register b);
2149   inline void stxvd2x(  VectorSRegister d, Register a);
2150   inline void stxvd2x(  VectorSRegister d, Register a, Register b);
2151   inline void mtvrwz(   VectorRegister  d, Register a);
2152   inline void mfvrwz(   Register        a, VectorRegister d);
2153   inline void mtvrd(    VectorRegister  d, Register a);
2154   inline void mfvrd(    Register        a, VectorRegister d);
2155   inline void xxpermdi( VectorSRegister d, VectorSRegister a, VectorSRegister b, int dm);
2156   inline void xxmrghw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2157   inline void xxmrglw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2158 
2159   // VSX Extended Mnemonics
2160   inline void xxspltd(  VectorSRegister d, VectorSRegister a, int x);
2161   inline void xxmrghd(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2162   inline void xxmrgld(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2163   inline void xxswapd(  VectorSRegister d, VectorSRegister a);
2164 
2165   // Vector-Scalar (VSX) instructions.
2166   inline void mtfprd(   FloatRegister   d, Register a);
2167   inline void mtfprwa(  FloatRegister   d, Register a);
2168   inline void mffprd(   Register        a, FloatRegister d);
2169 
2170   // AES (introduced with Power 8)
2171   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
2172   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
2173   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
2174   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
2175   inline void vsbox(       VectorRegister d, VectorRegister a);
2176 
2177   // SHA (introduced with Power 8)
2178   // Not yet implemented.
2179 
2180   // Vector Binary Polynomial Multiplication (introduced with Power 8)
2181   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
2182   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
2183   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
2184   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
2185 
2186   // Vector Permute and Xor (introduced with Power 8)
2187   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2188 
2189   // Transactional Memory instructions (introduced with Power 8)
2190   inline void tbegin_();    // R=0
2191   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
2192   inline void tend_();    // A=0
2193   inline void tendall_(); // A=1
2194   inline void tabort_();
2195   inline void tabort_(Register a);
2196   inline void tabortwc_(int t, Register a, Register b);
2197   inline void tabortwci_(int t, Register a, int si);
2198   inline void tabortdc_(int t, Register a, Register b);
2199   inline void tabortdci_(int t, Register a, int si);
2200   inline void tsuspend_(); // tsr with L=0
2201   inline void tresume_();  // tsr with L=1
2202   inline void tcheck(int f);
2203 
2204   static bool is_tbegin(int x) {
2205     return TBEGIN_OPCODE == (x &amp; (0x3f &lt;&lt; OPCODE_SHIFT | 0x3ff &lt;&lt; 1));
2206   }
2207 
2208   // The following encoders use r0 as second operand. These instructions
2209   // read r0 as '0'.
2210   inline void lwzx( Register d, Register s2);
2211   inline void lwz(  Register d, int si16);
2212   inline void lwax( Register d, Register s2);
2213   inline void lwa(  Register d, int si16);
2214   inline void lwbrx(Register d, Register s2);
2215   inline void lhzx( Register d, Register s2);
2216   inline void lhz(  Register d, int si16);
2217   inline void lhax( Register d, Register s2);
2218   inline void lha(  Register d, int si16);
2219   inline void lhbrx(Register d, Register s2);
2220   inline void lbzx( Register d, Register s2);
2221   inline void lbz(  Register d, int si16);
2222   inline void ldx(  Register d, Register s2);
2223   inline void ld(   Register d, int si16);
2224   inline void ldbrx(Register d, Register s2);
2225   inline void stwx( Register d, Register s2);
2226   inline void stw(  Register d, int si16);
2227   inline void stwbrx( Register d, Register s2);
2228   inline void sthx( Register d, Register s2);
2229   inline void sth(  Register d, int si16);
2230   inline void sthbrx( Register d, Register s2);
2231   inline void stbx( Register d, Register s2);
2232   inline void stb(  Register d, int si16);
2233   inline void stdx( Register d, Register s2);
2234   inline void std(  Register d, int si16);
2235   inline void stdbrx( Register d, Register s2);
2236 
2237   // PPC 2, section 3.2.1 Instruction Cache Instructions
2238   inline void icbi(    Register s2);
2239   // PPC 2, section 3.2.2 Data Cache Instructions
2240   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2241   inline void dcbz(    Register s2);
2242   inline void dcbst(   Register s2);
2243   inline void dcbf(    Register s2);
2244   // dcache read hint
2245   inline void dcbt(    Register s2);
2246   inline void dcbtct(  Register s2, int ct);
2247   inline void dcbtds(  Register s2, int ds);
2248   // dcache write hint
2249   inline void dcbtst(  Register s2);
2250   inline void dcbtstct(Register s2, int ct);
2251 
2252   // Atomics: use ra0mem to disallow R0 as base.
2253   inline void lbarx_unchecked(Register d, Register b, int eh1);
2254   inline void lharx_unchecked(Register d, Register b, int eh1);
2255   inline void lwarx_unchecked(Register d, Register b, int eh1);
2256   inline void ldarx_unchecked(Register d, Register b, int eh1);
2257   inline void lqarx_unchecked(Register d, Register b, int eh1);
2258   inline void lbarx( Register d, Register b, bool hint_exclusive_access);
2259   inline void lharx( Register d, Register b, bool hint_exclusive_access);
2260   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2261   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2262   inline void lqarx( Register d, Register b, bool hint_exclusive_access);
2263   inline void stbcx_(Register s, Register b);
2264   inline void sthcx_(Register s, Register b);
2265   inline void stwcx_(Register s, Register b);
2266   inline void stdcx_(Register s, Register b);
2267   inline void stqcx_(Register s, Register b);
2268   inline void lfs(   FloatRegister d, int si16);
2269   inline void lfsx(  FloatRegister d, Register b);
2270   inline void lfd(   FloatRegister d, int si16);
2271   inline void lfdx(  FloatRegister d, Register b);
2272   inline void stfs(  FloatRegister s, int si16);
2273   inline void stfsx( FloatRegister s, Register b);
2274   inline void stfd(  FloatRegister s, int si16);
2275   inline void stfdx( FloatRegister s, Register b);
2276   inline void lvebx( VectorRegister d, Register s2);
2277   inline void lvehx( VectorRegister d, Register s2);
2278   inline void lvewx( VectorRegister d, Register s2);
2279   inline void lvx(   VectorRegister d, Register s2);
2280   inline void lvxl(  VectorRegister d, Register s2);
2281   inline void stvebx(VectorRegister d, Register s2);
2282   inline void stvehx(VectorRegister d, Register s2);
2283   inline void stvewx(VectorRegister d, Register s2);
2284   inline void stvx(  VectorRegister d, Register s2);
2285   inline void stvxl( VectorRegister d, Register s2);
2286   inline void lvsl(  VectorRegister d, Register s2);
2287   inline void lvsr(  VectorRegister d, Register s2);
2288 
2289   // RegisterOrConstant versions.
2290   // These emitters choose between the versions using two registers and
2291   // those with register and immediate, depending on the content of roc.
2292   // If the constant is not encodable as immediate, instructions to
2293   // load the constant are emitted beforehand. Store instructions need a
2294   // tmp reg if the constant is not encodable as immediate.
2295   // Size unpredictable.
2296   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2297   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2298   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2299   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2300   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2301   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2302   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2303   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2304   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2305   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2306   void add( Register d, RegisterOrConstant roc, Register s1);
2307   void subf(Register d, RegisterOrConstant roc, Register s1);
2308   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2309   // Load pointer d from s1+roc.
2310   void ld_ptr(Register d, RegisterOrConstant roc, Register s1 = noreg) { ld(d, roc, s1); }
2311 
2312   // Emit several instructions to load a 64 bit constant. This issues a fixed
2313   // instruction pattern so that the constant can be patched later on.
2314   enum {
2315     load_const_size = 5 * BytesPerInstWord
2316   };
2317          void load_const(Register d, long a,            Register tmp = noreg);
2318   inline void load_const(Register d, void* a,           Register tmp = noreg);
2319   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2320   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2321   inline void load_const32(Register d, int i); // load signed int (patchable)
2322 
2323   // Load a 64 bit constant, optimized, not identifyable.
2324   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2325   // 16 bit immediate offset. This is useful if the offset can be encoded in
2326   // a succeeding instruction.
2327          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2328   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2329     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2330   }
2331 
2332   // If return_simm16_rest, the return value needs to get added afterwards.
2333          int add_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false);
2334   inline int add_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2335     return add_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2336   }
2337 
2338   // If return_simm16_rest, the return value needs to get added afterwards.
2339   inline int sub_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false) {
2340     return add_const_optimized(d, s, -x, tmp, return_simm16_rest);
2341   }
2342   inline int sub_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2343     return sub_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2344   }
2345 
2346   // Creation
2347   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2348 #ifdef CHECK_DELAY
2349     delay_state = no_delay;
2350 #endif
2351   }
2352 
2353   // Testing
2354 #ifndef PRODUCT
2355   void test_asm();
2356 #endif
2357 };
2358 
2359 
2360 #endif // CPU_PPC_VM_ASSEMBLER_PPC_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>

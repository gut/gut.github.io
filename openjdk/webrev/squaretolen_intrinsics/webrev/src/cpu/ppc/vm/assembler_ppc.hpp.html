<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/cpu/ppc/vm/assembler_ppc.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2016 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_VM_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_VM_ASSEMBLER_PPC_HPP
  28 
  29 #include "asm/register.hpp"
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 class Address VALUE_OBJ_CLASS_SPEC {
  35  private:
  36   Register _base;         // Base register.
  37   Register _index;        // Index register.
  38   intptr_t _disp;         // Displacement.
  39 
  40  public:
  41   Address(Register b, Register i, address d = 0)
  42     : _base(b), _index(i), _disp((intptr_t)d) {
  43     assert(i == noreg || d == 0, "can't have both");
  44   }
  45 
  46   Address(Register b, address d = 0)
  47     : _base(b), _index(noreg), _disp((intptr_t)d) {}
  48 
  49   Address(Register b, intptr_t d)
  50     : _base(b), _index(noreg), _disp(d) {}
  51 
  52   Address(Register b, RegisterOrConstant roc)
  53     : _base(b), _index(noreg), _disp(0) {
  54     if (roc.is_constant()) _disp = roc.as_constant(); else _index = roc.as_register();
  55   }
  56 
  57   Address()
  58     : _base(noreg), _index(noreg), _disp(0) {}
  59 
  60   // accessors
  61   Register base()  const { return _base; }
  62   Register index() const { return _index; }
  63   int      disp()  const { return (int)_disp; }
  64   bool     is_const() const { return _base == noreg &amp;&amp; _index == noreg; }
  65 };
  66 
  67 class AddressLiteral VALUE_OBJ_CLASS_SPEC {
  68  private:
  69   address          _address;
  70   RelocationHolder _rspec;
  71 
  72   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  73     switch (rtype) {
  74     case relocInfo::external_word_type:
  75       return external_word_Relocation::spec(addr);
  76     case relocInfo::internal_word_type:
  77       return internal_word_Relocation::spec(addr);
  78     case relocInfo::opt_virtual_call_type:
  79       return opt_virtual_call_Relocation::spec();
  80     case relocInfo::static_call_type:
  81       return static_call_Relocation::spec();
  82     case relocInfo::runtime_call_type:
  83       return runtime_call_Relocation::spec();
  84     case relocInfo::none:
  85       return RelocationHolder();
  86     default:
  87       ShouldNotReachHere();
  88       return RelocationHolder();
  89     }
  90   }
  91 
  92  protected:
  93   // creation
  94   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  95 
  96  public:
  97   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  98     : _address(addr),
  99       _rspec(rspec) {}
 100 
 101   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 102     : _address((address) addr),
 103       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 104 
 105   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
 106     : _address((address) addr),
 107       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 108 
 109   intptr_t value() const { return (intptr_t) _address; }
 110 
 111   const RelocationHolder&amp; rspec() const { return _rspec; }
 112 };
 113 
 114 // Argument is an abstraction used to represent an outgoing
 115 // actual argument or an incoming formal parameter, whether
 116 // it resides in memory or in a register, in a manner consistent
 117 // with the PPC Application Binary Interface, or ABI. This is
 118 // often referred to as the native or C calling convention.
 119 
 120 class Argument VALUE_OBJ_CLASS_SPEC {
 121  private:
 122   int _number;  // The number of the argument.
 123  public:
 124   enum {
 125     // Only 8 registers may contain integer parameters.
 126     n_register_parameters = 8,
 127     // Can have up to 8 floating registers.
 128     n_float_register_parameters = 8,
 129 
 130     // PPC C calling conventions.
 131     // The first eight arguments are passed in int regs if they are int.
 132     n_int_register_parameters_c = 8,
 133     // The first thirteen float arguments are passed in float regs.
 134     n_float_register_parameters_c = 13,
 135     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 136     // shows that xlC places all float args after argument 8 on the stack AND
 137     // in a register. This is not documented, but we follow this convention, too.
 138     n_regs_not_on_stack_c = 8,
 139   };
 140   // creation
 141   Argument(int number) : _number(number) {}
 142 
 143   int  number() const { return _number; }
 144 
 145   // Locating register-based arguments:
 146   bool is_register() const { return _number &lt; n_register_parameters; }
 147 
 148   Register as_register() const {
 149     assert(is_register(), "must be a register argument");
 150     return as_Register(number() + R3_ARG1-&gt;encoding());
 151   }
 152 };
 153 
 154 #if !defined(ABI_ELFv2)
 155 // A ppc64 function descriptor.
 156 struct FunctionDescriptor VALUE_OBJ_CLASS_SPEC {
 157  private:
 158   address _entry;
 159   address _toc;
 160   address _env;
 161 
 162  public:
 163   inline address entry() const { return _entry; }
 164   inline address toc()   const { return _toc; }
 165   inline address env()   const { return _env; }
 166 
 167   inline void set_entry(address entry) { _entry = entry; }
 168   inline void set_toc(  address toc)   { _toc   = toc; }
 169   inline void set_env(  address env)   { _env   = env; }
 170 
 171   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 172   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 173   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 174 
 175   // Friend functions can be called without loading toc and env.
 176   enum {
 177     friend_toc = 0xcafe,
 178     friend_env = 0xc0de
 179   };
 180 
 181   inline bool is_friend_function() const {
 182     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 183   }
 184 
 185   // Constructor for stack-allocated instances.
 186   FunctionDescriptor() {
 187     _entry = (address) 0xbad;
 188     _toc   = (address) 0xbad;
 189     _env   = (address) 0xbad;
 190   }
 191 };
 192 #endif
 193 
 194 
 195 // The PPC Assembler: Pure assembler doing NO optimizations on the
 196 // instruction level; i.e., what you write is what you get. The
 197 // Assembler is generating code into a CodeBuffer.
 198 
 199 class Assembler : public AbstractAssembler {
 200  protected:
 201   // Displacement routines
 202   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 203   static int  branch_destination(int inst, int pos);
 204 
 205   friend class AbstractAssembler;
 206 
 207   // Code patchers need various routines like inv_wdisp()
 208   friend class NativeInstruction;
 209   friend class NativeGeneralJump;
 210   friend class Relocation;
 211 
 212  public:
 213 
 214   enum shifts {
 215     XO_21_29_SHIFT = 2,
 216     XO_21_30_SHIFT = 1,
 217     XO_27_29_SHIFT = 2,
 218     XO_30_31_SHIFT = 0,
 219     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 220     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 221     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 222     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 223   };
 224 
 225   enum opcdxos_masks {
 226     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 227     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 228     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 229     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 230     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 231     // trap instructions
 232     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 233     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 234     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 235     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 236     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 237     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 238     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 239     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 240     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 241     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 242     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 243     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 244     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 245     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 246     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 247     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 248     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 249   };
 250 
 251   enum opcdxos {
 252     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 253     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 254     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 255     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 256     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 257     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 258     ADDME_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 234u &lt;&lt; 1),
 259     ADDZE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 202u &lt;&lt; 1),
 260     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 261     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 262     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 263     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 264     SUBFME_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 232u &lt;&lt; 1),
 265     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 266     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 267     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 268     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 269     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 270     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 271     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 272     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 273     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 274     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 275     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 276     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 277     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 278     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 279     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 280     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 281     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 282 
 283     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 284 
 285     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 286     CLRRWI_OPCODE = RLWINM_OPCODE,
 287     CLRLWI_OPCODE = RLWINM_OPCODE,
 288 
 289     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 290 
 291     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 292     SLWI_OPCODE   = RLWINM_OPCODE,
 293     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 294     SRWI_OPCODE   = RLWINM_OPCODE,
 295     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 296     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 297 
 298     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 299     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 300     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 301     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 302 
 303     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 304 
 305     // Special purpose registers
 306     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 307     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 308 
 309     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 310     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 311 
 312     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 313     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 314 
 315     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 316     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 317 
 318     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 319     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 320 
 321     // Attention: Higher and lower half are inserted in reversed order.
 322     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 323     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 324     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 325     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 326     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 327     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 328     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 329     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 330 
 331     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 332     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 333 
 334     MFTB_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 12 &lt;&lt; SPR_0_4_SHIFT),
 335 
 336     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 337     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 338     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 339 
 340     // condition register logic instructions
 341     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 342     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 343     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 344     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 345     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 346     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 347     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 348     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 349 
 350     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 351     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 352     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 353 
 354     // CTR-related opcodes
 355     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 356 
 357     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 358     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 359     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 360     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 361 
 362     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 363     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 364     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 365 
 366     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 367     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 368     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 369     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 370 
 371     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 372     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 373     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 374 
 375     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 376     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 377     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 378     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 379 
 380     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 381     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 382     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 383 
 384     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 385     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 386     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 387 
 388     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 389     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 390     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 391 
 392     // 32 bit opcode encodings
 393 
 394     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 395     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 396 
 397     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 398 
 399     // 64 bit opcode encodings
 400 
 401     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 402     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 403     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 404 
 405     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 406     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 407     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),                  // X-FORM
 408     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 409 
 410     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 411     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 412     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 413     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 414 
 415     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 416 
 417     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 418     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 419     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 420 
 421     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 422     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 423     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 424     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 425 
 426     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 427     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 428     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 429 
 430 
 431     // opcodes only used for floating arithmetic
 432     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 433     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 434     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 435     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 436     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 437     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
 438     // These are special Power6 opcodes, reused for "lfdepx" and "stfdepx"
 439     // on Power7.  Do not use.
 440     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 441     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 442     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 443     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 444     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 445     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 446     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 447     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 448     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 449     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 450     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 451     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 452     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 453 
 454     // PPC64-internal FPU conversion opcodes
 455     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 456     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 457     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 458     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 459     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 460     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 461     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 462 
 463     // Fused multiply-accumulate instructions.
 464     FMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 465     FMADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 466     FMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 467     FMSUBS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 468     FNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 469     FNMADDS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 470     FNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 471     FNMSUBS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 472 
 473     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 474     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 475     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 476     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 477     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 478     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 479 
 480     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 481     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 482     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 483     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 484     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 485     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 486 
 487     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 488     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 489 
 490     // Vector instruction support for &gt;= Power6
 491     // Vector Storage Access
 492     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 493     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 494     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 495     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 496     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 497     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 498     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 499     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 500     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 501     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 502     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 503     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 504 
 505     // Vector-Scalar (VSX) instruction support.
 506     LXVD2X_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  844u &lt;&lt; 1),
 507     STXVD2X_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  972u &lt;&lt; 1),
 508     MTVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  179u &lt;&lt; 1),
 509     MFVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   51u &lt;&lt; 1),
 510 
 511     // Vector Permute and Formatting
 512     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 513     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 514     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 515     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 516     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 517     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 518     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 519     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 520     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 521     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 522     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 523     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 524     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 525     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 526     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 527 
 528     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 529     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 530     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 531     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 532     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 533     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 534 
 535     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 536     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 537     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 538     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 539     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 540     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 541 
 542     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 543     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 544 
 545     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 546     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 547     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 548     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 549     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 550 
 551     // Vector Integer
 552     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 553     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 554     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 555     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 556     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 557     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 558     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
 559     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 560     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 561     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 562     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 563     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 564     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 565     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 566     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 567     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 568     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 569     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 570     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 571     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 572 
 573     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 574     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 575     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 576     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 577     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 578     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 579     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 580     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 581     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 582     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 583     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 584     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 585     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 586     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 587     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 588     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 589     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 590 
 591     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 592     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 593     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 594     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 595     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 596 
 597     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 598     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 599     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 600     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 601     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 602     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 603 
 604     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 605     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 606     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 607     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 608     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 609     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 610     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 611     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 612     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 613     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 614     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 615     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 616 
 617     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 618     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 619     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 620     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 621     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 622     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 623     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 624     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 625     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 626 
 627     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 628     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 629     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 630     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 631     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 632     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 633     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 634     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 635     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 636     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 637     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 638     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 639     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 640     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 641     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 642     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 643     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 644     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 645 
 646     // Vector Floating-Point
 647     // not implemented yet
 648 
 649     // Vector Status and Control
 650     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 651     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 652 
 653     // AES (introduced with Power 8)
 654     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 655     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 656     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 657     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 658     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 659 
 660     // SHA (introduced with Power 8)
 661     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 662     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 663 
 664     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 665     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 666     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 667     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 668     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 669 
 670     // Vector Permute and Xor (introduced with Power 8)
 671     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 672 
 673     // Transactional Memory instructions (introduced with Power 8)
 674     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 675     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 676     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 677     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 678     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 679     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 680     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 681     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 682     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 683 
 684     // Icache and dcache related instructions
 685     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 686     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 687     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 688     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 689 
 690     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 691     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 692     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 693 
 694     // Instruction synchronization
 695     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 696     // Memory barriers
 697     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 698     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 699 
 700     // Wait instructions for polling.
 701     WAIT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   62u &lt;&lt; 1),
 702 
 703     // Trap instructions
 704     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 705     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 706     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 707     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 708 
 709     // Atomics.
 710     LBARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   52u &lt;&lt; 1),
 711     LHARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  116u &lt;&lt; 1),
 712     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 713     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 714     LQARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  276u &lt;&lt; 1),
 715     STBCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  694u &lt;&lt; 1),
 716     STHCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  726u &lt;&lt; 1),
 717     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 718     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1),
 719     STQCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  182u &lt;&lt; 1)
 720 
 721   };
 722 
 723   // Trap instructions TO bits
 724   enum trap_to_bits {
 725     // single bits
 726     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 727     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 728     traptoEqual               = 1 &lt;&lt; 2,
 729     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 730     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 731 
 732     // compound ones
 733     traptoUnconditional       = (traptoLessThanSigned |
 734                                  traptoGreaterThanSigned |
 735                                  traptoEqual |
 736                                  traptoLessThanUnsigned |
 737                                  traptoGreaterThanUnsigned)
 738   };
 739 
 740   // Branch hints BH field
 741   enum branch_hint_bh {
 742     // bclr cases:
 743     bhintbhBCLRisReturn            = 0,
 744     bhintbhBCLRisNotReturnButSame  = 1,
 745     bhintbhBCLRisNotPredictable    = 3,
 746 
 747     // bcctr cases:
 748     bhintbhBCCTRisNotReturnButSame = 0,
 749     bhintbhBCCTRisNotPredictable   = 3
 750   };
 751 
 752   // Branch prediction hints AT field
 753   enum branch_hint_at {
 754     bhintatNoHint     = 0,  // at=00
 755     bhintatIsNotTaken = 2,  // at=10
 756     bhintatIsTaken    = 3   // at=11
 757   };
 758 
 759   // Branch prediction hints
 760   enum branch_hint_concept {
 761     // Use the same encoding as branch_hint_at to simply code.
 762     bhintNoHint       = bhintatNoHint,
 763     bhintIsNotTaken   = bhintatIsNotTaken,
 764     bhintIsTaken      = bhintatIsTaken
 765   };
 766 
 767   // Used in BO field of branch instruction.
 768   enum branch_condition {
 769     bcondCRbiIs0      =  4, // bo=001at
 770     bcondCRbiIs1      = 12, // bo=011at
 771     bcondAlways       = 20  // bo=10100
 772   };
 773 
 774   // Branch condition with combined prediction hints.
 775   enum branch_condition_with_hint {
 776     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 777     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 778     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 779     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 780     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 781     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 782   };
 783 
 784   // Elemental Memory Barriers (&gt;=Power 8)
 785   enum Elemental_Membar_mask_bits {
 786     StoreStore = 1 &lt;&lt; 0,
 787     StoreLoad  = 1 &lt;&lt; 1,
 788     LoadStore  = 1 &lt;&lt; 2,
 789     LoadLoad   = 1 &lt;&lt; 3
 790   };
 791 
 792   // Branch prediction hints.
 793   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 794     switch (boint) {
 795       case bcondCRbiIs0:
 796       case bcondCRbiIs1:
 797         // branch_hint and branch_hint_at have same encodings
 798         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 799                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 800                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 801                "wrong encodings");
 802         assert((bhint &amp; 0x03) == bhint, "wrong encodings");
 803         return (boint &amp; ~0x03) | bhint;
 804       case bcondAlways:
 805         // no branch_hint
 806         return boint;
 807       default:
 808         ShouldNotReachHere();
 809         return 0;
 810     }
 811   }
 812 
 813   // Extract bcond from boint.
 814   inline static int inv_boint_bcond(const int boint) {
 815     int r_bcond = boint &amp; ~0x03;
 816     assert(r_bcond == bcondCRbiIs0 ||
 817            r_bcond == bcondCRbiIs1 ||
 818            r_bcond == bcondAlways,
 819            "bad branch condition");
 820     return r_bcond;
 821   }
 822 
 823   // Extract bhint from boint.
 824   inline static int inv_boint_bhint(const int boint) {
 825     int r_bhint = boint &amp; 0x03;
 826     assert(r_bhint == bhintatNoHint ||
 827            r_bhint == bhintatIsNotTaken ||
 828            r_bhint == bhintatIsTaken,
 829            "bad branch hint");
 830     return r_bhint;
 831   }
 832 
 833   // Calculate opposite of given bcond.
 834   inline static int opposite_bcond(const int bcond) {
 835     switch (bcond) {
 836       case bcondCRbiIs0:
 837         return bcondCRbiIs1;
 838       case bcondCRbiIs1:
 839         return bcondCRbiIs0;
 840       default:
 841         ShouldNotReachHere();
 842         return 0;
 843     }
 844   }
 845 
 846   // Calculate opposite of given bhint.
 847   inline static int opposite_bhint(const int bhint) {
 848     switch (bhint) {
 849       case bhintatNoHint:
 850         return bhintatNoHint;
 851       case bhintatIsNotTaken:
 852         return bhintatIsTaken;
 853       case bhintatIsTaken:
 854         return bhintatIsNotTaken;
 855       default:
 856         ShouldNotReachHere();
 857         return 0;
 858     }
 859   }
 860 
 861   // PPC branch instructions
 862   enum ppcops {
 863     b_op    = 18,
 864     bc_op   = 16,
 865     bcr_op  = 19
 866   };
 867 
 868   enum Condition {
 869     negative         = 0,
 870     less             = 0,
 871     positive         = 1,
 872     greater          = 1,
 873     zero             = 2,
 874     equal            = 2,
 875     summary_overflow = 3,
 876   };
 877 
 878  public:
 879   // Helper functions for groups of instructions
 880 
 881   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 882 
 883   // Instruction must start at passed address.
 884   static int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 885 
 886   // longest instructions
 887   static int instr_maxlen() { return BytesPerInstWord; }
 888 
 889   // Test if x is within signed immediate range for nbits.
 890   static bool is_simm(int x, unsigned int nbits) {
 891     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 892     const int   min      = -(((int)1) &lt;&lt; nbits-1);
 893     const int   maxplus1 =  (((int)1) &lt;&lt; nbits-1);
 894     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 895   }
 896 
 897   static bool is_simm(jlong x, unsigned int nbits) {
 898     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 899     const jlong min      = -(((jlong)1) &lt;&lt; nbits-1);
 900     const jlong maxplus1 =  (((jlong)1) &lt;&lt; nbits-1);
 901     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 902   }
 903 
 904   // Test if x is within unsigned immediate range for nbits.
 905   static bool is_uimm(int x, unsigned int nbits) {
 906     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, "out of bounds");
 907     const unsigned int maxplus1 = (((unsigned int)1) &lt;&lt; nbits);
 908     return (unsigned int)x &lt; maxplus1;
 909   }
 910 
 911   static bool is_uimm(jlong x, unsigned int nbits) {
 912     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, "out of bounds");
 913     const julong maxplus1 = (((julong)1) &lt;&lt; nbits);
 914     return (julong)x &lt; maxplus1;
 915   }
 916 
 917  protected:
 918   // helpers
 919 
 920   // X is supposed to fit in a field "nbits" wide
 921   // and be sign-extended. Check the range.
 922   static void assert_signed_range(intptr_t x, int nbits) {
 923     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 924            "value out of range");
 925   }
 926 
 927   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 928     assert((x &amp; 3) == 0, "not word aligned");
 929     assert_signed_range(x, nbits + 2);
 930   }
 931 
 932   static void assert_unsigned_const(int x, int nbits) {
 933     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), "unsigned constant out of range");
 934   }
 935 
 936   static int fmask(juint hi_bit, juint lo_bit) {
 937     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, "bad bits");
 938     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 939   }
 940 
 941   // inverse of u_field
 942   static int inv_u_field(int x, int hi_bit, int lo_bit) {
 943     juint r = juint(x) &gt;&gt; lo_bit;
 944     r &amp;= fmask(hi_bit, lo_bit);
 945     return int(r);
 946   }
 947 
 948   // signed version: extract from field and sign-extend
 949   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
 950     x = x &lt;&lt; (31-hi_bit);
 951     x = x &gt;&gt; (31-hi_bit+lo_bit);
 952     return x;
 953   }
 954 
 955   static int u_field(int x, int hi_bit, int lo_bit) {
 956     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, "value out of range");
 957     int r = x &lt;&lt; lo_bit;
 958     assert(inv_u_field(r, hi_bit, lo_bit) == x, "just checking");
 959     return r;
 960   }
 961 
 962   // Same as u_field for signed values
 963   static int s_field(int x, int hi_bit, int lo_bit) {
 964     int nbits = hi_bit - lo_bit + 1;
 965     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 966       "value out of range");
 967     x &amp;= fmask(hi_bit, lo_bit);
 968     int r = x &lt;&lt; lo_bit;
 969     return r;
 970   }
 971 
 972   // inv_op for ppc instructions
 973   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
 974 
 975   // Determine target address from li, bd field of branch instruction.
 976   static intptr_t inv_li_field(int x) {
 977     intptr_t r = inv_s_field_ppc(x, 25, 2);
 978     r = (r &lt;&lt; 2);
 979     return r;
 980   }
 981   static intptr_t inv_bd_field(int x, intptr_t pos) {
 982     intptr_t r = inv_s_field_ppc(x, 15, 2);
 983     r = (r &lt;&lt; 2) + pos;
 984     return r;
 985   }
 986 
 987   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
 988   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
 989   // Extract instruction fields from instruction words.
 990  public:
 991   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
 992   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
 993   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
 994   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
 995   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
 996   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
 997   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
 998   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
 999   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1000   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1001   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
1002   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
1003   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1004   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1005 
1006   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
1007   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
1008 
1009   // instruction fields
1010   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
1011   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
1012   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
1013   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
1014   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
1015   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
1016   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
1017   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
1018   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
1019   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
1020   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
1021   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
1022   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
1023   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
1024   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
1025   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, "unaligned offset"); return opp_s_field(x, 31, 16); }
1026   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
1027   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
1028   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
1029   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
1030   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
1031   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
1032   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
1033   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
1034   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
1035   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
1036   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
1037   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
1038   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
1039   static int l10(      int         x)  { return  opp_u_field(x,             10, 10); }
1040   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
1041   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
1042   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
1043   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
1044   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
1045   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1046   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1047   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1048   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1049   static int me2126(   int         x)  { return  mb2126(x); }
1050   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1051   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1052   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1053   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1054   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1055   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1056   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1057   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1058   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1059   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1060   // we don't want to use R0 in memory accesses, because it has value `0' then
1061   static int ra0mem(   Register    r)  { assert(r != R0, "cannot use register R0 in memory access"); return ra(r); }
1062   static int ra0mem(   int         x)  { assert(x != 0,  "cannot use register 0 in memory access");  return ra(x); }
1063 
1064   // register r is target
1065   static int rt(       Register    r)  { return rs(r); }
1066   static int rt(       int         x)  { return rs(x); }
1067   static int rta(      Register    r)  { return ra(r); }
1068   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1069 
1070   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1071   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1072   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1073   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1074   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1075   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1076   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1077   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1078   static int thct(     int         x)  { assert((x&amp;8) == 0, "must be valid cache specification");  return th(x); }
1079   static int thds(     int         x)  { assert((x&amp;8) == 8, "must be valid stream specification"); return th(x); }
1080   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1081   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1082   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1083 
1084   // Support vector instructions for &gt;= Power6.
1085   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1086   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1087   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1088   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1089   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1090 
1091   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1092   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1093   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1094   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1095   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1096 
1097   // Support Vector-Scalar (VSX) instructions.
1098   static int vsra(      int         x)  { return  opp_u_field(x,            15, 11); }
1099   static int vsrb(      int         x)  { return  opp_u_field(x,            20, 16); }
1100   static int vsrc(      int         x)  { return  opp_u_field(x,            25, 21); }
1101   static int vsrs(      int         x)  { return  opp_u_field(x,            10,  6); }
1102   static int vsrt(      int         x)  { return  opp_u_field(x,            10,  6); }
1103 
1104   static int vsra(   VectorSRegister r)  { return  vsra(r-&gt;encoding());}
1105   static int vsrb(   VectorSRegister r)  { return  vsrb(r-&gt;encoding());}
1106   static int vsrc(   VectorSRegister r)  { return  vsrc(r-&gt;encoding());}
1107   static int vsrs(   VectorSRegister r)  { return  vsrs(r-&gt;encoding());}
1108   static int vsrt(   VectorSRegister r)  { return  vsrt(r-&gt;encoding());}
1109 
1110   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1111   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1112   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1113   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1114 
1115   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1116   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1117   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1118   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1119   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1120   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1121   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1122 
1123  protected:
1124   // Compute relative address for branch.
1125   static intptr_t disp(intptr_t x, intptr_t off) {
1126     int xx = x - off;
1127     xx = xx &gt;&gt; 2;
1128     return xx;
1129   }
1130 
1131  public:
1132   // signed immediate, in low bits, nbits long
1133   static int simm(int x, int nbits) {
1134     assert_signed_range(x, nbits);
1135     return x &amp; ((1 &lt;&lt; nbits) - 1);
1136   }
1137 
1138   // unsigned immediate, in low bits, nbits long
1139   static int uimm(int x, int nbits) {
1140     assert_unsigned_const(x, nbits);
1141     return x &amp; ((1 &lt;&lt; nbits) - 1);
1142   }
1143 
1144   static void set_imm(int* instr, short s) {
1145     // imm is always in the lower 16 bits of the instruction,
1146     // so this is endian-neutral. Same for the get_imm below.
1147     uint32_t w = *(uint32_t *)instr;
1148     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1149   }
1150 
1151   static int get_imm(address a, int instruction_number) {
1152     return (short)((int *)a)[instruction_number];
1153   }
1154 
1155   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1156   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1157 
1158  protected:
1159 
1160   // Extract the top 32 bits in a 64 bit word.
1161   static int32_t hi32(int64_t x) {
1162     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1163     return r;
1164   }
1165 
1166  public:
1167 
1168   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1169     return ((addr + (a - 1)) &amp; ~(a - 1));
1170   }
1171 
1172   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1173     return (0 == addr % a);
1174   }
1175 
1176   void flush() {
1177     AbstractAssembler::flush();
1178   }
1179 
1180   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1181   inline void emit_data(int);
1182   inline void emit_data(int, RelocationHolder const&amp;);
1183   inline void emit_data(int, relocInfo::relocType rtype);
1184 
1185   // Emit an address.
1186   inline address emit_addr(const address addr = NULL);
1187 
1188 #if !defined(ABI_ELFv2)
1189   // Emit a function descriptor with the specified entry point, TOC,
1190   // and ENV. If the entry point is NULL, the descriptor will point
1191   // just past the descriptor.
1192   // Use values from friend functions as defaults.
1193   inline address emit_fd(address entry = NULL,
1194                          address toc = (address) FunctionDescriptor::friend_toc,
1195                          address env = (address) FunctionDescriptor::friend_env);
1196 #endif
1197 
1198   /////////////////////////////////////////////////////////////////////////////////////
1199   // PPC instructions
1200   /////////////////////////////////////////////////////////////////////////////////////
1201 
1202   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1203   // immediates. The normal instruction encoders enforce that r0 is not
1204   // passed to them. Use either extended mnemonics encoders or the special ra0
1205   // versions.
1206 
1207   // Issue an illegal instruction.
1208   inline void illtrap();
1209   static inline bool is_illtrap(int x);
1210 
1211   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1212   inline void addi( Register d, Register a, int si16);
1213   inline void addis(Register d, Register a, int si16);
1214  private:
1215   inline void addi_r0ok( Register d, Register a, int si16);
1216   inline void addis_r0ok(Register d, Register a, int si16);
1217  public:
1218   inline void addic_( Register d, Register a, int si16);
1219   inline void subfic( Register d, Register a, int si16);
1220   inline void add(    Register d, Register a, Register b);
1221   inline void add_(   Register d, Register a, Register b);
1222   inline void subf(   Register d, Register a, Register b);  // d = b - a    "Sub_from", as in ppc spec.
1223   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1224   inline void subf_(  Register d, Register a, Register b);
1225   inline void addc(   Register d, Register a, Register b);
1226   inline void addc_(  Register d, Register a, Register b);
1227   inline void subfc(  Register d, Register a, Register b);
1228   inline void subfc_( Register d, Register a, Register b);
1229   inline void adde(   Register d, Register a, Register b);
1230   inline void adde_(  Register d, Register a, Register b);
1231   inline void subfe(  Register d, Register a, Register b);
1232   inline void subfe_( Register d, Register a, Register b);
1233   inline void addme(  Register d, Register a);
1234   inline void addme_( Register d, Register a);
1235   inline void subfme( Register d, Register a);
1236   inline void subfme_(Register d, Register a);
1237   inline void addze(  Register d, Register a);
1238   inline void addze_( Register d, Register a);
1239   inline void subfze( Register d, Register a);
1240   inline void subfze_(Register d, Register a);
1241   inline void neg(    Register d, Register a);
1242   inline void neg_(   Register d, Register a);
1243   inline void mulli(  Register d, Register a, int si16);
1244   inline void mulld(  Register d, Register a, Register b);
1245   inline void mulld_( Register d, Register a, Register b);
1246   inline void mullw(  Register d, Register a, Register b);
1247   inline void mullw_( Register d, Register a, Register b);
1248   inline void mulhw(  Register d, Register a, Register b);
1249   inline void mulhw_( Register d, Register a, Register b);
1250   inline void mulhwu( Register d, Register a, Register b);
1251   inline void mulhwu_(Register d, Register a, Register b);
1252   inline void mulhd(  Register d, Register a, Register b);
1253   inline void mulhd_( Register d, Register a, Register b);
1254   inline void mulhdu( Register d, Register a, Register b);
1255   inline void mulhdu_(Register d, Register a, Register b);
1256   inline void divd(   Register d, Register a, Register b);
1257   inline void divd_(  Register d, Register a, Register b);
1258   inline void divw(   Register d, Register a, Register b);
1259   inline void divw_(  Register d, Register a, Register b);
1260 
1261   // Fixed-Point Arithmetic Instructions with Overflow detection
1262   inline void addo(    Register d, Register a, Register b);
1263   inline void addo_(   Register d, Register a, Register b);
1264   inline void subfo(   Register d, Register a, Register b);
1265   inline void subfo_(  Register d, Register a, Register b);
1266   inline void addco(   Register d, Register a, Register b);
1267   inline void addco_(  Register d, Register a, Register b);
1268   inline void subfco(  Register d, Register a, Register b);
1269   inline void subfco_( Register d, Register a, Register b);
1270   inline void addeo(   Register d, Register a, Register b);
1271   inline void addeo_(  Register d, Register a, Register b);
1272   inline void subfeo(  Register d, Register a, Register b);
1273   inline void subfeo_( Register d, Register a, Register b);
1274   inline void addmeo(  Register d, Register a);
1275   inline void addmeo_( Register d, Register a);
1276   inline void subfmeo( Register d, Register a);
1277   inline void subfmeo_(Register d, Register a);
1278   inline void addzeo(  Register d, Register a);
1279   inline void addzeo_( Register d, Register a);
1280   inline void subfzeo( Register d, Register a);
1281   inline void subfzeo_(Register d, Register a);
1282   inline void nego(    Register d, Register a);
1283   inline void nego_(   Register d, Register a);
1284   inline void mulldo(  Register d, Register a, Register b);
1285   inline void mulldo_( Register d, Register a, Register b);
1286   inline void mullwo(  Register d, Register a, Register b);
1287   inline void mullwo_( Register d, Register a, Register b);
1288   inline void divdo(   Register d, Register a, Register b);
1289   inline void divdo_(  Register d, Register a, Register b);
1290   inline void divwo(   Register d, Register a, Register b);
1291   inline void divwo_(  Register d, Register a, Register b);
1292 
1293   // extended mnemonics
1294   inline void li(   Register d, int si16);
1295   inline void lis(  Register d, int si16);
1296   inline void addir(Register d, int si16, Register a);
1297   inline void subi( Register d, Register a, int si16);
1298 
1299   static bool is_addi(int x) {
1300      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1301   }
1302   static bool is_addis(int x) {
1303      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1304   }
1305   static bool is_bxx(int x) {
1306      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1307   }
1308   static bool is_b(int x) {
1309      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1310   }
1311   static bool is_bl(int x) {
1312      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1313   }
1314   static bool is_bcxx(int x) {
1315      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1316   }
1317   static bool is_bxx_or_bcxx(int x) {
1318      return is_bxx(x) || is_bcxx(x);
1319   }
1320   static bool is_bctrl(int x) {
1321      return x == 0x4e800421;
1322   }
1323   static bool is_bctr(int x) {
1324      return x == 0x4e800420;
1325   }
1326   static bool is_bclr(int x) {
1327      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1328   }
1329   static bool is_li(int x) {
1330      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1331   }
1332   static bool is_lis(int x) {
1333      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1334   }
1335   static bool is_mtctr(int x) {
1336      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1337   }
1338   static bool is_ld(int x) {
1339      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1340   }
1341   static bool is_std(int x) {
1342      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1343   }
1344   static bool is_stdu(int x) {
1345      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1346   }
1347   static bool is_stdx(int x) {
1348      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1349   }
1350   static bool is_stdux(int x) {
1351      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1352   }
1353   static bool is_stwx(int x) {
1354      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1355   }
1356   static bool is_stwux(int x) {
1357      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1358   }
1359   static bool is_stw(int x) {
1360      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1361   }
1362   static bool is_stwu(int x) {
1363      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1364   }
1365   static bool is_ori(int x) {
1366      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1367   };
1368   static bool is_oris(int x) {
1369      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1370   };
1371   static bool is_rldicr(int x) {
1372      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1373   };
1374   static bool is_nop(int x) {
1375     return x == 0x60000000;
1376   }
1377   // endgroup opcode for Power6
1378   static bool is_endgroup(int x) {
1379     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1380   }
1381 
1382 
1383  private:
1384   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1385   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1386   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1387   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1388   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1389 
1390  public:
1391   // extended mnemonics of Compare Instructions
1392   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1393   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1394   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1395   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1396   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1397   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1398   inline void cmplw( ConditionRegister crx, Register a, Register b);
1399   inline void cmpld( ConditionRegister crx, Register a, Register b);
1400 
1401   inline void isel(   Register d, Register a, Register b, int bc);
1402   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1403   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1404   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1405   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1406 
1407   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1408          void andi(   Register a, Register s, long ui16);   // optimized version
1409   inline void andi_(  Register a, Register s, int ui16);
1410   inline void andis_( Register a, Register s, int ui16);
1411   inline void ori(    Register a, Register s, int ui16);
1412   inline void oris(   Register a, Register s, int ui16);
1413   inline void xori(   Register a, Register s, int ui16);
1414   inline void xoris(  Register a, Register s, int ui16);
1415   inline void andr(   Register a, Register s, Register b);  // suffixed by 'r' as 'and' is C++ keyword
1416   inline void and_(   Register a, Register s, Register b);
1417   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1418   // SMT-priority change instruction (see SMT instructions below).
1419   inline void or_unchecked(Register a, Register s, Register b);
1420   inline void orr(    Register a, Register s, Register b);  // suffixed by 'r' as 'or' is C++ keyword
1421   inline void or_(    Register a, Register s, Register b);
1422   inline void xorr(   Register a, Register s, Register b);  // suffixed by 'r' as 'xor' is C++ keyword
1423   inline void xor_(   Register a, Register s, Register b);
1424   inline void nand(   Register a, Register s, Register b);
1425   inline void nand_(  Register a, Register s, Register b);
1426   inline void nor(    Register a, Register s, Register b);
1427   inline void nor_(   Register a, Register s, Register b);
1428   inline void andc(   Register a, Register s, Register b);
1429   inline void andc_(  Register a, Register s, Register b);
1430   inline void orc(    Register a, Register s, Register b);
1431   inline void orc_(   Register a, Register s, Register b);
1432   inline void extsb(  Register a, Register s);
1433   inline void extsb_( Register a, Register s);
1434   inline void extsh(  Register a, Register s);
1435   inline void extsh_( Register a, Register s);
1436   inline void extsw(  Register a, Register s);
1437   inline void extsw_( Register a, Register s);
1438 
1439   // extended mnemonics
1440   inline void nop();
1441   // NOP for FP and BR units (different versions to allow them to be in one group)
1442   inline void fpnop0();
1443   inline void fpnop1();
1444   inline void brnop0();
1445   inline void brnop1();
1446   inline void brnop2();
1447 
1448   inline void mr(      Register d, Register s);
1449   inline void ori_opt( Register d, int ui16);
1450   inline void oris_opt(Register d, int ui16);
1451 
1452   // endgroup opcode for Power6
1453   inline void endgroup();
1454 
1455   // count instructions
1456   inline void cntlzw(  Register a, Register s);
1457   inline void cntlzw_( Register a, Register s);
1458   inline void cntlzd(  Register a, Register s);
1459   inline void cntlzd_( Register a, Register s);
1460 
1461   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1462   inline void sld(     Register a, Register s, Register b);
1463   inline void sld_(    Register a, Register s, Register b);
1464   inline void slw(     Register a, Register s, Register b);
1465   inline void slw_(    Register a, Register s, Register b);
1466   inline void srd(     Register a, Register s, Register b);
1467   inline void srd_(    Register a, Register s, Register b);
1468   inline void srw(     Register a, Register s, Register b);
1469   inline void srw_(    Register a, Register s, Register b);
1470   inline void srad(    Register a, Register s, Register b);
1471   inline void srad_(   Register a, Register s, Register b);
1472   inline void sraw(    Register a, Register s, Register b);
1473   inline void sraw_(   Register a, Register s, Register b);
1474   inline void sradi(   Register a, Register s, int sh6);
1475   inline void sradi_(  Register a, Register s, int sh6);
1476   inline void srawi(   Register a, Register s, int sh5);
1477   inline void srawi_(  Register a, Register s, int sh5);
1478 
1479   // extended mnemonics for Shift Instructions
1480   inline void sldi(    Register a, Register s, int sh6);
1481   inline void sldi_(   Register a, Register s, int sh6);
1482   inline void slwi(    Register a, Register s, int sh5);
1483   inline void slwi_(   Register a, Register s, int sh5);
1484   inline void srdi(    Register a, Register s, int sh6);
1485   inline void srdi_(   Register a, Register s, int sh6);
1486   inline void srwi(    Register a, Register s, int sh5);
1487   inline void srwi_(   Register a, Register s, int sh5);
1488 
1489   inline void clrrdi(  Register a, Register s, int ui6);
1490   inline void clrrdi_( Register a, Register s, int ui6);
1491   inline void clrldi(  Register a, Register s, int ui6);
1492   inline void clrldi_( Register a, Register s, int ui6);
1493   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1494   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1495   inline void extrdi(  Register a, Register s, int n, int b);
1496   // testbit with condition register
1497   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1498 
1499   // rotate instructions
1500   inline void rotldi(  Register a, Register s, int n);
1501   inline void rotrdi(  Register a, Register s, int n);
1502   inline void rotlwi(  Register a, Register s, int n);
1503   inline void rotrwi(  Register a, Register s, int n);
1504 
1505   // Rotate Instructions
1506   inline void rldic(   Register a, Register s, int sh6, int mb6);
1507   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1508   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1509   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1510   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1511   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1512   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1513   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1514   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1515   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1516   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1517   inline void insrdi(  Register a, Register s, int n,   int b);
1518   inline void insrwi(  Register a, Register s, int n,   int b);
1519 
1520   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1521   // 4 bytes
1522   inline void lwzx( Register d, Register s1, Register s2);
1523   inline void lwz(  Register d, int si16,    Register s1);
1524   inline void lwzu( Register d, int si16,    Register s1);
1525 
1526   // 4 bytes
1527   inline void lwax( Register d, Register s1, Register s2);
1528   inline void lwa(  Register d, int si16,    Register s1);
1529 
1530   // 4 bytes reversed
1531   inline void lwbrx( Register d, Register s1, Register s2);
1532 
1533   // 2 bytes
1534   inline void lhzx( Register d, Register s1, Register s2);
1535   inline void lhz(  Register d, int si16,    Register s1);
1536   inline void lhzu( Register d, int si16,    Register s1);
1537 
1538   // 2 bytes reversed
1539   inline void lhbrx( Register d, Register s1, Register s2);
1540 
1541   // 2 bytes
1542   inline void lhax( Register d, Register s1, Register s2);
1543   inline void lha(  Register d, int si16,    Register s1);
1544   inline void lhau( Register d, int si16,    Register s1);
1545 
1546   // 1 byte
1547   inline void lbzx( Register d, Register s1, Register s2);
1548   inline void lbz(  Register d, int si16,    Register s1);
1549   inline void lbzu( Register d, int si16,    Register s1);
1550 
1551   // 8 bytes
1552   inline void ldx(  Register d, Register s1, Register s2);
1553   inline void ld(   Register d, int si16,    Register s1);
1554   inline void ldu(  Register d, int si16,    Register s1);
1555 
1556   // For convenience. Load pointer into d from b+s1.
1557   inline void ld_ptr(Register d, int b, Register s1);
1558   DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)
1559 
1560   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1561   inline void stwx( Register d, Register s1, Register s2);
1562   inline void stw(  Register d, int si16,    Register s1);
1563   inline void stwu( Register d, int si16,    Register s1);
1564 
1565   inline void sthx( Register d, Register s1, Register s2);
1566   inline void sth(  Register d, int si16,    Register s1);
1567   inline void sthu( Register d, int si16,    Register s1);
1568 
1569   inline void stbx( Register d, Register s1, Register s2);
1570   inline void stb(  Register d, int si16,    Register s1);
1571   inline void stbu( Register d, int si16,    Register s1);
1572 
1573   inline void stdx( Register d, Register s1, Register s2);
1574   inline void std(  Register d, int si16,    Register s1);
1575   inline void stdu( Register d, int si16,    Register s1);
1576   inline void stdux(Register s, Register a,  Register b);
1577 
1578   inline void st_ptr(Register d, int si16,    Register s1);
1579   DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)
1580 
1581   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1582   inline void mtlr( Register s1);
1583   inline void mflr( Register d);
1584   inline void mtctr(Register s1);
1585   inline void mfctr(Register d);
1586   inline void mtcrf(int fxm, Register s);
1587   inline void mfcr( Register d);
1588   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1589   inline void mtcr( Register s);
1590 
1591   // Special purpose registers
1592   // Exception Register
1593   inline void mtxer(Register s1);
1594   inline void mfxer(Register d);
1595   // Vector Register Save Register
1596   inline void mtvrsave(Register s1);
1597   inline void mfvrsave(Register d);
1598   // Timebase
1599   inline void mftb(Register d);
1600   // Introduced with Power 8:
1601   // Data Stream Control Register
1602   inline void mtdscr(Register s1);
1603   inline void mfdscr(Register d );
1604   // Transactional Memory Registers
1605   inline void mftfhar(Register d);
1606   inline void mftfiar(Register d);
1607   inline void mftexasr(Register d);
1608   inline void mftexasru(Register d);
1609 
1610   // TEXASR bit description
1611   enum transaction_failure_reason {
1612     // Upper half (TEXASRU):
1613     tm_failure_persistent =  7, // The failure is likely to recur on each execution.
1614     tm_disallowed         =  8, // The instruction is not permitted.
1615     tm_nesting_of         =  9, // The maximum transaction level was exceeded.
1616     tm_footprint_of       = 10, // The tracking limit for transactional storage accesses was exceeded.
1617     tm_self_induced_cf    = 11, // A self-induced conflict occurred in Suspended state.
1618     tm_non_trans_cf       = 12, // A conflict occurred with a non-transactional access by another processor.
1619     tm_trans_cf           = 13, // A conflict occurred with another transaction.
1620     tm_translation_cf     = 14, // A conflict occurred with a TLB invalidation.
1621     tm_inst_fetch_cf      = 16, // An instruction fetch was performed from a block that was previously written transactionally.
1622     tm_tabort             = 31, // Termination was caused by the execution of an abort instruction.
1623     // Lower half:
1624     tm_suspended          = 32, // Failure was recorded in Suspended state.
1625     tm_failure_summary    = 36, // Failure has been detected and recorded.
1626     tm_tfiar_exact        = 37, // Value in the TFIAR is exact.
1627     tm_rot                = 38, // Rollback-only transaction.
1628   };
1629 
1630   // PPC 1, section 2.4.1 Branch Instructions
1631   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1632   inline void b(  Label&amp; L);
1633   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1634   inline void bl( Label&amp; L);
1635   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1636   inline void bc( int boint, int biint, Label&amp; L);
1637   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1638   inline void bcl(int boint, int biint, Label&amp; L);
1639 
1640   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1641   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1642   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1643                          relocInfo::relocType rt = relocInfo::none);
1644   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1645                          relocInfo::relocType rt = relocInfo::none);
1646 
1647   // helper function for b, bcxx
1648   inline bool is_within_range_of_b(address a, address pc);
1649   inline bool is_within_range_of_bcxx(address a, address pc);
1650 
1651   // get the destination of a bxx branch (b, bl, ba, bla)
1652   static inline address  bxx_destination(address baddr);
1653   static inline address  bxx_destination(int instr, address pc);
1654   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1655 
1656   // extended mnemonics for branch instructions
1657   inline void blt(ConditionRegister crx, Label&amp; L);
1658   inline void bgt(ConditionRegister crx, Label&amp; L);
1659   inline void beq(ConditionRegister crx, Label&amp; L);
1660   inline void bso(ConditionRegister crx, Label&amp; L);
1661   inline void bge(ConditionRegister crx, Label&amp; L);
1662   inline void ble(ConditionRegister crx, Label&amp; L);
1663   inline void bne(ConditionRegister crx, Label&amp; L);
1664   inline void bns(ConditionRegister crx, Label&amp; L);
1665 
1666   // Branch instructions with static prediction hints.
1667   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1668   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1669   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1670   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1671   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1672   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1673   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1674   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1675   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1676   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1677   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1678   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1679   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1680   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1681   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1682   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1683 
1684   // for use in conjunction with testbitdi:
1685   inline void btrue( ConditionRegister crx, Label&amp; L);
1686   inline void bfalse(ConditionRegister crx, Label&amp; L);
1687 
1688   inline void bltl(ConditionRegister crx, Label&amp; L);
1689   inline void bgtl(ConditionRegister crx, Label&amp; L);
1690   inline void beql(ConditionRegister crx, Label&amp; L);
1691   inline void bsol(ConditionRegister crx, Label&amp; L);
1692   inline void bgel(ConditionRegister crx, Label&amp; L);
1693   inline void blel(ConditionRegister crx, Label&amp; L);
1694   inline void bnel(ConditionRegister crx, Label&amp; L);
1695   inline void bnsl(ConditionRegister crx, Label&amp; L);
1696 
1697   // extended mnemonics for Branch Instructions via LR
1698   // We use `blr' for returns.
1699   inline void blr(relocInfo::relocType rt = relocInfo::none);
1700 
1701   // extended mnemonics for Branch Instructions with CTR
1702   // bdnz means `decrement CTR and jump to L if CTR is not zero'
1703   inline void bdnz(Label&amp; L);
1704   // Decrement and branch if result is zero.
1705   inline void bdz(Label&amp; L);
1706   // we use `bctr[l]' for jumps/calls in function descriptor glue
1707   // code, e.g. calls to runtime functions
1708   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1709   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1710   // conditional jumps/branches via CTR
1711   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1712   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1713   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1714   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1715 
1716   // condition register logic instructions
1717   // NOTE: There's a preferred form: d and s2 should point into the same condition register.
1718   inline void crand( int d, int s1, int s2);
1719   inline void crnand(int d, int s1, int s2);
1720   inline void cror(  int d, int s1, int s2);
1721   inline void crxor( int d, int s1, int s2);
1722   inline void crnor( int d, int s1, int s2);
1723   inline void creqv( int d, int s1, int s2);
1724   inline void crandc(int d, int s1, int s2);
1725   inline void crorc( int d, int s1, int s2);
1726 
1727   // More convenient version.
1728   int condition_register_bit(ConditionRegister cr, Condition c) {
1729     return 4 * (int)(intptr_t)cr + c;
1730   }
1731   void crand( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1732   void crnand(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1733   void cror(  ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1734   void crxor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1735   void crnor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1736   void creqv( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1737   void crandc(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1738   void crorc( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1739 
1740   // icache and dcache related instructions
1741   inline void icbi(  Register s1, Register s2);
1742   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1743   inline void dcbz(  Register s1, Register s2);
1744   inline void dcbst( Register s1, Register s2);
1745   inline void dcbf(  Register s1, Register s2);
1746 
1747   enum ct_cache_specification {
1748     ct_primary_cache   = 0,
1749     ct_secondary_cache = 2
1750   };
1751   // dcache read hint
1752   inline void dcbt(    Register s1, Register s2);
1753   inline void dcbtct(  Register s1, Register s2, int ct);
1754   inline void dcbtds(  Register s1, Register s2, int ds);
1755   // dcache write hint
1756   inline void dcbtst(  Register s1, Register s2);
1757   inline void dcbtstct(Register s1, Register s2, int ct);
1758 
1759   //  machine barrier instructions:
1760   //
1761   //  - sync    two-way memory barrier, aka fence
1762   //  - lwsync  orders  Store|Store,
1763   //                     Load|Store,
1764   //                     Load|Load,
1765   //            but not Store|Load
1766   //  - eieio   orders memory accesses for device memory (only)
1767   //  - isync   invalidates speculatively executed instructions
1768   //            From the Power ISA 2.06 documentation:
1769   //             "[...] an isync instruction prevents the execution of
1770   //            instructions following the isync until instructions
1771   //            preceding the isync have completed, [...]"
1772   //            From IBM's AIX assembler reference:
1773   //             "The isync [...] instructions causes the processor to
1774   //            refetch any instructions that might have been fetched
1775   //            prior to the isync instruction. The instruction isync
1776   //            causes the processor to wait for all previous instructions
1777   //            to complete. Then any instructions already fetched are
1778   //            discarded and instruction processing continues in the
1779   //            environment established by the previous instructions."
1780   //
1781   //  semantic barrier instructions:
1782   //  (as defined in orderAccess.hpp)
1783   //
1784   //  - release  orders Store|Store,       (maps to lwsync)
1785   //                     Load|Store
1786   //  - acquire  orders  Load|Store,       (maps to lwsync)
1787   //                     Load|Load
1788   //  - fence    orders Store|Store,       (maps to sync)
1789   //                     Load|Store,
1790   //                     Load|Load,
1791   //                    Store|Load
1792   //
1793  private:
1794   inline void sync(int l);
1795  public:
1796   inline void sync();
1797   inline void lwsync();
1798   inline void ptesync();
1799   inline void eieio();
1800   inline void isync();
1801   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1802 
1803   // Wait instructions for polling. Attention: May result in SIGILL.
1804   inline void wait();
1805   inline void waitrsv(); // &gt;=Power7
1806 
1807   // atomics
1808   inline void lbarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1809   inline void lharx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1810   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1811   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1812   inline void lqarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1813   inline bool lxarx_hint_exclusive_access();
1814   inline void lbarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1815   inline void lharx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1816   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1817   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1818   inline void lqarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1819   inline void stbcx_( Register s, Register a, Register b);
1820   inline void sthcx_( Register s, Register a, Register b);
1821   inline void stwcx_( Register s, Register a, Register b);
1822   inline void stdcx_( Register s, Register a, Register b);
1823   inline void stqcx_( Register s, Register a, Register b);
1824 
1825   // Instructions for adjusting thread priority for simultaneous
1826   // multithreading (SMT) on Power5.
1827  private:
1828   inline void smt_prio_very_low();
1829   inline void smt_prio_medium_high();
1830   inline void smt_prio_high();
1831 
1832  public:
1833   inline void smt_prio_low();
1834   inline void smt_prio_medium_low();
1835   inline void smt_prio_medium();
1836   // &gt;= Power7
1837   inline void smt_yield();
1838   inline void smt_mdoio();
1839   inline void smt_mdoom();
1840   // &gt;= Power8
1841   inline void smt_miso();
1842 
1843   // trap instructions
1844   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can't occur)
1845   // NOT FOR DIRECT USE!!
1846  protected:
1847   inline void tdi_unchecked(int tobits, Register a, int si16);
1848   inline void twi_unchecked(int tobits, Register a, int si16);
1849   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1850   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1851   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1852   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1853 
1854   static bool is_tdi(int x, int tobits, int ra, int si16) {
1855      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1856          &amp;&amp; (tobits == inv_to_field(x))
1857          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1858          &amp;&amp; (si16 == inv_si_field(x));
1859   }
1860 
1861   static bool is_twi(int x, int tobits, int ra, int si16) {
1862      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1863          &amp;&amp; (tobits == inv_to_field(x))
1864          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1865          &amp;&amp; (si16 == inv_si_field(x));
1866   }
1867 
1868   static bool is_twi(int x, int tobits, int ra) {
1869      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1870          &amp;&amp; (tobits == inv_to_field(x))
1871          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1872   }
1873 
1874   static bool is_td(int x, int tobits, int ra, int rb) {
1875      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1876          &amp;&amp; (tobits == inv_to_field(x))
1877          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1878          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1879   }
1880 
1881   static bool is_tw(int x, int tobits, int ra, int rb) {
1882      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1883          &amp;&amp; (tobits == inv_to_field(x))
1884          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1885          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1886   }
1887 
1888  public:
1889   // PPC floating point instructions
1890   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1891   inline void lfs(  FloatRegister d, int si16,   Register a);
1892   inline void lfsu( FloatRegister d, int si16,   Register a);
1893   inline void lfsx( FloatRegister d, Register a, Register b);
1894   inline void lfd(  FloatRegister d, int si16,   Register a);
1895   inline void lfdu( FloatRegister d, int si16,   Register a);
1896   inline void lfdx( FloatRegister d, Register a, Register b);
1897 
1898   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1899   inline void stfs(  FloatRegister s, int si16,   Register a);
1900   inline void stfsu( FloatRegister s, int si16,   Register a);
1901   inline void stfsx( FloatRegister s, Register a, Register b);
1902   inline void stfd(  FloatRegister s, int si16,   Register a);
1903   inline void stfdu( FloatRegister s, int si16,   Register a);
1904   inline void stfdx( FloatRegister s, Register a, Register b);
1905 
1906   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1907   inline void fmr(  FloatRegister d, FloatRegister b);
1908   inline void fmr_( FloatRegister d, FloatRegister b);
1909 
1910   //  inline void mffgpr( FloatRegister d, Register b);
1911   //  inline void mftgpr( Register d, FloatRegister b);
1912   inline void cmpb(   Register a, Register s, Register b);
1913   inline void popcntb(Register a, Register s);
1914   inline void popcntw(Register a, Register s);
1915   inline void popcntd(Register a, Register s);
1916 
1917   inline void fneg(  FloatRegister d, FloatRegister b);
1918   inline void fneg_( FloatRegister d, FloatRegister b);
1919   inline void fabs(  FloatRegister d, FloatRegister b);
1920   inline void fabs_( FloatRegister d, FloatRegister b);
1921   inline void fnabs( FloatRegister d, FloatRegister b);
1922   inline void fnabs_(FloatRegister d, FloatRegister b);
1923 
1924   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
1925   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
1926   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
1927   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
1928   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
1929   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
1930   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
1931   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
1932   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
1933   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
1934   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
1935   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
1936   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
1937   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
1938   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
1939   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
1940   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
1941 
1942   // Fused multiply-accumulate instructions.
1943   // WARNING: Use only when rounding between the 2 parts is not desired.
1944   // Some floating point tck tests will fail if used incorrectly.
1945   inline void fmadd(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1946   inline void fmadd_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1947   inline void fmadds(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1948   inline void fmadds_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1949   inline void fmsub(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1950   inline void fmsub_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1951   inline void fmsubs(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1952   inline void fmsubs_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1953   inline void fnmadd(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1954   inline void fnmadd_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1955   inline void fnmadds( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1956   inline void fnmadds_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1957   inline void fnmsub(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1958   inline void fnmsub_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1959   inline void fnmsubs( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1960   inline void fnmsubs_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
1961 
1962   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
1963   inline void frsp(  FloatRegister d, FloatRegister b);
1964   inline void fctid( FloatRegister d, FloatRegister b);
1965   inline void fctidz(FloatRegister d, FloatRegister b);
1966   inline void fctiw( FloatRegister d, FloatRegister b);
1967   inline void fctiwz(FloatRegister d, FloatRegister b);
1968   inline void fcfid( FloatRegister d, FloatRegister b);
1969   inline void fcfids(FloatRegister d, FloatRegister b);
1970 
1971   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
1972   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
1973 
1974   inline void fsqrt( FloatRegister d, FloatRegister b);
1975   inline void fsqrts(FloatRegister d, FloatRegister b);
1976 
1977   // Vector instructions for &gt;= Power6.
1978   inline void lvebx(    VectorRegister d, Register s1, Register s2);
1979   inline void lvehx(    VectorRegister d, Register s1, Register s2);
1980   inline void lvewx(    VectorRegister d, Register s1, Register s2);
1981   inline void lvx(      VectorRegister d, Register s1, Register s2);
1982   inline void lvxl(     VectorRegister d, Register s1, Register s2);
1983   inline void stvebx(   VectorRegister d, Register s1, Register s2);
1984   inline void stvehx(   VectorRegister d, Register s1, Register s2);
1985   inline void stvewx(   VectorRegister d, Register s1, Register s2);
1986   inline void stvx(     VectorRegister d, Register s1, Register s2);
1987   inline void stvxl(    VectorRegister d, Register s1, Register s2);
1988   inline void lvsl(     VectorRegister d, Register s1, Register s2);
1989   inline void lvsr(     VectorRegister d, Register s1, Register s2);
1990   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
1991   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
1992   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
1993   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
1994   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
1995   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
1996   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
1997   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
1998   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
1999   inline void vupkhpx(  VectorRegister d, VectorRegister b);
2000   inline void vupkhsb(  VectorRegister d, VectorRegister b);
2001   inline void vupkhsh(  VectorRegister d, VectorRegister b);
2002   inline void vupklpx(  VectorRegister d, VectorRegister b);
2003   inline void vupklsb(  VectorRegister d, VectorRegister b);
2004   inline void vupklsh(  VectorRegister d, VectorRegister b);
2005   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
2006   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
2007   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
2008   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
2009   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
2010   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
2011   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
2012   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
2013   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
2014   inline void vspltisb( VectorRegister d, int si5);
2015   inline void vspltish( VectorRegister d, int si5);
2016   inline void vspltisw( VectorRegister d, int si5);
2017   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2018   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2019   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
2020   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int si4);
2021   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
2022   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
2023   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
2024   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2025   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2026   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2027   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2028   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
2029   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2030   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2031   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
2032   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
2033   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2034   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2035   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2036   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2037   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2038   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
2039   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2040   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2041   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
2042   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
2043   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2044   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
2045   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
2046   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
2047   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
2048   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
2049   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
2050   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
2051   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
2052   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2053   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
2054   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2055   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2056   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2057   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2058   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2059   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2060   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2061   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2062   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
2063   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
2064   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
2065   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
2066   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2067   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2068   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2069   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
2070   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
2071   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
2072   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2073   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2074   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2075   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
2076   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2077   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2078   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2079   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2080   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2081   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
2082   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2083   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2084   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
2085   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
2086   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
2087   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
2088   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
2089   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
2090   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
2091   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
2092   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
2093   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
2094   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
2095   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
2096   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
2097   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
2098   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
2099   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
2100   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
2101   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
2102   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
2103   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
2104   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
2105   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
2106   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
2107   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
2108   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
2109   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
2110   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
2111   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
2112   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
2113   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
2114   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
2115   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
2116   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
2117   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
2118   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
2119   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
2120   // Vector Floating-Point not implemented yet
2121   inline void mtvscr(   VectorRegister b);
2122   inline void mfvscr(   VectorRegister d);
2123 
2124   // Vector-Scalar (VSX) instructions.
2125   inline void lxvd2x(   VectorSRegister d, Register a);
2126   inline void lxvd2x(   VectorSRegister d, Register a, Register b);
2127   inline void stxvd2x(  VectorSRegister d, Register a);
2128   inline void stxvd2x(  VectorSRegister d, Register a, Register b);
2129   inline void mtvrd(    VectorRegister  d, Register a);
2130   inline void mfvrd(    Register        a, VectorRegister d);
2131 
2132   // AES (introduced with Power 8)
2133   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
2134   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
2135   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
2136   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
2137   inline void vsbox(       VectorRegister d, VectorRegister a);
2138 
2139   // SHA (introduced with Power 8)
2140   // Not yet implemented.
2141 
2142   // Vector Binary Polynomial Multiplication (introduced with Power 8)
2143   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
2144   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
2145   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
2146   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
2147 
2148   // Vector Permute and Xor (introduced with Power 8)
2149   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2150 
2151   // Transactional Memory instructions (introduced with Power 8)
2152   inline void tbegin_();    // R=0
2153   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
2154   inline void tend_();    // A=0
2155   inline void tendall_(); // A=1
2156   inline void tabort_();
2157   inline void tabort_(Register a);
2158   inline void tabortwc_(int t, Register a, Register b);
2159   inline void tabortwci_(int t, Register a, int si);
2160   inline void tabortdc_(int t, Register a, Register b);
2161   inline void tabortdci_(int t, Register a, int si);
2162   inline void tsuspend_(); // tsr with L=0
2163   inline void tresume_();  // tsr with L=1
2164   inline void tcheck(int f);
2165 
2166   static bool is_tbegin(int x) {
2167     return TBEGIN_OPCODE == (x &amp; (0x3f &lt;&lt; OPCODE_SHIFT | 0x3ff &lt;&lt; 1));
2168   }
2169 
2170   // The following encoders use r0 as second operand. These instructions
2171   // read r0 as '0'.
2172   inline void lwzx( Register d, Register s2);
2173   inline void lwz(  Register d, int si16);
2174   inline void lwax( Register d, Register s2);
2175   inline void lwa(  Register d, int si16);
2176   inline void lwbrx(Register d, Register s2);
2177   inline void lhzx( Register d, Register s2);
2178   inline void lhz(  Register d, int si16);
2179   inline void lhax( Register d, Register s2);
2180   inline void lha(  Register d, int si16);
2181   inline void lhbrx(Register d, Register s2);
2182   inline void lbzx( Register d, Register s2);
2183   inline void lbz(  Register d, int si16);
2184   inline void ldx(  Register d, Register s2);
2185   inline void ld(   Register d, int si16);
2186   inline void stwx( Register d, Register s2);
2187   inline void stw(  Register d, int si16);
2188   inline void sthx( Register d, Register s2);
2189   inline void sth(  Register d, int si16);
2190   inline void stbx( Register d, Register s2);
2191   inline void stb(  Register d, int si16);
2192   inline void stdx( Register d, Register s2);
2193   inline void std(  Register d, int si16);
2194 
2195   // PPC 2, section 3.2.1 Instruction Cache Instructions
2196   inline void icbi(    Register s2);
2197   // PPC 2, section 3.2.2 Data Cache Instructions
2198   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2199   inline void dcbz(    Register s2);
2200   inline void dcbst(   Register s2);
2201   inline void dcbf(    Register s2);
2202   // dcache read hint
2203   inline void dcbt(    Register s2);
2204   inline void dcbtct(  Register s2, int ct);
2205   inline void dcbtds(  Register s2, int ds);
2206   // dcache write hint
2207   inline void dcbtst(  Register s2);
2208   inline void dcbtstct(Register s2, int ct);
2209 
2210   // Atomics: use ra0mem to disallow R0 as base.
2211   inline void lbarx_unchecked(Register d, Register b, int eh1);
2212   inline void lharx_unchecked(Register d, Register b, int eh1);
2213   inline void lwarx_unchecked(Register d, Register b, int eh1);
2214   inline void ldarx_unchecked(Register d, Register b, int eh1);
2215   inline void lqarx_unchecked(Register d, Register b, int eh1);
2216   inline void lbarx( Register d, Register b, bool hint_exclusive_access);
2217   inline void lharx( Register d, Register b, bool hint_exclusive_access);
2218   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2219   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2220   inline void lqarx( Register d, Register b, bool hint_exclusive_access);
2221   inline void stbcx_(Register s, Register b);
2222   inline void sthcx_(Register s, Register b);
2223   inline void stwcx_(Register s, Register b);
2224   inline void stdcx_(Register s, Register b);
2225   inline void stqcx_(Register s, Register b);
2226   inline void lfs(   FloatRegister d, int si16);
2227   inline void lfsx(  FloatRegister d, Register b);
2228   inline void lfd(   FloatRegister d, int si16);
2229   inline void lfdx(  FloatRegister d, Register b);
2230   inline void stfs(  FloatRegister s, int si16);
2231   inline void stfsx( FloatRegister s, Register b);
2232   inline void stfd(  FloatRegister s, int si16);
2233   inline void stfdx( FloatRegister s, Register b);
2234   inline void lvebx( VectorRegister d, Register s2);
2235   inline void lvehx( VectorRegister d, Register s2);
2236   inline void lvewx( VectorRegister d, Register s2);
2237   inline void lvx(   VectorRegister d, Register s2);
2238   inline void lvxl(  VectorRegister d, Register s2);
2239   inline void stvebx(VectorRegister d, Register s2);
2240   inline void stvehx(VectorRegister d, Register s2);
2241   inline void stvewx(VectorRegister d, Register s2);
2242   inline void stvx(  VectorRegister d, Register s2);
2243   inline void stvxl( VectorRegister d, Register s2);
2244   inline void lvsl(  VectorRegister d, Register s2);
2245   inline void lvsr(  VectorRegister d, Register s2);
2246 
2247   // RegisterOrConstant versions.
2248   // These emitters choose between the versions using two registers and
2249   // those with register and immediate, depending on the content of roc.
2250   // If the constant is not encodable as immediate, instructions to
2251   // load the constant are emitted beforehand. Store instructions need a
2252   // tmp reg if the constant is not encodable as immediate.
2253   // Size unpredictable.
2254   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2255   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2256   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2257   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2258   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2259   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2260   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2261   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2262   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2263   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2264   void add( Register d, RegisterOrConstant roc, Register s1);
2265   void subf(Register d, RegisterOrConstant roc, Register s1);
2266   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2267   // Load pointer d from s1+roc.
2268   void ld_ptr(Register d, RegisterOrConstant roc, Register s1 = noreg) { ld(d, roc, s1); }
2269 
2270   // Emit several instructions to load a 64 bit constant. This issues a fixed
2271   // instruction pattern so that the constant can be patched later on.
2272   enum {
2273     load_const_size = 5 * BytesPerInstWord
2274   };
2275          void load_const(Register d, long a,            Register tmp = noreg);
2276   inline void load_const(Register d, void* a,           Register tmp = noreg);
2277   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2278   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2279   inline void load_const32(Register d, int i); // load signed int (patchable)
2280 
2281   // Load a 64 bit constant, optimized, not identifyable.
2282   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2283   // 16 bit immediate offset. This is useful if the offset can be encoded in
2284   // a succeeding instruction.
2285          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2286   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2287     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2288   }
2289 
2290   // If return_simm16_rest, the return value needs to get added afterwards.
2291          int add_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false);
2292   inline int add_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2293     return add_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2294   }
2295 
2296   // If return_simm16_rest, the return value needs to get added afterwards.
2297   inline int sub_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false) {
2298     return add_const_optimized(d, s, -x, tmp, return_simm16_rest);
2299   }
2300   inline int sub_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2301     return sub_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2302   }
2303 
2304   // Creation
2305   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2306 #ifdef CHECK_DELAY
2307     delay_state = no_delay;
2308 #endif
2309   }
2310 
2311   // Testing
2312 #ifndef PRODUCT
2313   void test_asm();
2314 #endif
2315 };
2316 
2317 
2318 #endif // CPU_PPC_VM_ASSEMBLER_PPC_HPP
</pre></body></html>

<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk10-hotspot-hg Sdiff src/cpu/ppc/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/cpu/ppc/vm/macroAssembler_ppc.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/vm_version_ppc.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/cpu/ppc/vm/stubGenerator_ppc.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13010">13010</a> : PPC: Implement MulAdd and SquareToLen intrinsics

This implementation is based on the algorithm implemented in java. It
yields a performance speedup of:
JDK8 - 23%
JDK9 - 5%
JDK10 - 5%</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
3288       const Register t0      = R2;
3289       const Register t1      = R7;
3290       const Register t2      = R8;
3291       const Register t3      = R9;
3292       const Register tc0     = R10;
3293       const Register tc1     = R11;
3294       const Register tc2     = R12;
3295 
3296       BLOCK_COMMENT("Stub body {");
3297       assert_different_registers(crc, data, dataLen, table);
3298 
3299       __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, tc0, tc1, tc2, table, invertCRC);
3300 
3301       BLOCK_COMMENT("return");
3302       __ mr_if_needed(R3_RET, crc);      // Updated crc is function result. No copying required (R3_ARG1 == R3_RET).
3303       __ blr();
3304 
3305       BLOCK_COMMENT("} Stub body");
3306   }
3307 





























































































































































































































































3308 
3309   /**
3310    * Arguments:
3311    *
3312    * Inputs:
3313    *   R3_ARG1    - int   crc
3314    *   R4_ARG2    - byte* buf
3315    *   R5_ARG3    - int   length (of buffer)
3316    *
3317    * scratch:
3318    *   R2, R6-R12
3319    *
3320    * Ouput:
3321    *   R3_RET     - int   crc result
3322    */
3323   // Compute CRC32 function.
3324   address generate_CRC32_updateBytes(const char* name) {
3325     __ align(CodeEntryAlignment);
3326     StubCodeMark mark(this, "StubRoutines", name);
3327     address start = __ function_entry();  // Remember stub start address (is rtn value).

</pre><hr></hr><pre>
3482     // support for verify_oop (must happen after universe_init)
3483     StubRoutines::_verify_oop_subroutine_entry             = generate_verify_oop();
3484 
3485     // arraycopy stubs used by compilers
3486     generate_arraycopy_stubs();
3487 
3488     // Safefetch stubs.
3489     generate_safefetch("SafeFetch32", sizeof(int),     &amp;StubRoutines::_safefetch32_entry,
3490                                                        &amp;StubRoutines::_safefetch32_fault_pc,
3491                                                        &amp;StubRoutines::_safefetch32_continuation_pc);
3492     generate_safefetch("SafeFetchN", sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,
3493                                                        &amp;StubRoutines::_safefetchN_fault_pc,
3494                                                        &amp;StubRoutines::_safefetchN_continuation_pc);
3495 
3496 #ifdef COMPILER2
3497     if (UseMultiplyToLenIntrinsic) {
3498       StubRoutines::_multiplyToLen = generate_multiplyToLen();
3499     }
3500 #endif
3501 






3502     if (UseMontgomeryMultiplyIntrinsic) {
3503       StubRoutines::_montgomeryMultiply
3504         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_multiply);
3505     }
3506     if (UseMontgomerySquareIntrinsic) {
3507       StubRoutines::_montgomerySquare
3508         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_square);
3509     }
3510 
3511     if (UseAESIntrinsics) {
3512       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3513       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3514     }
3515 
3516   }
3517 
3518  public:
3519   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3520     // replace the standard masm with a special one:
3521     _masm = new MacroAssembler(code);
</pre></td><td><pre>

</pre><hr></hr><pre>
3288       const Register t0      = R2;
3289       const Register t1      = R7;
3290       const Register t2      = R8;
3291       const Register t3      = R9;
3292       const Register tc0     = R10;
3293       const Register tc1     = R11;
3294       const Register tc2     = R12;
3295 
3296       BLOCK_COMMENT("Stub body {");
3297       assert_different_registers(crc, data, dataLen, table);
3298 
3299       __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, tc0, tc1, tc2, table, invertCRC);
3300 
3301       BLOCK_COMMENT("return");
3302       __ mr_if_needed(R3_RET, crc);      // Updated crc is function result. No copying required (R3_ARG1 == R3_RET).
3303       __ blr();
3304 
3305       BLOCK_COMMENT("} Stub body");
3306   }
3307 
<span class="new">3308   /**</span>
<span class="new">3309   *  Arguments:</span>
<span class="new">3310   *</span>
<span class="new">3311   *  Input:</span>
<span class="new">3312   *   R3_ARG1    - out address</span>
<span class="new">3313   *   R4_ARG2    - in address</span>
<span class="new">3314   *   R5_ARG3    - offset</span>
<span class="new">3315   *   R6_ARG4    - len</span>
<span class="new">3316   *   R7_ARG5    - k</span>
<span class="new">3317   *  Output:</span>
<span class="new">3318   *   R3_RET     - carry</span>
<span class="new">3319   */</span>
<span class="new">3320   address generate_mulAdd() {</span>
<span class="new">3321     __ align(CodeEntryAlignment);</span>
<span class="new">3322     StubCodeMark mark(this, "StubRoutines", "mulAdd");</span>
<span class="new">3323 </span>
<span class="new">3324     address start = __ function_entry();</span>
<span class="new">3325 </span>
<span class="new">3326     __ sldi   (R5_ARG3, R5_ARG3, 2);</span>
<span class="new">3327     __ clrldi (R7_ARG5, R7_ARG5, 32);</span>
<span class="new">3328 </span>
<span class="new">3329     __ muladd(R3_ARG1, R4_ARG2, R5_ARG3, R6_ARG4, R7_ARG5, R8, R9, R10);</span>
<span class="new">3330 </span>
<span class="new">3331     // Moves output carry to return register</span>
<span class="new">3332     __ mr(R3_RET, R10);</span>
<span class="new">3333 </span>
<span class="new">3334     __ blr();</span>
<span class="new">3335 </span>
<span class="new">3336     return start;</span>
<span class="new">3337   }</span>
<span class="new">3338 </span>
<span class="new">3339   /**</span>
<span class="new">3340   *  Arguments:</span>
<span class="new">3341   *</span>
<span class="new">3342   *  Input:</span>
<span class="new">3343   *   R3_ARG1    - in address</span>
<span class="new">3344   *   R4_ARG2    - in length</span>
<span class="new">3345   *   R5_ARG3    - out address</span>
<span class="new">3346   *   R6_ARG4    - out length</span>
<span class="new">3347   */</span>
<span class="new">3348   address generate_squareToLen() {</span>
<span class="new">3349     __ align(CodeEntryAlignment);</span>
<span class="new">3350     StubCodeMark mark(this, "StubRoutines", "squareToLen");</span>
<span class="new">3351 </span>
<span class="new">3352     address start = __ function_entry();</span>
<span class="new">3353 </span>
<span class="new">3354     // args</span>
<span class="new">3355     const Register in        = R3_ARG1;</span>
<span class="new">3356     const Register in_len    = R4_ARG2;</span>
<span class="new">3357     const Register out       = R5_ARG3;</span>
<span class="new">3358     const Register out_len   = R6_ARG4;</span>
<span class="new">3359 </span>
<span class="new">3360     // output</span>
<span class="new">3361     const Register ret       = R3_RET;</span>
<span class="new">3362 </span>
<span class="new">3363     // temporaries</span>
<span class="new">3364     const Register lplw_s    = R7;</span>
<span class="new">3365     const Register in_aux    = R8;</span>
<span class="new">3366     const Register out_aux   = R9;</span>
<span class="new">3367     const Register piece     = R10;</span>
<span class="new">3368     const Register product   = R14;</span>
<span class="new">3369     const Register product_s = R15;</span>
<span class="new">3370     const Register lplw      = R16;</span>
<span class="new">3371     const Register i_minus1  = R17;</span>
<span class="new">3372     const Register carry     = R18;</span>
<span class="new">3373     const Register offset    = R19;</span>
<span class="new">3374     const Register off_aux   = R20;</span>
<span class="new">3375     const Register t         = R21;</span>
<span class="new">3376     const Register mlen      = R22;</span>
<span class="new">3377     const Register len       = R23;</span>
<span class="new">3378     const Register a         = R24;</span>
<span class="new">3379     const Register b         = R25;</span>
<span class="new">3380     const Register i         = R26;</span>
<span class="new">3381     const Register c         = R27;</span>
<span class="new">3382     const Register cs        = R28;</span>
<span class="new">3383 </span>
<span class="new">3384     // Labels</span>
<span class="new">3385     Label SKIP_LSHIFT, SKIP_DIAGONAL_SUM, SKIP_ADDONE, SKIP_MULADD, SKIP_LOOP_SQUARE;</span>
<span class="new">3386     Label LOOP_LSHIFT, LOOP_DIAGONAL_SUM, LOOP_ADDONE, LOOP_MULADD, LOOP_SQUARE;</span>
<span class="new">3387 </span>
<span class="new">3388     // Save non-volatile regs (frameless).</span>
<span class="new">3389     int current_offs = -8;</span>
<span class="new">3390     __ std(R28, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3391     __ std(R27, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3392     __ std(R26, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3393     __ std(R25, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3394     __ std(R24, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3395     __ std(R23, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3396     __ std(R22, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3397     __ std(R21, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3398     __ std(R20, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3399     __ std(R19, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3400     __ std(R18, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3401     __ std(R17, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3402     __ std(R16, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3403     __ std(R15, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3404     __ std(R14, current_offs, R1_SP);</span>
<span class="new">3405 </span>
<span class="new">3406     // Store the squares, right shifted one bit (i.e., divided by 2)</span>
<span class="new">3407     __ subi   (out_aux,   out,       4);</span>
<span class="new">3408     __ subi   (in_aux,    in,        4);</span>
<span class="new">3409     __ cmpwi  (CCR0,      in_len,    0);</span>
<span class="new">3410     __ ble    (CCR0,      SKIP_LOOP_SQUARE);    // in_len &lt;= 0</span>
<span class="new">3411     __ mtctr  (in_len);</span>
<span class="new">3412 </span>
<span class="new">3413     __ bind(LOOP_SQUARE);</span>
<span class="new">3414     __ lwzu   (piece,     4,         in_aux);</span>
<span class="new">3415     __ mulld  (product,   piece,     piece);</span>
<span class="new">3416     // shift left 31 bits and only keep the 31th bit</span>
<span class="new">3417     __ rlwinm (lplw_s,    lplw,      31, 0, 0);</span>
<span class="new">3418     // shift right 33 bits without sign extension</span>
<span class="new">3419     __ srdi   (product_s, product,   33);</span>
<span class="new">3420     __ or_    (product_s, lplw_s,    product_s);</span>
<span class="new">3421     __ stwu   (product_s, 4,         out_aux);</span>
<span class="new">3422     __ mr     (lplw,      product);</span>
<span class="new">3423     __ srdi   (product,   product,   1);</span>
<span class="new">3424     __ stwu   (product,   4,         out_aux);</span>
<span class="new">3425     __ bdnz   (LOOP_SQUARE);</span>
<span class="new">3426 </span>
<span class="new">3427     __ bind(SKIP_LOOP_SQUARE);</span>
<span class="new">3428 </span>
<span class="new">3429     // Add in off-diagonal sums</span>
<span class="new">3430     __ cmpwi  (CCR0,      in_len,    0);</span>
<span class="new">3431     __ ble    (CCR0,      SKIP_DIAGONAL_SUM);</span>
<span class="new">3432     // Avoid CTR usage here in order to use it at mulAdd</span>
<span class="new">3433     __ subi   (i_minus1,  in_len,    1);</span>
<span class="new">3434     __ li     (offset,    4);</span>
<span class="new">3435 </span>
<span class="new">3436     __ bind(LOOP_DIAGONAL_SUM);</span>
<span class="new">3437 </span>
<span class="new">3438     __ sldi   (off_aux,   out_len,   2);</span>
<span class="new">3439     __ sub    (off_aux,   off_aux,   offset);</span>
<span class="new">3440 </span>
<span class="new">3441     __ mr     (len,       i_minus1);</span>
<span class="new">3442     __ sldi   (mlen,      i_minus1,  2);</span>
<span class="new">3443     __ lwzx   (t,         in,        mlen);</span>
<span class="new">3444 </span>
<span class="new">3445     __ muladd (out, in, off_aux, len, t, a, b, carry);</span>
<span class="new">3446 </span>
<span class="new">3447     // begin&lt;addOne&gt;</span>
<span class="new">3448     // off_aux = out_len*4 - 4 - mlen - offset*4 - 4;</span>
<span class="new">3449     __ addi   (mlen,      mlen,      4);</span>
<span class="new">3450     __ sldi   (a,         out_len,   2);</span>
<span class="new">3451     __ subi   (a,         a,         4);</span>
<span class="new">3452     __ sub    (a,         a,         mlen);</span>
<span class="new">3453     __ subi   (off_aux,   offset,    4);</span>
<span class="new">3454     __ sub    (off_aux,   a,         off_aux);</span>
<span class="new">3455 </span>
<span class="new">3456     __ lwzx   (b,         off_aux,   out);</span>
<span class="new">3457     __ add    (b,         b,         carry);</span>
<span class="new">3458     __ stwx   (b,         off_aux,   out);</span>
<span class="new">3459 </span>
<span class="new">3460     // if (((uint64_t)s &gt;&gt; 32) != 0) {</span>
<span class="new">3461     __ srdi_  (a,         b,         32);</span>
<span class="new">3462     __ beq    (CCR0,      SKIP_ADDONE);</span>
<span class="new">3463 </span>
<span class="new">3464     // while (--mlen &gt;= 0) {</span>
<span class="new">3465     __ bind(LOOP_ADDONE);</span>
<span class="new">3466     __ subi   (mlen,      mlen,      4);</span>
<span class="new">3467     __ cmpwi  (CCR0,      mlen,      0);</span>
<span class="new">3468     __ beq    (CCR0,      SKIP_ADDONE);</span>
<span class="new">3469 </span>
<span class="new">3470     // if (--offset_aux &lt; 0) { // Carry out of number</span>
<span class="new">3471     __ subi   (off_aux,   off_aux,   4);</span>
<span class="new">3472     __ cmpwi  (CCR0,      off_aux,   0);</span>
<span class="new">3473     __ blt    (CCR0,      SKIP_ADDONE);</span>
<span class="new">3474 </span>
<span class="new">3475     // } else {</span>
<span class="new">3476     __ lwzx   (b,         off_aux,   out);</span>
<span class="new">3477     __ addi   (b,         b,         1);</span>
<span class="new">3478     __ stwx   (b,         off_aux,   out);</span>
<span class="new">3479     __ cmpwi  (CCR0,      b,         0);</span>
<span class="new">3480     __ bne    (CCR0,      SKIP_ADDONE);</span>
<span class="new">3481     __ b      (LOOP_ADDONE);</span>
<span class="new">3482 </span>
<span class="new">3483     __ bind(SKIP_ADDONE);</span>
<span class="new">3484     // } } } end&lt;addOne&gt;</span>
<span class="new">3485 </span>
<span class="new">3486     __ addi   (offset,    offset,    8);</span>
<span class="new">3487     __ subi   (i_minus1,  i_minus1,  1);</span>
<span class="new">3488     __ cmpwi  (CCR0,      i_minus1,  0);</span>
<span class="new">3489     __ bge    (CCR0,      LOOP_DIAGONAL_SUM);</span>
<span class="new">3490 </span>
<span class="new">3491     __ bind(SKIP_DIAGONAL_SUM);</span>
<span class="new">3492 </span>
<span class="new">3493     // Shift back up and set low bit</span>
<span class="new">3494     // Shifts 1 bit left up to len positions. Assumes no leading zeros</span>
<span class="new">3495     // begin&lt;primitiveLeftShift&gt;</span>
<span class="new">3496     __ cmpwi  (CCR0,      out_len,   0);</span>
<span class="new">3497     __ ble    (CCR0,      SKIP_LSHIFT);</span>
<span class="new">3498     __ li     (i,         0);</span>
<span class="new">3499     __ lwz    (c,         0,         out);</span>
<span class="new">3500     __ subi   (b,         out_len,   1);</span>
<span class="new">3501     __ mtctr  (b);</span>
<span class="new">3502 </span>
<span class="new">3503     __ bind(LOOP_LSHIFT);</span>
<span class="new">3504     __ mr     (b,         c);</span>
<span class="new">3505     __ addi   (cs,        i,         4);</span>
<span class="new">3506     __ lwzx   (c,         out,       cs);</span>
<span class="new">3507 </span>
<span class="new">3508     __ sldi   (b,         b,         1);</span>
<span class="new">3509     __ srwi   (cs,        c,         31);</span>
<span class="new">3510     __ or_    (b,         b,         cs);</span>
<span class="new">3511     __ stwx   (b,         i,         out);</span>
<span class="new">3512 </span>
<span class="new">3513     __ addi   (i,         i,         4);</span>
<span class="new">3514     __ bdnz   (LOOP_LSHIFT);</span>
<span class="new">3515 </span>
<span class="new">3516     __ sldi   (c,         out_len,   2);</span>
<span class="new">3517     __ subi   (c,         c,         4);</span>
<span class="new">3518     __ lwzx   (b,         out,       c);</span>
<span class="new">3519     __ sldi   (b,         b,         1);</span>
<span class="new">3520     __ stwx   (b,         out,       c);</span>
<span class="new">3521 </span>
<span class="new">3522     __ bind(SKIP_LSHIFT);</span>
<span class="new">3523     // end&lt;primitiveLeftShift&gt;</span>
<span class="new">3524 </span>
<span class="new">3525     // Set low bit</span>
<span class="new">3526     __ sldi   (i,         in_len,    2);</span>
<span class="new">3527     __ subi   (i,         i,         4);</span>
<span class="new">3528     __ lwzx   (i,         in,        i);</span>
<span class="new">3529     __ sldi   (c,         out_len,   2);</span>
<span class="new">3530     __ subi   (c,         c,         4);</span>
<span class="new">3531     __ lwzx   (b,         out,       c);</span>
<span class="new">3532 </span>
<span class="new">3533     __ andi_  (i,         i,         1);</span>
<span class="new">3534     __ or_    (i,         b,         i);</span>
<span class="new">3535 </span>
<span class="new">3536     __ stwx   (i,         out,       c);</span>
<span class="new">3537 </span>
<span class="new">3538     // Restore non-volatile regs.</span>
<span class="new">3539     current_offs = -8;</span>
<span class="new">3540     __ ld(R28, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3541     __ ld(R27, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3542     __ ld(R26, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3543     __ ld(R25, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3544     __ ld(R24, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3545     __ ld(R23, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3546     __ ld(R22, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3547     __ ld(R21, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3548     __ ld(R20, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3549     __ ld(R19, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3550     __ ld(R18, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3551     __ ld(R17, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3552     __ ld(R16, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3553     __ ld(R15, current_offs, R1_SP); current_offs -= 8;</span>
<span class="new">3554     __ ld(R14, current_offs, R1_SP);</span>
<span class="new">3555 </span>
<span class="new">3556     __ mr(ret, out);</span>
<span class="new">3557     __ blr();</span>
<span class="new">3558 </span>
<span class="new">3559     return start;</span>
<span class="new">3560   }</span>
3561 
3562   /**
3563    * Arguments:
3564    *
3565    * Inputs:
3566    *   R3_ARG1    - int   crc
3567    *   R4_ARG2    - byte* buf
3568    *   R5_ARG3    - int   length (of buffer)
3569    *
3570    * scratch:
3571    *   R2, R6-R12
3572    *
3573    * Ouput:
3574    *   R3_RET     - int   crc result
3575    */
3576   // Compute CRC32 function.
3577   address generate_CRC32_updateBytes(const char* name) {
3578     __ align(CodeEntryAlignment);
3579     StubCodeMark mark(this, "StubRoutines", name);
3580     address start = __ function_entry();  // Remember stub start address (is rtn value).

</pre><hr></hr><pre>
3735     // support for verify_oop (must happen after universe_init)
3736     StubRoutines::_verify_oop_subroutine_entry             = generate_verify_oop();
3737 
3738     // arraycopy stubs used by compilers
3739     generate_arraycopy_stubs();
3740 
3741     // Safefetch stubs.
3742     generate_safefetch("SafeFetch32", sizeof(int),     &amp;StubRoutines::_safefetch32_entry,
3743                                                        &amp;StubRoutines::_safefetch32_fault_pc,
3744                                                        &amp;StubRoutines::_safefetch32_continuation_pc);
3745     generate_safefetch("SafeFetchN", sizeof(intptr_t), &amp;StubRoutines::_safefetchN_entry,
3746                                                        &amp;StubRoutines::_safefetchN_fault_pc,
3747                                                        &amp;StubRoutines::_safefetchN_continuation_pc);
3748 
3749 #ifdef COMPILER2
3750     if (UseMultiplyToLenIntrinsic) {
3751       StubRoutines::_multiplyToLen = generate_multiplyToLen();
3752     }
3753 #endif
3754 
<span class="new">3755     if (UseSquareToLenIntrinsic) {</span>
<span class="new">3756       StubRoutines::_squareToLen = generate_squareToLen();</span>
<span class="new">3757     }</span>
<span class="new">3758     if (UseMulAddIntrinsic) {</span>
<span class="new">3759       StubRoutines::_mulAdd = generate_mulAdd();</span>
<span class="new">3760     }</span>
3761     if (UseMontgomeryMultiplyIntrinsic) {
3762       StubRoutines::_montgomeryMultiply
3763         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_multiply);
3764     }
3765     if (UseMontgomerySquareIntrinsic) {
3766       StubRoutines::_montgomerySquare
3767         = CAST_FROM_FN_PTR(address, SharedRuntime::montgomery_square);
3768     }
3769 
3770     if (UseAESIntrinsics) {
3771       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3772       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3773     }
3774 
3775   }
3776 
3777  public:
3778   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3779     // replace the standard masm with a special one:
3780     _masm = new MacroAssembler(code);
</pre></td>
</tr></table>
<center><a href='../../../../src/cpu/ppc/vm/macroAssembler_ppc.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/vm_version_ppc.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>

<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/cpu/ppc/vm/vm_version_ppc.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2017, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 #include "asm/assembler.inline.hpp"
  28 #include "asm/macroAssembler.inline.hpp"
  29 #include "compiler/disassembler.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "runtime/java.hpp"
  32 #include "runtime/os.hpp"
  33 #include "runtime/stubCodeGenerator.hpp"
  34 #include "utilities/defaultStream.hpp"
  35 #include "utilities/globalDefinitions.hpp"
  36 #include "vm_version_ppc.hpp"
  37 
  38 # include &lt;sys/sysinfo.h&gt;
  39 
  40 bool VM_Version::_is_determine_features_test_running = false;
  41 uint64_t VM_Version::_dscr_val = 0;
  42 
  43 #define MSG(flag)   \
  44   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
  45       jio_fprintf(defaultStream::error_stream(),                       \
  46                   "warning: -XX:+" #flag " requires -XX:+UseSIGTRAP\n" \
  47                   "         -XX:+" #flag " will be disabled!\n");
  48 
  49 void VM_Version::initialize() {
  50 
  51   // Test which instructions are supported and measure cache line size.
  52   determine_features();
  53 
  54   // If PowerArchitecturePPC64 hasn't been specified explicitly determine from features.
  55   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
  56     if (VM_Version::has_lqarx()) {
  57       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 8);
  58     } else if (VM_Version::has_popcntw()) {
  59       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 7);
  60     } else if (VM_Version::has_cmpb()) {
  61       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 6);
  62     } else if (VM_Version::has_popcntb()) {
  63       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 5);
  64     } else {
  65       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 0);
  66     }
  67   }
  68 
  69   bool PowerArchitecturePPC64_ok = false;
  70   switch (PowerArchitecturePPC64) {
  71     case 8: if (!VM_Version::has_lqarx()  ) break;
  72     case 7: if (!VM_Version::has_popcntw()) break;
  73     case 6: if (!VM_Version::has_cmpb()   ) break;
  74     case 5: if (!VM_Version::has_popcntb()) break;
  75     case 0: PowerArchitecturePPC64_ok = true; break;
  76     default: break;
  77   }
  78   guarantee(PowerArchitecturePPC64_ok, "PowerArchitecturePPC64 cannot be set to "
  79             UINTX_FORMAT " on this machine", PowerArchitecturePPC64);
  80 
  81   // Power 8: Configure Data Stream Control Register.
  82   if (has_mfdscr()) {
  83     config_dscr();
  84   }
  85 
  86   if (!UseSIGTRAP) {
  87     MSG(TrapBasedICMissChecks);
  88     MSG(TrapBasedNotEntrantChecks);
  89     MSG(TrapBasedNullChecks);
  90     FLAG_SET_ERGO(bool, TrapBasedNotEntrantChecks, false);
  91     FLAG_SET_ERGO(bool, TrapBasedNullChecks,       false);
  92     FLAG_SET_ERGO(bool, TrapBasedICMissChecks,     false);
  93   }
  94 
  95 #ifdef COMPILER2
  96   if (!UseSIGTRAP) {
  97     MSG(TrapBasedRangeChecks);
  98     FLAG_SET_ERGO(bool, TrapBasedRangeChecks, false);
  99   }
 100 
 101   // On Power6 test for section size.
 102   if (PowerArchitecturePPC64 == 6) {
 103     determine_section_size();
 104   // TODO: PPC port } else {
 105   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
 106   }
 107 
 108   MaxVectorSize = 8;
 109 #endif
 110 
 111   // Create and print feature-string.
 112   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
 113   jio_snprintf(buf, sizeof(buf),
 114                "ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
 115                (has_fsqrt()   ? " fsqrt"   : ""),
 116                (has_isel()    ? " isel"    : ""),
 117                (has_lxarxeh() ? " lxarxeh" : ""),
 118                (has_cmpb()    ? " cmpb"    : ""),
 119                //(has_mftgpr()? " mftgpr"  : ""),
 120                (has_popcntb() ? " popcntb" : ""),
 121                (has_popcntw() ? " popcntw" : ""),
 122                (has_fcfids()  ? " fcfids"  : ""),
 123                (has_vand()    ? " vand"    : ""),
 124                (has_lqarx()   ? " lqarx"   : ""),
 125                (has_vcipher() ? " aes"     : ""),
 126                (has_vpmsumb() ? " vpmsumb" : ""),
 127                (has_tcheck()  ? " tcheck"  : ""),
 128                (has_mfdscr()  ? " mfdscr"  : ""),
 129                (has_vsx()     ? " vsx"     : "")
 130                // Make sure number of %s matches num_features!
 131               );
 132   _features_string = os::strdup(buf);
 133   if (Verbose) {
 134     print_features();
 135   }
 136 
 137   // PPC64 supports 8-byte compare-exchange operations (see
 138   // Atomic::cmpxchg and StubGenerator::generate_atomic_cmpxchg_ptr)
 139   // and 'atomic long memory ops' (see Unsafe_GetLongVolatile).
 140   _supports_cx8 = true;
 141 
 142   // Used by C1.
 143   _supports_atomic_getset4 = true;
 144   _supports_atomic_getadd4 = true;
 145   _supports_atomic_getset8 = true;
 146   _supports_atomic_getadd8 = true;
 147 
 148   UseSSE = 0; // Only on x86 and x64
 149 
 150   intx cache_line_size = L1_data_cache_line_size();
 151 
 152   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
 153 
 154   if (AllocatePrefetchStyle == 4) {
 155     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
 156     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
 157     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
 158   } else {
 159     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
 160     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
 161     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
 162   }
 163 
 164   assert(AllocatePrefetchLines &gt; 0, "invalid value");
 165   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
 166     AllocatePrefetchLines = 1; // Conservative value.
 167   }
 168 
 169   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
 170     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
 171   }
 172 
 173   assert(AllocatePrefetchStyle &gt;= 0, "AllocatePrefetchStyle should be positive");
 174 
 175   // If defined(VM_LITTLE_ENDIAN) and running on Power8 or newer hardware,
 176   // the implementation uses the vector instructions available with Power8.
 177   // In all other cases, the implementation uses only generally available instructions.
 178   if (!UseCRC32Intrinsics) {
 179     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 180       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 181     }
 182   }
 183 
 184   // Implementation does not use any of the vector instructions available with Power8.
 185   // Their exploitation is still pending (aka "work in progress").
 186   if (!UseCRC32CIntrinsics) {
 187     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 188       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 189     }
 190   }
 191 
 192   // TODO: Provide implementation.
 193   if (UseAdler32Intrinsics) {
 194     warning("Adler32Intrinsics not available on this CPU.");
 195     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 196   }
 197 
 198   // The AES intrinsic stubs require AES instruction support.
 199 #if defined(VM_LITTLE_ENDIAN)
 200   if (has_vcipher()) {
 201     if (FLAG_IS_DEFAULT(UseAES)) {
 202       UseAES = true;
 203     }
 204   } else if (UseAES) {
 205     if (!FLAG_IS_DEFAULT(UseAES))
 206       warning("AES instructions are not available on this CPU");
 207     FLAG_SET_DEFAULT(UseAES, false);
 208   }
 209 
 210   if (UseAES &amp;&amp; has_vcipher()) {
 211     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 212       UseAESIntrinsics = true;
 213     }
 214   } else if (UseAESIntrinsics) {
 215     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
 216       warning("AES intrinsics are not available on this CPU");
 217     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 218   }
 219 
 220 #else
 221   if (UseAES) {
 222     warning("AES instructions are not available on this CPU");
 223     FLAG_SET_DEFAULT(UseAES, false);
 224   }
 225   if (UseAESIntrinsics) {
 226     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
 227       warning("AES intrinsics are not available on this CPU");
 228     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 229   }
 230 #endif
 231 
 232   if (UseAESCTRIntrinsics) {
 233     warning("AES/CTR intrinsics are not available on this CPU");
 234     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 235   }
 236 
 237   if (UseGHASHIntrinsics) {
 238     warning("GHASH intrinsics are not available on this CPU");
 239     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 240   }
 241 
 242   if (FLAG_IS_DEFAULT(UseFMA)) {
 243     FLAG_SET_DEFAULT(UseFMA, true);
 244   }
 245 
 246   if (UseSHA) {
 247     warning("SHA instructions are not available on this CPU");
 248     FLAG_SET_DEFAULT(UseSHA, false);
 249   }
 250   if (UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics) {
 251     warning("SHA intrinsics are not available on this CPU");
 252     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 253     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 254     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 255   }
 256 
 257   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 258     UseMultiplyToLenIntrinsic = true;
 259   }
 260   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 261     UseMontgomeryMultiplyIntrinsic = true;
 262   }
 263   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 264     UseMontgomerySquareIntrinsic = true;
 265   }
 266 
 267   if (UseVectorizedMismatchIntrinsic) {
 268     warning("UseVectorizedMismatchIntrinsic specified, but not available on this CPU.");
 269     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
 270   }
 271 
 272 
 273   // Adjust RTM (Restricted Transactional Memory) flags.
 274   if (UseRTMLocking) {
 275     // If CPU or OS are too old:
 276     // Can't continue because UseRTMLocking affects UseBiasedLocking flag
 277     // setting during arguments processing. See use_biased_locking().
 278     // VM_Version_init() is executed after UseBiasedLocking is used
 279     // in Thread::allocate().
 280     if (!has_tcheck()) {
 281       vm_exit_during_initialization("RTM instructions are not available on this CPU");
 282     }
 283     bool os_too_old = true;
 284 #ifdef AIX
 285     // Actually, this is supported since AIX 7.1.. Unfortunately, this first
 286     // contained bugs, so that it can only be enabled after AIX 7.1.3.30.
 287     // The Java property os.version, which is used in RTM tests to decide
 288     // whether the feature is available, only knows major and minor versions.
 289     // We don't want to change this property, as user code might depend on it.
 290     // So the tests can not check on subversion 3.30, and we only enable RTM
 291     // with AIX 7.2.
 292     if (os::Aix::os_version() &gt;= 0x07020000) { // At least AIX 7.2.
 293       os_too_old = false;
 294     }
 295 #endif
 296 #ifdef LINUX
 297     // At least Linux kernel 4.2, as the problematic behavior of syscalls
 298     // being called in the middle of a transaction has been addressed.
 299     // Please, refer to commit b4b56f9ecab40f3b4ef53e130c9f6663be491894
 300     // in Linux kernel source tree: https://goo.gl/Kc5i7A
 301     if (os::Linux::os_version_is_known()) {
 302       if (os::Linux::os_version() &gt;= 0x040200)
 303         os_too_old = false;
 304     } else {
 305       vm_exit_during_initialization("RTM can not be enabled: kernel version is unknown.");
 306     }
 307 #endif
 308     if (os_too_old) {
 309       vm_exit_during_initialization("RTM is not supported on this OS version.");
 310     }
 311   }
 312 
 313   if (UseRTMLocking) {
 314 #if INCLUDE_RTM_OPT
 315     if (!UnlockExperimentalVMOptions) {
 316       vm_exit_during_initialization("UseRTMLocking is only available as experimental option on this platform. "
 317                                     "It must be enabled via -XX:+UnlockExperimentalVMOptions flag.");
 318     } else {
 319       warning("UseRTMLocking is only available as experimental option on this platform.");
 320     }
 321     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
 322       // RTM locking should be used only for applications with
 323       // high lock contention. For now we do not use it by default.
 324       vm_exit_during_initialization("UseRTMLocking flag should be only set on command line");
 325     }
 326     if (!is_power_of_2(RTMTotalCountIncrRate)) {
 327       warning("RTMTotalCountIncrRate must be a power of 2, resetting it to 64");
 328       FLAG_SET_DEFAULT(RTMTotalCountIncrRate, 64);
 329     }
 330     if (RTMAbortRatio &lt; 0 || RTMAbortRatio &gt; 100) {
 331       warning("RTMAbortRatio must be in the range 0 to 100, resetting it to 50");
 332       FLAG_SET_DEFAULT(RTMAbortRatio, 50);
 333     }
 334     if (RTMSpinLoopCount &lt; 0) {
 335       warning("RTMSpinLoopCount must not be a negative value, resetting it to 0");
 336       FLAG_SET_DEFAULT(RTMSpinLoopCount, 0);
 337     }
 338 #else
 339     // Only C2 does RTM locking optimization.
 340     // Can't continue because UseRTMLocking affects UseBiasedLocking flag
 341     // setting during arguments processing. See use_biased_locking().
 342     vm_exit_during_initialization("RTM locking optimization is not supported in this VM");
 343 #endif
 344   } else { // !UseRTMLocking
 345     if (UseRTMForStackLocks) {
 346       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 347         warning("UseRTMForStackLocks flag should be off when UseRTMLocking flag is off");
 348       }
 349       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
 350     }
 351     if (UseRTMDeopt) {
 352       FLAG_SET_DEFAULT(UseRTMDeopt, false);
 353     }
 354     if (PrintPreciseRTMLockingStatistics) {
 355       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
 356     }
 357   }
 358 
 359   // This machine allows unaligned memory accesses
 360   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 361     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 362   }
 363 }
 364 
 365 bool VM_Version::use_biased_locking() {
 366 #if INCLUDE_RTM_OPT
 367   // RTM locking is most useful when there is high lock contention and
 368   // low data contention. With high lock contention the lock is usually
 369   // inflated and biased locking is not suitable for that case.
 370   // RTM locking code requires that biased locking is off.
 371   // Note: we can't switch off UseBiasedLocking in get_processor_features()
 372   // because it is used by Thread::allocate() which is called before
 373   // VM_Version::initialize().
 374   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
 375     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
 376       FLAG_SET_DEFAULT(UseBiasedLocking, false);
 377     } else {
 378       warning("Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag." );
 379       UseBiasedLocking = false;
 380     }
 381   }
 382 #endif
 383   return UseBiasedLocking;
 384 }
 385 
 386 void VM_Version::print_features() {
 387   tty-&gt;print_cr("Version: %s L1_data_cache_line_size=%d", features_string(), L1_data_cache_line_size());
 388 }
 389 
 390 #ifdef COMPILER2
 391 // Determine section size on power6: If section size is 8 instructions,
 392 // there should be a difference between the two testloops of ~15 %. If
 393 // no difference is detected the section is assumed to be 32 instructions.
 394 void VM_Version::determine_section_size() {
 395 
 396   int unroll = 80;
 397 
 398   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
 399 
 400   // Allocate space for the code.
 401   ResourceMark rm;
 402   CodeBuffer cb("detect_section_size", code_size, 0);
 403   MacroAssembler* a = new MacroAssembler(&amp;cb);
 404 
 405   uint32_t *code = (uint32_t *)a-&gt;pc();
 406   // Emit code.
 407   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
 408 
 409   Label l1;
 410 
 411   a-&gt;li(R4, 1);
 412   a-&gt;sldi(R4, R4, 28);
 413   a-&gt;b(l1);
 414   a-&gt;align(CodeEntryAlignment);
 415 
 416   a-&gt;bind(l1);
 417 
 418   for (int i = 0; i &lt; unroll; i++) {
 419     // Schleife 1
 420     // ------- sector 0 ------------
 421     // ;; 0
 422     a-&gt;nop();                   // 1
 423     a-&gt;fpnop0();                // 2
 424     a-&gt;fpnop1();                // 3
 425     a-&gt;addi(R4,R4, -1); // 4
 426 
 427     // ;;  1
 428     a-&gt;nop();                   // 5
 429     a-&gt;fmr(F6, F6);             // 6
 430     a-&gt;fmr(F7, F7);             // 7
 431     a-&gt;endgroup();              // 8
 432     // ------- sector 8 ------------
 433 
 434     // ;;  2
 435     a-&gt;nop();                   // 9
 436     a-&gt;nop();                   // 10
 437     a-&gt;fmr(F8, F8);             // 11
 438     a-&gt;fmr(F9, F9);             // 12
 439 
 440     // ;;  3
 441     a-&gt;nop();                   // 13
 442     a-&gt;fmr(F10, F10);           // 14
 443     a-&gt;fmr(F11, F11);           // 15
 444     a-&gt;endgroup();              // 16
 445     // -------- sector 16 -------------
 446 
 447     // ;;  4
 448     a-&gt;nop();                   // 17
 449     a-&gt;nop();                   // 18
 450     a-&gt;fmr(F15, F15);           // 19
 451     a-&gt;fmr(F16, F16);           // 20
 452 
 453     // ;;  5
 454     a-&gt;nop();                   // 21
 455     a-&gt;fmr(F17, F17);           // 22
 456     a-&gt;fmr(F18, F18);           // 23
 457     a-&gt;endgroup();              // 24
 458     // ------- sector 24  ------------
 459 
 460     // ;;  6
 461     a-&gt;nop();                   // 25
 462     a-&gt;nop();                   // 26
 463     a-&gt;fmr(F19, F19);           // 27
 464     a-&gt;fmr(F20, F20);           // 28
 465 
 466     // ;;  7
 467     a-&gt;nop();                   // 29
 468     a-&gt;fmr(F21, F21);           // 30
 469     a-&gt;fmr(F22, F22);           // 31
 470     a-&gt;brnop0();                // 32
 471 
 472     // ------- sector 32 ------------
 473   }
 474 
 475   // ;; 8
 476   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
 477   a-&gt;bge(CCR0, l1);             // 34
 478   a-&gt;blr();
 479 
 480   // Emit code.
 481   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
 482   // uint32_t *code = (uint32_t *)a-&gt;pc();
 483 
 484   Label l2;
 485 
 486   a-&gt;li(R4, 1);
 487   a-&gt;sldi(R4, R4, 28);
 488   a-&gt;b(l2);
 489   a-&gt;align(CodeEntryAlignment);
 490 
 491   a-&gt;bind(l2);
 492 
 493   for (int i = 0; i &lt; unroll; i++) {
 494     // Schleife 2
 495     // ------- sector 0 ------------
 496     // ;; 0
 497     a-&gt;brnop0();                  // 1
 498     a-&gt;nop();                     // 2
 499     //a-&gt;cmpdi(CCR0, R4, unroll);
 500     a-&gt;fpnop0();                  // 3
 501     a-&gt;fpnop1();                  // 4
 502     a-&gt;addi(R4,R4, -1);           // 5
 503 
 504     // ;; 1
 505 
 506     a-&gt;nop();                     // 6
 507     a-&gt;fmr(F6, F6);               // 7
 508     a-&gt;fmr(F7, F7);               // 8
 509     // ------- sector 8 ---------------
 510 
 511     // ;; 2
 512     a-&gt;endgroup();                // 9
 513 
 514     // ;; 3
 515     a-&gt;nop();                     // 10
 516     a-&gt;nop();                     // 11
 517     a-&gt;fmr(F8, F8);               // 12
 518 
 519     // ;; 4
 520     a-&gt;fmr(F9, F9);               // 13
 521     a-&gt;nop();                     // 14
 522     a-&gt;fmr(F10, F10);             // 15
 523 
 524     // ;; 5
 525     a-&gt;fmr(F11, F11);             // 16
 526     // -------- sector 16 -------------
 527 
 528     // ;; 6
 529     a-&gt;endgroup();                // 17
 530 
 531     // ;; 7
 532     a-&gt;nop();                     // 18
 533     a-&gt;nop();                     // 19
 534     a-&gt;fmr(F15, F15);             // 20
 535 
 536     // ;; 8
 537     a-&gt;fmr(F16, F16);             // 21
 538     a-&gt;nop();                     // 22
 539     a-&gt;fmr(F17, F17);             // 23
 540 
 541     // ;; 9
 542     a-&gt;fmr(F18, F18);             // 24
 543     // -------- sector 24 -------------
 544 
 545     // ;; 10
 546     a-&gt;endgroup();                // 25
 547 
 548     // ;; 11
 549     a-&gt;nop();                     // 26
 550     a-&gt;nop();                     // 27
 551     a-&gt;fmr(F19, F19);             // 28
 552 
 553     // ;; 12
 554     a-&gt;fmr(F20, F20);             // 29
 555     a-&gt;nop();                     // 30
 556     a-&gt;fmr(F21, F21);             // 31
 557 
 558     // ;; 13
 559     a-&gt;fmr(F22, F22);             // 32
 560   }
 561 
 562   // -------- sector 32 -------------
 563   // ;; 14
 564   a-&gt;cmpdi(CCR0, R4, unroll); // 33
 565   a-&gt;bge(CCR0, l2);           // 34
 566 
 567   a-&gt;blr();
 568   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 569   a-&gt;flush();
 570 
 571   double loop1_seconds,loop2_seconds, rel_diff;
 572   uint64_t start1, stop1;
 573 
 574   start1 = os::current_thread_cpu_time(false);
 575   (*test1)();
 576   stop1 = os::current_thread_cpu_time(false);
 577   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
 578 
 579 
 580   start1 = os::current_thread_cpu_time(false);
 581   (*test2)();
 582   stop1 = os::current_thread_cpu_time(false);
 583 
 584   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
 585 
 586   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
 587 
 588   if (PrintAssembly) {
 589     ttyLocker ttyl;
 590     tty-&gt;print_cr("Decoding section size detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
 591     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 592     tty-&gt;print_cr("Time loop1 :%f", loop1_seconds);
 593     tty-&gt;print_cr("Time loop2 :%f", loop2_seconds);
 594     tty-&gt;print_cr("(time2 - time1) / time1 = %f %%", rel_diff);
 595 
 596     if (rel_diff &gt; 12.0) {
 597       tty-&gt;print_cr("Section Size 8 Instructions");
 598     } else{
 599       tty-&gt;print_cr("Section Size 32 Instructions or Power5");
 600     }
 601   }
 602 
 603 #if 0 // TODO: PPC port
 604   // Set sector size (if not set explicitly).
 605   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
 606     if (rel_diff &gt; 12.0) {
 607       PdScheduling::power6SectorSize = 0x20;
 608     } else {
 609       PdScheduling::power6SectorSize = 0x80;
 610     }
 611   } else if (Power6SectorSize128PPC64) {
 612     PdScheduling::power6SectorSize = 0x80;
 613   } else {
 614     PdScheduling::power6SectorSize = 0x20;
 615   }
 616 #endif
 617   if (UsePower6SchedulerPPC64) Unimplemented();
 618 }
 619 #endif // COMPILER2
 620 
 621 void VM_Version::determine_features() {
 622 #if defined(ABI_ELFv2)
 623   // 1 InstWord per call for the blr instruction.
 624   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
 625 #else
 626   // 7 InstWords for each call (function descriptor + blr instruction).
 627   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
 628 #endif
 629   int features = 0;
 630 
 631   // create test area
 632   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can't exceed min page size).
 633   char test_area[BUFFER_SIZE];
 634   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
 635 
 636   // Allocate space for the code.
 637   ResourceMark rm;
 638   CodeBuffer cb("detect_cpu_features", code_size, 0);
 639   MacroAssembler* a = new MacroAssembler(&amp;cb);
 640 
 641   // Must be set to true so we can generate the test code.
 642   _features = VM_Version::all_features_m;
 643 
 644   // Emit code.
 645   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
 646   uint32_t *code = (uint32_t *)a-&gt;pc();
 647   // Don't use R0 in ldarx.
 648   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
 649   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
 650   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
 651   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
 652   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
 653   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
 654   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
 655   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
 656   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
 657   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
 658   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
 659   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
 660   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
 661   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
 662   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
 663   a-&gt;tcheck(0);                                // code[12] -&gt; tcheck
 664   a-&gt;mfdscr(R0);                               // code[13] -&gt; mfdscr
 665   a-&gt;lxvd2x(VSR0, R3_ARG1);                    // code[14] -&gt; vsx
 666   a-&gt;blr();
 667 
 668   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
 669   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
 670   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
 671   a-&gt;blr();
 672 
 673   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 674   a-&gt;flush();
 675   _features = VM_Version::unknown_m;
 676 
 677   // Print the detection code.
 678   if (PrintAssembly) {
 679     ttyLocker ttyl;
 680     tty-&gt;print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
 681     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 682   }
 683 
 684   // Measure cache line size.
 685   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
 686   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
 687   int count = 0; // count zeroed bytes
 688   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
 689   guarantee(is_power_of_2(count), "cache line size needs to be a power of 2");
 690   _L1_data_cache_line_size = count;
 691 
 692   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
 693   VM_Version::_is_determine_features_test_running = true;
 694   // We must align the first argument to 16 bytes because of the lqarx check.
 695   (*test)((address)align_size_up((intptr_t)mid_of_test_area, 16), (uint64_t)0);
 696   VM_Version::_is_determine_features_test_running = false;
 697 
 698   // determine which instructions are legal.
 699   int feature_cntr = 0;
 700   if (code[feature_cntr++]) features |= fsqrt_m;
 701   if (code[feature_cntr++]) features |= fsqrts_m;
 702   if (code[feature_cntr++]) features |= isel_m;
 703   if (code[feature_cntr++]) features |= lxarxeh_m;
 704   if (code[feature_cntr++]) features |= cmpb_m;
 705   if (code[feature_cntr++]) features |= popcntb_m;
 706   if (code[feature_cntr++]) features |= popcntw_m;
 707   if (code[feature_cntr++]) features |= fcfids_m;
 708   if (code[feature_cntr++]) features |= vand_m;
 709   if (code[feature_cntr++]) features |= lqarx_m;
 710   if (code[feature_cntr++]) features |= vcipher_m;
 711   if (code[feature_cntr++]) features |= vpmsumb_m;
 712   if (code[feature_cntr++]) features |= tcheck_m;
 713   if (code[feature_cntr++]) features |= mfdscr_m;
 714   if (code[feature_cntr++]) features |= vsx_m;
 715 
 716   // Print the detection code.
 717   if (PrintAssembly) {
 718     ttyLocker ttyl;
 719     tty-&gt;print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " after execution:", p2i(code));
 720     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 721   }
 722 
 723   _features = features;
 724 }
 725 
 726 // Power 8: Configure Data Stream Control Register.
 727 void VM_Version::config_dscr() {
 728   // 7 InstWords for each call (function descriptor + blr instruction).
 729   const int code_size = (2+2*7)*BytesPerInstWord;
 730 
 731   // Allocate space for the code.
 732   ResourceMark rm;
 733   CodeBuffer cb("config_dscr", code_size, 0);
 734   MacroAssembler* a = new MacroAssembler(&amp;cb);
 735 
 736   // Emit code.
 737   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
 738   uint32_t *code = (uint32_t *)a-&gt;pc();
 739   a-&gt;mfdscr(R3);
 740   a-&gt;blr();
 741 
 742   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
 743   a-&gt;mtdscr(R3);
 744   a-&gt;blr();
 745 
 746   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 747   a-&gt;flush();
 748 
 749   // Print the detection code.
 750   if (PrintAssembly) {
 751     ttyLocker ttyl;
 752     tty-&gt;print_cr("Decoding dscr configuration stub at " INTPTR_FORMAT " before execution:", p2i(code));
 753     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 754   }
 755 
 756   // Apply the configuration if needed.
 757   _dscr_val = (*get_dscr)();
 758   if (Verbose) {
 759     tty-&gt;print_cr("dscr value was 0x%lx" , _dscr_val);
 760   }
 761   bool change_requested = false;
 762   if (DSCR_PPC64 != (uintx)-1) {
 763     _dscr_val = DSCR_PPC64;
 764     change_requested = true;
 765   }
 766   if (DSCR_DPFD_PPC64 &lt;= 7) {
 767     uint64_t mask = 0x7;
 768     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
 769       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
 770       change_requested = true;
 771     }
 772   }
 773   if (DSCR_URG_PPC64 &lt;= 7) {
 774     uint64_t mask = 0x7 &lt;&lt; 6;
 775     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
 776       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
 777       change_requested = true;
 778     }
 779   }
 780   if (change_requested) {
 781     (*set_dscr)(_dscr_val);
 782     if (Verbose) {
 783       tty-&gt;print_cr("dscr was set to 0x%lx" , (*get_dscr)());
 784     }
 785   }
 786 }
 787 
 788 static uint64_t saved_features = 0;
 789 
 790 void VM_Version::allow_all() {
 791   saved_features = _features;
 792   _features      = all_features_m;
 793 }
 794 
 795 void VM_Version::revert() {
 796   _features = saved_features;
 797 }
</pre></body></html>

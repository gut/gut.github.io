<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk10-hotspot-hg Sdiff src/cpu/ppc/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/cpu/ppc/vm/macroAssembler_ppc.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> next &gt</center>
<h2>src/cpu/ppc/vm/stubGenerator_ppc.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13010">13010</a> : Fix vsldoi interface according to ISA

vsldoi should accept a 5 bit unsigned integer and OpenJDK has set it as
5 bit signed integer.

Changed not only the interface but also all related code that was
adapted to use it as signed (hence -8 is now 8)</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
2711     __ li              (hex, 16);
2712     __ li              (fifteen, 15);
2713     __ vspltisb        (fSplt, 0x0f);
2714 
2715     // load unaligned from[0-15] to vsRet
2716     __ lvx             (vRet, from);
2717     __ lvx             (vTmp1, fifteen, from);
2718     __ lvsl            (fromPerm, from);
2719     __ vxor            (fromPerm, fromPerm, fSplt);
2720     __ vperm           (vRet, vRet, vTmp1, fromPerm);
2721 
2722     // load keylen (44 or 52 or 60)
2723     __ lwz             (keylen, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT), key);
2724 
2725     // to load keys
2726     __ lvsr            (keyPerm, key);
2727     __ vxor            (vTmp2, vTmp2, vTmp2);
2728     __ vspltisb        (vTmp2, -16);
2729     __ vrld            (keyPerm, keyPerm, vTmp2);
2730     __ vrld            (keyPerm, keyPerm, vTmp2);
<span class="changed">2731     __ vsldoi          (keyPerm, keyPerm, keyPerm, -8);</span>
2732 
2733     // load the 1st round key to vKey1
2734     __ li              (keypos, 0);
2735     __ lvx             (vKey1, keypos, key);
2736     __ addi            (keypos, keypos, 16);
2737     __ lvx             (vTmp1, keypos, key);
2738     __ vperm           (vKey1, vTmp1, vKey1, keyPerm);
2739 
2740     // 1st round
2741     __ vxor (vRet, vRet, vKey1);
2742 
2743     // load the 2nd round key to vKey1
2744     __ addi            (keypos, keypos, 16);
2745     __ lvx             (vTmp2, keypos, key);
2746     __ vperm           (vKey1, vTmp2, vTmp1, keyPerm);
2747 
2748     // load the 3rd round key to vKey2
2749     __ addi            (keypos, keypos, 16);
2750     __ lvx             (vTmp1, keypos, key);
2751     __ vperm           (vKey2, vTmp1, vTmp2, keyPerm);

</pre><hr></hr><pre>
2911     __ li              (hex, 16);
2912     __ li              (fifteen, 15);
2913     __ vspltisb        (fSplt, 0x0f);
2914 
2915     // load unaligned from[0-15] to vsRet
2916     __ lvx             (vRet, from);
2917     __ lvx             (vTmp1, fifteen, from);
2918     __ lvsl            (fromPerm, from);
2919     __ vxor            (fromPerm, fromPerm, fSplt);
2920     __ vperm           (vRet, vRet, vTmp1, fromPerm); // align [and byte swap in LE]
2921 
2922     // load keylen (44 or 52 or 60)
2923     __ lwz             (keylen, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT), key);
2924 
2925     // to load keys
2926     __ lvsr            (keyPerm, key);
2927     __ vxor            (vTmp2, vTmp2, vTmp2);
2928     __ vspltisb        (vTmp2, -16);
2929     __ vrld            (keyPerm, keyPerm, vTmp2);
2930     __ vrld            (keyPerm, keyPerm, vTmp2);
<span class="changed">2931     __ vsldoi          (keyPerm, keyPerm, keyPerm, -8);</span>
2932 
2933     __ cmpwi           (CCR0, keylen, 44);
2934     __ beq             (CCR0, L_do44);
2935 
2936     __ cmpwi           (CCR0, keylen, 52);
2937     __ beq             (CCR0, L_do52);
2938 
2939     // load the 15th round key to vKey11
2940     __ li              (keypos, 240);
2941     __ lvx             (vTmp1, keypos, key);
2942     __ addi            (keypos, keypos, -16);
2943     __ lvx             (vTmp2, keypos, key);
2944     __ vperm           (vKey1, vTmp1, vTmp2, keyPerm);
2945 
2946     // load the 14th round key to vKey10
2947     __ addi            (keypos, keypos, -16);
2948     __ lvx             (vTmp1, keypos, key);
2949     __ vperm           (vKey2, vTmp2, vTmp1, keyPerm);
2950 
2951     // load the 13th round key to vKey10

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
2711     __ li              (hex, 16);
2712     __ li              (fifteen, 15);
2713     __ vspltisb        (fSplt, 0x0f);
2714 
2715     // load unaligned from[0-15] to vsRet
2716     __ lvx             (vRet, from);
2717     __ lvx             (vTmp1, fifteen, from);
2718     __ lvsl            (fromPerm, from);
2719     __ vxor            (fromPerm, fromPerm, fSplt);
2720     __ vperm           (vRet, vRet, vTmp1, fromPerm);
2721 
2722     // load keylen (44 or 52 or 60)
2723     __ lwz             (keylen, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT), key);
2724 
2725     // to load keys
2726     __ lvsr            (keyPerm, key);
2727     __ vxor            (vTmp2, vTmp2, vTmp2);
2728     __ vspltisb        (vTmp2, -16);
2729     __ vrld            (keyPerm, keyPerm, vTmp2);
2730     __ vrld            (keyPerm, keyPerm, vTmp2);
<span class="changed">2731     __ vsldoi          (keyPerm, keyPerm, keyPerm, 8);</span>
2732 
2733     // load the 1st round key to vKey1
2734     __ li              (keypos, 0);
2735     __ lvx             (vKey1, keypos, key);
2736     __ addi            (keypos, keypos, 16);
2737     __ lvx             (vTmp1, keypos, key);
2738     __ vperm           (vKey1, vTmp1, vKey1, keyPerm);
2739 
2740     // 1st round
2741     __ vxor (vRet, vRet, vKey1);
2742 
2743     // load the 2nd round key to vKey1
2744     __ addi            (keypos, keypos, 16);
2745     __ lvx             (vTmp2, keypos, key);
2746     __ vperm           (vKey1, vTmp2, vTmp1, keyPerm);
2747 
2748     // load the 3rd round key to vKey2
2749     __ addi            (keypos, keypos, 16);
2750     __ lvx             (vTmp1, keypos, key);
2751     __ vperm           (vKey2, vTmp1, vTmp2, keyPerm);

</pre><hr></hr><pre>
2911     __ li              (hex, 16);
2912     __ li              (fifteen, 15);
2913     __ vspltisb        (fSplt, 0x0f);
2914 
2915     // load unaligned from[0-15] to vsRet
2916     __ lvx             (vRet, from);
2917     __ lvx             (vTmp1, fifteen, from);
2918     __ lvsl            (fromPerm, from);
2919     __ vxor            (fromPerm, fromPerm, fSplt);
2920     __ vperm           (vRet, vRet, vTmp1, fromPerm); // align [and byte swap in LE]
2921 
2922     // load keylen (44 or 52 or 60)
2923     __ lwz             (keylen, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT), key);
2924 
2925     // to load keys
2926     __ lvsr            (keyPerm, key);
2927     __ vxor            (vTmp2, vTmp2, vTmp2);
2928     __ vspltisb        (vTmp2, -16);
2929     __ vrld            (keyPerm, keyPerm, vTmp2);
2930     __ vrld            (keyPerm, keyPerm, vTmp2);
<span class="changed">2931     __ vsldoi          (keyPerm, keyPerm, keyPerm, 8);</span>
2932 
2933     __ cmpwi           (CCR0, keylen, 44);
2934     __ beq             (CCR0, L_do44);
2935 
2936     __ cmpwi           (CCR0, keylen, 52);
2937     __ beq             (CCR0, L_do52);
2938 
2939     // load the 15th round key to vKey11
2940     __ li              (keypos, 240);
2941     __ lvx             (vTmp1, keypos, key);
2942     __ addi            (keypos, keypos, -16);
2943     __ lvx             (vTmp2, keypos, key);
2944     __ vperm           (vKey1, vTmp1, vTmp2, keyPerm);
2945 
2946     // load the 14th round key to vKey10
2947     __ addi            (keypos, keypos, -16);
2948     __ lvx             (vTmp1, keypos, key);
2949     __ vperm           (vKey2, vTmp2, vTmp1, keyPerm);
2950 
2951     // load the 13th round key to vKey10

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/cpu/ppc/vm/macroAssembler_ppc.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> next &gt</center>
</body></html>

<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk10-hotspot-hg Sdiff src/cpu/ppc/vm </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/cpu/ppc/vm/assembler_ppc.inline.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/stubGenerator_ppc.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/cpu/ppc/vm/macroAssembler_ppc.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13010">13010</a> : Fix vsldoi interface according to ISA

vsldoi should accept a 5 bit unsigned integer and OpenJDK has set it as
5 bit signed integer.

Changed not only the interface but also all related code that was
adapted to use it as signed (hence -8 is now 8)</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
4547   offsetInt -= 8; std(R28, offsetInt, R1_SP);
4548   offsetInt -= 8; std(R29, offsetInt, R1_SP);
4549   offsetInt -= 8; std(R30, offsetInt, R1_SP);
4550   offsetInt -= 8; std(R31, offsetInt, R1_SP);
4551 
4552   // Set constants
4553   li(off16, 16);
4554   li(off32, 32);
4555   li(off48, 48);
4556   li(off64, 64);
4557   li(off80, 80);
4558   li(off96, 96);
4559   li(off112, 112);
4560 
4561   clrldi(crc, crc, 32);
4562 
4563   vxor(zeroes, zeroes, zeroes);
4564   vspltisw(VR0, -1);
4565 
4566   vsldoi(mask_32bit, zeroes, VR0, 4);
<span class="changed">4567   vsldoi(mask_64bit, zeroes, VR0, -8);</span>
4568 
4569   // Get the initial value into v8
4570   vxor(VR8, VR8, VR8);
4571   mtvrd(VR8, crc);
<span class="changed">4572   vsldoi(VR8, zeroes, VR8, -8); // shift into bottom 32 bits</span>
4573 
4574   li (rLoaded, 0);
4575 
4576   rldicr(rIdx, len, 0, 56);
4577 
4578   {
4579     BIND(L_1);
4580     // Checksum in blocks of MAX_SIZE (32768)
4581     lis(rMax, 0);
4582     ori(rMax, rMax, 32768);
4583     mr(rTmp2, rMax);
4584     cmpd(CCR0, rIdx, rMax);
4585     bgt(CCR0, L_2);
4586     mr(rMax, rIdx);
4587 
4588     BIND(L_2);
4589     subf(rIdx, rMax, rIdx);
4590 
4591     // our main loop does 128 bytes at a time
4592     srdi(rMax, rMax, 7);

</pre><hr></hr><pre>
4901 
4902   BIND(L_first_warm_up_done);
4903   lvx(const1, constantsPos);
4904   addi(constantsPos, constantsPos, 16);
4905   vpmsumd(VR8,  VR16, const1);
4906   vpmsumd(VR9,  VR17, const1);
4907   vpmsumd(VR10, VR18, const1);
4908   vpmsumd(VR11, VR19, const1);
4909   vpmsumd(VR12, VR20, const1);
4910   vpmsumd(VR13, VR21, const1);
4911   vpmsumd(VR14, VR22, const1);
4912   vpmsumd(VR15, VR23, const1);
4913   b(L_second_cool_down);
4914 
4915   BIND(L_barrett_reduction);
4916 
4917   lvx(const1, barretConstants);
4918   addi(barretConstants, barretConstants, 16);
4919   lvx(const2, barretConstants);
4920 
<span class="changed">4921   vsldoi(VR1, VR0, VR0, -8);</span>
4922   vxor(VR0, VR0, VR1);    // xor two 64 bit results together
4923 
4924   // shift left one bit
4925   vspltisb(VR1, 1);
4926   vsl(VR0, VR0, VR1);
4927 
4928   vand(VR0, VR0, mask_64bit);
4929 
4930   /*
4931    * The reflected version of Barrett reduction. Instead of bit
4932    * reflecting our data (which is expensive to do), we bit reflect our
4933    * constants and our algorithm, which means the intermediate data in
4934    * our vector registers goes from 0-63 instead of 63-0. We can reflect
4935    * the algorithm because we don't carry in mod 2 arithmetic.
4936    */
4937   vand(VR1, VR0, mask_32bit);  // bottom 32 bits of a
4938   vpmsumd(VR1, VR1, const1);   // ma
4939   vand(VR1, VR1, mask_32bit);  // bottom 32bits of ma
4940   vpmsumd(VR1, VR1, const2);   // qn */
4941   vxor(VR0, VR0, VR1);         // a - qn, subtraction is xor in GF(2)

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
4547   offsetInt -= 8; std(R28, offsetInt, R1_SP);
4548   offsetInt -= 8; std(R29, offsetInt, R1_SP);
4549   offsetInt -= 8; std(R30, offsetInt, R1_SP);
4550   offsetInt -= 8; std(R31, offsetInt, R1_SP);
4551 
4552   // Set constants
4553   li(off16, 16);
4554   li(off32, 32);
4555   li(off48, 48);
4556   li(off64, 64);
4557   li(off80, 80);
4558   li(off96, 96);
4559   li(off112, 112);
4560 
4561   clrldi(crc, crc, 32);
4562 
4563   vxor(zeroes, zeroes, zeroes);
4564   vspltisw(VR0, -1);
4565 
4566   vsldoi(mask_32bit, zeroes, VR0, 4);
<span class="changed">4567   vsldoi(mask_64bit, zeroes, VR0, 8);</span>
4568 
4569   // Get the initial value into v8
4570   vxor(VR8, VR8, VR8);
4571   mtvrd(VR8, crc);
<span class="changed">4572   vsldoi(VR8, zeroes, VR8, 8); // shift into bottom 32 bits</span>
4573 
4574   li (rLoaded, 0);
4575 
4576   rldicr(rIdx, len, 0, 56);
4577 
4578   {
4579     BIND(L_1);
4580     // Checksum in blocks of MAX_SIZE (32768)
4581     lis(rMax, 0);
4582     ori(rMax, rMax, 32768);
4583     mr(rTmp2, rMax);
4584     cmpd(CCR0, rIdx, rMax);
4585     bgt(CCR0, L_2);
4586     mr(rMax, rIdx);
4587 
4588     BIND(L_2);
4589     subf(rIdx, rMax, rIdx);
4590 
4591     // our main loop does 128 bytes at a time
4592     srdi(rMax, rMax, 7);

</pre><hr></hr><pre>
4901 
4902   BIND(L_first_warm_up_done);
4903   lvx(const1, constantsPos);
4904   addi(constantsPos, constantsPos, 16);
4905   vpmsumd(VR8,  VR16, const1);
4906   vpmsumd(VR9,  VR17, const1);
4907   vpmsumd(VR10, VR18, const1);
4908   vpmsumd(VR11, VR19, const1);
4909   vpmsumd(VR12, VR20, const1);
4910   vpmsumd(VR13, VR21, const1);
4911   vpmsumd(VR14, VR22, const1);
4912   vpmsumd(VR15, VR23, const1);
4913   b(L_second_cool_down);
4914 
4915   BIND(L_barrett_reduction);
4916 
4917   lvx(const1, barretConstants);
4918   addi(barretConstants, barretConstants, 16);
4919   lvx(const2, barretConstants);
4920 
<span class="changed">4921   vsldoi(VR1, VR0, VR0, 8);</span>
4922   vxor(VR0, VR0, VR1);    // xor two 64 bit results together
4923 
4924   // shift left one bit
4925   vspltisb(VR1, 1);
4926   vsl(VR0, VR0, VR1);
4927 
4928   vand(VR0, VR0, mask_64bit);
4929 
4930   /*
4931    * The reflected version of Barrett reduction. Instead of bit
4932    * reflecting our data (which is expensive to do), we bit reflect our
4933    * constants and our algorithm, which means the intermediate data in
4934    * our vector registers goes from 0-63 instead of 63-0. We can reflect
4935    * the algorithm because we don't carry in mod 2 arithmetic.
4936    */
4937   vand(VR1, VR0, mask_32bit);  // bottom 32 bits of a
4938   vpmsumd(VR1, VR1, const1);   // ma
4939   vand(VR1, VR1, mask_32bit);  // bottom 32bits of ma
4940   vpmsumd(VR1, VR1, const2);   // qn */
4941   vxor(VR0, VR0, VR1);         // a - qn, subtraction is xor in GF(2)

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/cpu/ppc/vm/assembler_ppc.inline.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/cpu/ppc/vm/stubGenerator_ppc.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
